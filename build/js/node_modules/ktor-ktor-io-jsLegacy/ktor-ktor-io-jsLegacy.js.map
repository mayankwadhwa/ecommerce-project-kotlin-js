{"version":3,"file":"ktor-ktor-io-jsLegacy.js","sources":["../../../../../ktor-io/common/src/io/ktor/utils/io/ByteChannelSequential.kt","generated/_ComparisonsJs.kt","util/Preconditions.kt","kotlin/UShort.kt","kotlin/UInt.kt","kotlin/ULong.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/charsets/Encoding.kt","text/StringBuilder.kt","kotlin/UByte.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryPrimitivesJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputArrays.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Buffers.kt","util/Standard.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteReadChannel.kt","coroutines/Continuation.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteChannelCtor.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Strings.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/concurrent/SharedJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Require.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Packet.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Buffer.kt","kotlin/math.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteWriteChannel.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Builder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ChannelLittleEndian.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/Coroutines.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ReadSession.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/WriterSession.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/ByteOrder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/Memory.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Numbers.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/MemoryFactory.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/MemoryPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/PrimiteArrays.kt","generated/_UArrays.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryFactoryJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Output.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/AbstractInput.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/PacketDirect.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Input.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/UTF8.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/AbstractOutput.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferAppend.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferCompatibility.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferFactory.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BytePacketBuilder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Preview.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/ByteReadPacket.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Closeable.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Copy.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Experimental.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputLittleEndian.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputPeek.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/OutputLittleEndian.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/OutputPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Scanner.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/UnsignedTypes.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Use.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt","../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Unsafe.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/errors/Errors.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/internal/AwaitingSlot.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/internal/SequentialCopyTo.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/pool/Pool.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ByteChannelJS.kt","generated/_Arrays.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ByteReadChannelJs.kt","util/Lazy.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ConditionJS.kt","util/Result.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ExceptionUtilsJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/NativeUtilsJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/ByteOrderJs.kt","kotlin/numbers_js-v1.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/PrimitiveArraysJs.kt","org.w3c/org.khronos.webgl.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/CharsetJS.kt","kotlin/text/string.kt","text/Strings.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/IoBufferJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/TextDecoders.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/DecodeBuffer.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/ISO88591.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ByteOrderJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ByteReadPacket.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/CloseableJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/InputArraysJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/InputJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/OutputJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/PacketJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ScannerJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/StringsJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/errors/IOException.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/TextEncoders.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/TypedArrays.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/WebSockets.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/XMLHttpRequest.kt","org.w3c/org.w3c.xhr.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/pool/DefaultPool.kt"],"sourcesContent":["package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlinx.atomicfu.locks.*\nimport kotlin.math.*\n\n@Deprecated(\"This is going to become internal. Use ByteReadChannel receiver instead.\", level = DeprecationLevel.ERROR)\nsuspend fun ByteChannelSequentialBase.joinTo(dst: ByteChannelSequentialBase, closeOnEnd: Boolean) {\n    return joinToImpl(dst, closeOnEnd)\n}\n\n@Deprecated(\"This is going to become internal. Use ByteReadChannel receiver instead.\", level = DeprecationLevel.ERROR)\nsuspend fun ByteChannelSequentialBase.copyTo(\n    dst: ByteChannelSequentialBase,\n    limit: Long = Long.MAX_VALUE\n): Long {\n    return copyToSequentialImpl(dst, limit)\n}\n\nprivate const val EXPECTED_CAPACITY: Long = 4088L\n\n/**\n * Sequential (non-concurrent) byte channel implementation\n */\n@Suppress(\"OverridingDeprecatedMember\")\n@DangerousInternalIoApi\nabstract class ByteChannelSequentialBase(\n    initial: IoBuffer,\n    override val autoFlush: Boolean,\n    pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n) : ByteChannel, ByteReadChannel, ByteWriteChannel, SuspendableReadSession, HasReadSession, HasWriteSession {\n\n    @Suppress(\"unused\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    constructor(initial: IoBuffer, autoFlush: Boolean) : this(initial, autoFlush, ChunkBuffer.Pool)\n\n    protected var closed: Boolean by shared(false)\n    protected val writable: BytePacketBuilder = BytePacketBuilder(0, pool)\n    protected val readable: ByteReadPacket = ByteReadPacket(initial, pool)\n\n    private val slot = AwaitingSlot()\n\n    private var waitingForRead by shared(1)\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun totalPending(): Int = availableForRead + writable.size\n\n    private val flushSize: Int get() = flushBuffer.size\n\n    override val availableForRead: Int\n        get() = flushSize + readable.remaining.toInt()\n\n    override val availableForWrite: Int\n        get() = maxOf(0, EXPECTED_CAPACITY.toInt() - totalPending())\n\n    override var readByteOrder: ByteOrder by shared(ByteOrder.BIG_ENDIAN)\n\n    override var writeByteOrder: ByteOrder by shared(ByteOrder.BIG_ENDIAN)\n\n    override val isClosedForRead: Boolean\n        get() = closed && readable.isEmpty && flushSize == 0 && writable.isEmpty\n\n    override val isClosedForWrite: Boolean\n        get() = closed\n\n    private var _totalBytesRead: Long by shared(0L)\n    override val totalBytesRead: Long get() = _totalBytesRead\n\n    private var _totalBytesWritten: Long by shared(0L)\n    override val totalBytesWritten: Long get() = _totalBytesWritten\n\n    final override var closedCause: Throwable? by shared(null)\n        private set\n\n    private val flushMutex = SynchronizedObject()\n    private val flushBuffer: BytePacketBuilder = BytePacketBuilder()\n\n    internal suspend fun awaitAtLeastNBytesAvailableForWrite(count: Int) {\n        while (availableForWrite < count && !closed) {\n            slot.sleep()\n        }\n    }\n\n    internal suspend fun awaitAtLeastNBytesAvailableForRead(count: Int) {\n        while (availableForRead < count && !closed) {\n            slot.sleep()\n        }\n    }\n\n    override fun flush() {\n        if (writable.isNotEmpty) {\n            flushWrittenBytes()\n            slot.resume()\n        }\n    }\n\n    /**\n     * Send bytes to thread-safe storage.\n     *\n     * This method is writer-only safe.\n     */\n    private fun flushWrittenBytes() {\n        synchronized(flushMutex) {\n            val buffer = writable.stealAll()!!\n            flushBuffer.writeChunkBuffer(buffer)\n        }\n    }\n\n    /**\n     * Take flushed bytes before read.\n     *\n     * This method is reader-only safe.\n     */\n    private fun prepareFlushedBytes() {\n        synchronized(flushMutex) {\n            readable.unsafeAppend(flushBuffer)\n        }\n    }\n\n    private fun ensureNotClosed() {\n        if (closed) {\n            throw closedCause ?: ClosedWriteChannelException(\"Channel is already closed\")\n        }\n    }\n\n    private fun ensureNotFailed() {\n        closedCause?.let { throw it }\n    }\n\n    private fun ensureNotFailed(closeable: BytePacketBuilder) {\n        closedCause?.let { cause ->\n            closeable.release()\n            throw cause\n        }\n    }\n\n    override suspend fun writeByte(b: Byte) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        writable.writeByte(b)\n        afterWrite(1)\n    }\n\n    private inline fun <T : Any> reverseWrite(value: () -> T, reversed: () -> T): T {\n        @Suppress(\"DEPRECATION_ERROR\")\n        return if (writeByteOrder == ByteOrder.BIG_ENDIAN) {\n            value()\n        } else {\n            reversed()\n        }\n    }\n\n    override suspend fun writeShort(s: Short) {\n        awaitAtLeastNBytesAvailableForWrite(2)\n        writable.writeShort(reverseWrite({ s }, { s.reverseByteOrder() }))\n        afterWrite(2)\n    }\n\n    override suspend fun writeInt(i: Int) {\n        awaitAtLeastNBytesAvailableForWrite(4)\n        writable.writeInt(reverseWrite({ i }, { i.reverseByteOrder() }))\n        afterWrite(4)\n    }\n\n    override suspend fun writeLong(l: Long) {\n        awaitAtLeastNBytesAvailableForWrite(8)\n        writable.writeLong(reverseWrite({ l }, { l.reverseByteOrder() }))\n        afterWrite(8)\n    }\n\n    override suspend fun writeFloat(f: Float) {\n        awaitAtLeastNBytesAvailableForWrite(4)\n        writable.writeFloat(reverseWrite({ f }, { f.reverseByteOrder() }))\n        afterWrite(4)\n    }\n\n    override suspend fun writeDouble(d: Double) {\n        awaitAtLeastNBytesAvailableForWrite(8)\n        writable.writeDouble(reverseWrite({ d }, { d.reverseByteOrder() }))\n        afterWrite(8)\n    }\n\n    override suspend fun writePacket(packet: ByteReadPacket) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        val size = packet.remaining.toInt()\n        writable.writePacket(packet)\n        afterWrite(size)\n    }\n\n    override suspend fun writeFully(src: IoBuffer) {\n        writeFully(src as Buffer)\n    }\n\n    override suspend fun writeFully(src: Buffer) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        val count = src.readRemaining\n        writable.writeFully(src)\n        afterWrite(count)\n    }\n\n    override suspend fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        var currentIndex = offset\n        val endIndex = offset + length\n\n        while (currentIndex < endIndex) {\n            awaitAtLeastNBytesAvailableForWrite(1)\n\n            val bytesCount = min(availableForWrite, endIndex - currentIndex)\n            writable.writeFully(src, currentIndex, bytesCount)\n\n            currentIndex += bytesCount\n            afterWrite(bytesCount)\n        }\n    }\n\n    override suspend fun writeFully(memory: Memory, startIndex: Int, endIndex: Int) {\n        var currentIndex = startIndex\n\n        while (currentIndex < endIndex) {\n            awaitAtLeastNBytesAvailableForWrite(1)\n\n            val bytesCount = min(availableForWrite, endIndex - currentIndex)\n            writable.writeFully(memory, currentIndex, bytesCount)\n\n            currentIndex += bytesCount\n            afterWrite(bytesCount)\n        }\n    }\n\n    override suspend fun writeAvailable(src: IoBuffer): Int {\n        val srcRemaining = src.readRemaining\n        if (srcRemaining == 0) return 0\n        val size = minOf(srcRemaining, availableForWrite)\n\n        return if (size == 0) writeAvailableSuspend(src)\n        else {\n            writable.writeFully(src, size)\n            afterWrite(size)\n            size\n        }\n    }\n\n    override suspend fun writeAvailable(src: ByteArray, offset: Int, length: Int): Int {\n        if (length == 0) return 0\n        val size = minOf(length, availableForWrite)\n\n        return if (size == 0) writeAvailableSuspend(src, offset, length)\n        else {\n            writable.writeFully(src, offset, size)\n            afterWrite(size)\n            size\n        }\n    }\n\n    @ExperimentalIoApi\n    @Suppress(\"DEPRECATION\")\n    override suspend fun writeSuspendSession(visitor: suspend WriterSuspendSession.() -> Unit) {\n        val session = beginWriteSession()\n        visitor(session)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    override fun beginWriteSession(): WriterSuspendSession {\n        return object : WriterSuspendSession {\n            override fun request(min: Int): IoBuffer? {\n                if (availableForWrite == 0) return null\n                return writable.prepareWriteHead(min) as IoBuffer\n            }\n\n            override fun written(n: Int) {\n                writable.afterHeadWrite()\n                afterWrite(n)\n            }\n\n            override fun flush() {\n                this@ByteChannelSequentialBase.flush()\n            }\n\n            override suspend fun tryAwait(n: Int) {\n                if (availableForWrite < n) {\n                    awaitAtLeastNBytesAvailableForWrite(n)\n                }\n            }\n        }\n    }\n\n    override fun endWriteSession(written: Int) {\n        writable.afterHeadWrite()\n        afterWrite(written)\n    }\n\n    override suspend fun readByte(): Byte {\n        return if (readable.isNotEmpty) {\n            readable.readByte().also { afterRead(1) }\n        } else {\n            readByteSlow()\n        }\n    }\n\n    private fun checkClosed(n: Int) {\n        if (closed) {\n            throw closedCause ?: prematureClose(n)\n        }\n    }\n\n    private fun prematureClose(n: Int): Exception {\n        return EOFException(\"$n bytes required but EOF reached\")\n    }\n\n    private suspend fun readByteSlow(): Byte {\n        do {\n            awaitSuspend(1)\n\n            if (readable.isNotEmpty) return readable.readByte().also { afterRead(1) }\n            checkClosed(1)\n        } while (true)\n    }\n\n    override suspend fun readShort(): Short {\n        return if (readable.hasBytes(2)) {\n            readable.readShort().reverseRead().also { afterRead(2) }\n        } else {\n            readShortSlow()\n        }\n    }\n\n    private suspend fun readShortSlow(): Short {\n        readNSlow(2) { return readable.readShort().reverseRead().also { afterRead(2) } }\n    }\n\n    @Deprecated(\"Consider providing consumed count of bytes\", level = DeprecationLevel.ERROR)\n    protected fun afterRead() {\n        afterRead(0)\n    }\n\n    protected fun afterRead(count: Int) {\n        _totalBytesRead += count\n        slot.resume()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Short.reverseRead(): Short = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Int.reverseRead(): Int = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Long.reverseRead(): Long = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Float.reverseRead(): Float = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Double.reverseRead(): Double = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    override suspend fun readInt(): Int {\n        return if (readable.hasBytes(4)) {\n            readable.readInt().reverseRead().also { afterRead(4) }\n        } else {\n            readIntSlow()\n        }\n    }\n\n    private suspend fun readIntSlow(): Int {\n        readNSlow(4) {\n            return readable.readInt().reverseRead().also { afterRead(4) }\n        }\n    }\n\n    override suspend fun readLong(): Long {\n        return if (readable.hasBytes(8)) {\n            readable.readLong().reverseRead().also { afterRead(8) }\n        } else {\n            readLongSlow()\n        }\n    }\n\n    private suspend fun readLongSlow(): Long {\n        readNSlow(8) {\n            return readable.readLong().reverseRead().also { afterRead(8) }\n        }\n    }\n\n    override suspend fun readFloat(): Float = if (readable.hasBytes(4)) {\n        readable.readFloat().reverseRead().also { afterRead(4) }\n    } else {\n        readFloatSlow()\n    }\n\n    private suspend fun readFloatSlow(): Float {\n        readNSlow(4) {\n            return readable.readFloat().reverseRead().also { afterRead(4) }\n        }\n    }\n\n    override suspend fun readDouble(): Double = if (readable.hasBytes(8)) {\n        readable.readDouble().reverseRead().also { afterRead(8) }\n    } else {\n        readDoubleSlow()\n    }\n\n    private suspend fun readDoubleSlow(): Double {\n        readNSlow(8) {\n            return readable.readDouble().reverseRead().also { afterRead(8) }\n        }\n    }\n\n    override suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket {\n        ensureNotFailed()\n\n        val builder = BytePacketBuilder(headerSizeHint)\n\n        val size = minOf(limit, readable.remaining)\n        builder.writePacket(readable, size)\n        val remaining = limit - builder.size\n\n        return if (remaining == 0L || isClosedForRead) {\n            afterRead(remaining.toInt())\n            ensureNotFailed(builder)\n            builder.build()\n        } else {\n            readRemainingSuspend(builder, limit)\n        }\n    }\n\n    private suspend fun readRemainingSuspend(builder: BytePacketBuilder, limit: Long): ByteReadPacket {\n        while (builder.size < limit) {\n            val partLimit = minOf(limit - builder.size, readable.remaining)\n            builder.writePacket(readable, partLimit)\n            afterRead(partLimit.toInt())\n            ensureNotFailed(builder)\n\n            if (isClosedForRead || builder.size == limit.toInt()) {\n                break\n            }\n\n            awaitSuspend(1)\n        }\n\n        ensureNotFailed(builder)\n        return builder.build()\n    }\n\n    override suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket {\n        val builder = BytePacketBuilder(headerSizeHint)\n\n        var remaining = size\n        val partSize = minOf(remaining.toLong(), readable.remaining).toInt()\n        remaining -= partSize\n        builder.writePacket(readable, partSize)\n        afterRead(partSize)\n\n        return if (remaining > 0) readPacketSuspend(builder, remaining)\n        else builder.build()\n    }\n\n    private suspend fun readPacketSuspend(builder: BytePacketBuilder, size: Int): ByteReadPacket {\n        var remaining = size\n        while (remaining > 0) {\n            val partSize = minOf(remaining.toLong(), readable.remaining).toInt()\n            remaining -= partSize\n            builder.writePacket(readable, partSize)\n            afterRead(partSize)\n\n            if (remaining > 0) {\n                awaitSuspend(1)\n            }\n        }\n\n        return builder.build()\n    }\n\n    protected fun readAvailableClosed(): Int {\n        closedCause?.let { throw it }\n        return -1\n    }\n\n    override suspend fun readAvailable(dst: IoBuffer): Int = readAvailable(dst as Buffer)\n\n    internal suspend fun readAvailable(dst: Buffer): Int = when {\n        closedCause != null -> throw closedCause!!\n        readable.canRead() -> {\n            val size = minOf(dst.writeRemaining.toLong(), readable.remaining).toInt()\n            readable.readFully(dst, size)\n            afterRead(size)\n            size\n        }\n        closed -> readAvailableClosed()\n        !dst.canWrite() -> 0\n        else -> readAvailableSuspend(dst)\n    }\n\n    private suspend fun readAvailableSuspend(dst: Buffer): Int {\n        awaitSuspend(1)\n        return readAvailable(dst)\n    }\n\n    override suspend fun readFully(dst: IoBuffer, n: Int) {\n        readFully(dst as Buffer, n)\n    }\n\n    private suspend fun readFully(dst: Buffer, n: Int) {\n        require(n <= dst.writeRemaining) { \"Not enough space in the destination buffer to write $n bytes\" }\n        require(n >= 0) { \"n shouldn't be negative\" }\n\n        return when {\n            closedCause != null -> throw closedCause!!\n            readable.remaining >= n -> readable.readFully(dst, n).also { afterRead(n) }\n            closed -> throw EOFException(\"Channel is closed and not enough bytes available: required $n but $availableForRead available\")\n            else -> readFullySuspend(dst, n)\n        }\n    }\n\n    private suspend fun readFullySuspend(dst: Buffer, n: Int) {\n        awaitSuspend(n)\n        return readFully(dst, n)\n    }\n\n    override suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int = when {\n        readable.canRead() -> {\n            val size = minOf(length.toLong(), readable.remaining).toInt()\n            readable.readFully(dst, offset, size)\n            afterRead(size)\n            size\n        }\n        closed -> readAvailableClosed()\n        else -> readAvailableSuspend(dst, offset, length)\n    }\n\n    private suspend fun readAvailableSuspend(dst: ByteArray, offset: Int, length: Int): Int {\n        awaitSuspend(1)\n        return readAvailable(dst, offset, length)\n    }\n\n    override suspend fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc == length) return\n        if (rc == -1) throw EOFException(\"Unexpected end of stream\")\n\n        return readFullySuspend(dst, offset + rc, length - rc)\n    }\n\n    private suspend fun readFullySuspend(dst: ByteArray, offset: Int, length: Int) {\n        var written = 0\n\n        while (written < length) {\n            val rc = readAvailable(dst, offset + written, length - written)\n            if (rc == -1) throw EOFException(\"Unexpected end of stream\")\n            written += rc\n        }\n    }\n\n    override suspend fun readBoolean(): Boolean {\n        return if (readable.canRead()) (readable.readByte() == 1.toByte()).also { afterRead(1) }\n        else readBooleanSlow()\n    }\n\n    private suspend fun readBooleanSlow(): Boolean {\n        awaitSuspend(1)\n        checkClosed(1)\n        return readBoolean()\n    }\n\n    private var lastReadAvailable by shared(0)\n    private var lastReadView: ChunkBuffer by shared(ChunkBuffer.Empty)\n\n    private fun completeReading() {\n        val remaining = lastReadView.readRemaining\n        val delta = lastReadAvailable - remaining\n        if (lastReadView !== Buffer.Empty) {\n            readable.completeReadHead(lastReadView)\n        }\n        if (delta > 0) {\n            afterRead(delta)\n        }\n        lastReadAvailable = 0\n        lastReadView = ChunkBuffer.Empty\n    }\n\n    override suspend fun await(atLeast: Int): Boolean {\n        require(atLeast >= 0) { \"atLeast parameter shouldn't be negative: $atLeast\" }\n        require(atLeast <= EXPECTED_CAPACITY) { \"atLeast parameter shouldn't be larger than max buffer size of $EXPECTED_CAPACITY: $atLeast\" }\n\n        completeReading()\n\n        if (atLeast == 0) return !isClosedForRead\n        if (readable.remaining >= atLeast) return true\n\n        return awaitSuspend(atLeast)\n    }\n\n    internal suspend fun awaitInternalAtLeast1(): Boolean = if (readable.isNotEmpty) {\n        true\n    } else {\n        awaitSuspend(1)\n    }\n\n    protected suspend fun awaitSuspend(atLeast: Int): Boolean {\n        require(atLeast >= 0)\n\n        awaitAtLeastNBytesAvailableForRead(atLeast)\n        prepareFlushedBytes()\n\n        closedCause?.let { throw it }\n        return !isClosedForRead && availableForRead >= atLeast\n    }\n\n    override fun discard(n: Int): Int {\n        closedCause?.let { throw it }\n\n        if (n == 0) {\n            return 0\n        }\n\n        return readable.discard(n).also {\n            afterRead(n)\n            requestNextView(1)\n        }\n    }\n\n    override fun request(atLeast: Int): IoBuffer? {\n        closedCause?.let { throw it }\n\n        completeReading()\n\n        return requestNextView(atLeast)\n    }\n\n    private fun requestNextView(atLeast: Int): IoBuffer? {\n        if (readable.isEmpty) {\n            prepareFlushedBytes()\n        }\n\n        val view = readable.prepareReadHead(atLeast) as IoBuffer?\n\n        if (view == null) {\n            lastReadView = ChunkBuffer.Empty\n            lastReadAvailable = 0\n        } else {\n            lastReadView = view\n            lastReadAvailable = view.readRemaining\n        }\n\n        return view\n    }\n\n    override suspend fun discard(max: Long): Long {\n        val discarded = readable.discard(max)\n\n        return if (discarded == max || isClosedForRead) return discarded\n        else discardSuspend(max, discarded)\n    }\n\n    private suspend fun discardSuspend(max: Long, discarded0: Long): Long {\n        var discarded = discarded0\n\n        do {\n            if (!await(1)) break\n            discarded += readable.discard(max - discarded)\n        } while (discarded < max && !isClosedForRead)\n\n        return discarded\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read instead.\")\n    override fun readSession(consumer: ReadSession.() -> Unit) {\n        try {\n            consumer(this)\n        } finally {\n            completeReading()\n        }\n    }\n\n    override fun startReadSession(): SuspendableReadSession = this\n\n    override fun endReadSession() {\n        completeReading()\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read instead.\")\n    override suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit) {\n        try {\n            consumer(this)\n        } finally {\n            completeReading()\n        }\n    }\n\n    override suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean {\n        if (isClosedForRead) {\n            val cause = closedCause\n            if (cause != null) {\n                throw cause\n            }\n\n            return false\n        }\n        @OptIn(DangerousInternalIoApi::class)\n        return decodeUTF8LineLoopSuspend(out, limit) { size ->\n            afterRead(size)\n            if (await(size)) readable\n            else null\n        }\n    }\n\n    override suspend fun readUTF8Line(limit: Int): String? {\n        val sb = StringBuilder()\n        if (!readUTF8LineTo(sb, limit)) {\n            return null\n        }\n\n        return sb.toString()\n    }\n\n    override fun cancel(cause: Throwable?): Boolean {\n        if (closedCause != null || closed) {\n            return false\n        }\n\n        return close(cause ?: io.ktor.utils.io.CancellationException(\"Channel cancelled\"))\n    }\n\n    override fun close(cause: Throwable?): Boolean {\n        if (closed || closedCause != null) return false\n        closedCause = cause\n        closed = true\n        if (cause != null) {\n            readable.release()\n            writable.release()\n            flushBuffer.release()\n        } else {\n            flush()\n        }\n\n        slot.cancel(cause)\n        return true\n    }\n\n    internal fun transferTo(dst: ByteChannelSequentialBase, limit: Long): Long {\n        val size = readable.remaining\n        return if (size <= limit) {\n            dst.writable.writePacket(readable)\n            dst.afterWrite(size.toInt())\n            afterRead(size.toInt())\n            size\n        } else {\n            0\n        }\n    }\n\n    private suspend inline fun readNSlow(n: Int, block: () -> Nothing): Nothing {\n        do {\n            awaitSuspend(n)\n\n            if (readable.hasBytes(n)) block()\n            checkClosed(n)\n        } while (true)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    private suspend fun writeAvailableSuspend(src: IoBuffer): Int {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        return writeAvailable(src)\n    }\n\n    private suspend fun writeAvailableSuspend(src: ByteArray, offset: Int, length: Int): Int {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        return writeAvailable(src, offset, length)\n    }\n\n    @Deprecated(\"Consider providing written count of bytes\", level = DeprecationLevel.ERROR)\n    protected fun afterWrite() {\n        afterWrite(0)\n    }\n\n    protected fun afterWrite(count: Int) {\n        _totalBytesWritten += count\n\n        if (closed) {\n            writable.release()\n            ensureNotClosed()\n        }\n        if (autoFlush || availableForWrite == 0) {\n            flush()\n        }\n    }\n\n    override suspend fun awaitFreeSpace() {\n        flush()\n        awaitAtLeastNBytesAvailableForWrite(1)\n        ensureNotClosed()\n    }\n\n    final override suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long {\n        var bytesCopied = 0L\n\n        @Suppress(\"DEPRECATION\")\n        readSuspendableSession {\n            val desiredSize = (min + offset).coerceAtMost(EXPECTED_CAPACITY).toInt()\n\n            await(desiredSize)\n\n            val buffer = request(1) ?: IoBuffer.Empty\n            if (buffer.readRemaining > offset) {\n                buffer.discardExact(offset)\n                bytesCopied = minOf(buffer.readRemaining.toLong(), max)\n                buffer.memory.copyTo(destination, buffer.readPosition.toLong(), bytesCopied, destinationOffset)\n            }\n        }\n\n        return bytesCopied\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\n\nexpect abstract class Charset {\n    @ExperimentalIoApi\n    abstract fun newEncoder(): CharsetEncoder\n\n    @ExperimentalIoApi\n    abstract fun newDecoder(): CharsetDecoder\n\n    companion object {\n        fun forName(name: String): Charset\n    }\n}\n\nexpect val Charset.name: String\n\n// ----------------------------- ENCODER -------------------------------------------------------------------------------\n@ExperimentalIoApi\nexpect abstract class CharsetEncoder\n\nexpect val CharsetEncoder.charset: Charset\n\n@Deprecated(\n    \"Use writeText on Output instead.\",\n    ReplaceWith(\"dst.writeText(input, fromIndex, toIndex, charset)\", \"io.ktor.utils.io.core.writeText\")\n)\nfun CharsetEncoder.encode(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Output) {\n    encodeToImpl(dst, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\nexpect fun CharsetEncoder.encodeToByteArray(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray\n\n@Deprecated(\n    \"Internal API. Will be hidden in future releases. Use encodeToByteArray instead.\",\n    replaceWith = ReplaceWith(\"encodeToByteArray(input, fromIndex, toIndex)\")\n)\nfun CharsetEncoder.encodeToByteArrayImpl(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    return encodeToByteArray(input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\nexpect fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output)\n\n@ExperimentalIoApi\nfun CharsetEncoder.encode(input: CharSequence, fromIndex: Int = 0, toIndex: Int = input.length) = buildPacket {\n    encodeToImpl(this, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\nfun CharsetEncoder.encodeUTF8(input: ByteReadPacket) = buildPacket {\n    encodeUTF8(input, this)\n}\n\n\n@ExperimentalIoApi\nfun CharsetEncoder.encode(input: CharArray, fromIndex: Int, toIndex: Int, dst: Output) {\n    var start = fromIndex\n\n    if (start >= toIndex) return\n    dst.writeWhileSize(1) { view: Buffer ->\n        val rc = encodeArrayImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    encodeCompleteImpl(dst)\n}\n\n\n// ----------------------------- DECODER -------------------------------------------------------------------------------\n\n@ExperimentalIoApi\nexpect abstract class CharsetDecoder\n\n/**\n * Decoder's charset it is created for.\n */\nexpect val CharsetDecoder.charset: Charset\n\n@ExperimentalIoApi\nfun CharsetDecoder.decode(input: Input, max: Int = Int.MAX_VALUE): String =\n    buildString(minOf(max.toLong(), input.sizeEstimate()).toInt()) {\n        decode(input, this, max)\n    }\n\n@ExperimentalIoApi\nexpect fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int\n\n@ExperimentalIoApi\nexpect fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String\n\n// ----------------------------- REGISTRY ------------------------------------------------------------------------------\nexpect object Charsets {\n    val UTF_8: Charset\n    val ISO_8859_1: Charset\n}\n\nexpect open class MalformedInputException(message: String) : Throwable\n\n\nclass TooLongLineException(message: String) : MalformedInputException(message)\n\n// ----------------------------- INTERNALS -----------------------------------------------------------------------------\n\ninternal fun CharsetEncoder.encodeArrayImpl(input: CharArray, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    val length = toIndex - fromIndex\n    return encodeImpl(CharArraySequence(input, fromIndex, length), 0, length, dst)\n}\n\ninternal expect fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int\n\ninternal expect fun CharsetEncoder.encodeComplete(dst: Buffer): Boolean\n\ninternal expect fun CharsetDecoder.decodeBuffer(\n    input: Buffer,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int = Int.MAX_VALUE\n): Int\n\ninternal fun CharsetEncoder.encodeToByteArrayImpl1(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    var start = fromIndex\n    if (start >= toIndex) return EmptyByteArray\n    val single = ChunkBuffer.Pool.borrow()\n\n    try {\n        val rc = encodeImpl(input, start, toIndex, single)\n        start += rc\n        if (start == toIndex) {\n            val result = ByteArray(single.readRemaining)\n            single.readFully(result)\n            return result\n        }\n\n        return buildPacket {\n            appendSingleChunk(single.duplicate())\n            encodeToImpl(this, input, start, toIndex)\n        }.readBytes()\n    } finally {\n        single.release(ChunkBuffer.Pool)\n    }\n}\n\ninternal fun Input.sizeEstimate(): Long = when (this) {\n    is ByteReadPacket -> remaining\n    is AbstractInput -> maxOf(remaining, 16)\n    else -> 16\n}\n\n\nprivate fun CharsetEncoder.encodeCompleteImpl(dst: Output): Int {\n    var size = 1\n    var bytesWritten = 0\n\n    dst.writeWhile { view ->\n        val before = view.writeRemaining\n        if (encodeComplete(view)) {\n            size = 0\n        } else {\n            size++\n        }\n        bytesWritten += before - view.writeRemaining\n        size > 0\n    }\n\n    return bytesWritten\n}\n\ninternal fun CharsetEncoder.encodeToImpl(\n    destination: Output,\n    input: CharSequence,\n    fromIndex: Int,\n    toIndex: Int\n): Int {\n    var start = fromIndex\n    if (start >= toIndex) return 0\n\n    var bytesWritten = 0\n\n    destination.writeWhileSize(1) { view: Buffer ->\n        val before = view.writeRemaining\n        val rc = encodeImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n        bytesWritten += before - view.writeRemaining\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    bytesWritten += encodeCompleteImpl(destination)\n    return bytesWritten\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\n\n\nactual inline fun Memory.loadShortAt(offset: Int): Short = view.getInt16(offset, false)\n\nactual inline fun Memory.loadShortAt(offset: Long): Short = loadShortAt(offset.toIntOrFail(\"offset\"))\n\nactual inline fun Memory.loadIntAt(offset: Int): Int = view.getInt32(offset, false)\n\nactual inline fun Memory.loadIntAt(offset: Long): Int = loadIntAt(offset.toIntOrFail(\"offset\"))\n\nactual inline fun Memory.loadLongAt(offset: Int): Long =\n    (view.getUint32(offset, false).toLong() shl 32) or\n        view.getUint32(offset + 4, false).toLong()\n\nactual inline fun Memory.loadLongAt(offset: Long): Long = loadLongAt(offset.toIntOrFail(\"offset\"))\n\nactual inline fun Memory.loadFloatAt(offset: Int): Float = view.getFloat32(offset, false)\n\nactual inline fun Memory.loadFloatAt(offset: Long): Float = loadFloatAt(offset.toIntOrFail(\"offset\"))\n\nactual inline fun Memory.loadDoubleAt(offset: Int): Double = view.getFloat64(offset, false)\n\nactual inline fun Memory.loadDoubleAt(offset: Long): Double = loadDoubleAt(offset.toIntOrFail(\"offset\"))\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeIntAt(offset: Int, value: Int) {\n    view.setInt32(offset, value, littleEndian = false)\n}\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeIntAt(offset: Long, value: Int) {\n    view.setInt32(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeShortAt(offset: Int, value: Short) {\n    view.setInt16(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeShortAt(offset: Long, value: Short) {\n    view.setInt16(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeLongAt(offset: Int, value: Long) {\n    view.setInt32(offset, (value shr 32).toInt(), littleEndian = false)\n    view.setInt32(offset + 4, (value and 0xffffffffL).toInt(), littleEndian = false)\n}\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeLongAt(offset: Long, value: Long) {\n    storeLongAt(offset.toIntOrFail(\"offset\"), value)\n}\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeFloatAt(offset: Int, value: Float) {\n    view.setFloat32(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeFloatAt(offset: Long, value: Float) {\n    view.setFloat32(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeDoubleAt(offset: Int, value: Double) {\n    view.setFloat64(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\nactual inline fun Memory.storeDoubleAt(offset: Long, value: Double) {\n    view.setFloat64(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyBytesTemplate(offset, length) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 2) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: Buffer, length: Int = dst.writeRemaining) {\n    readFullyBytesTemplate(0, length) { src, _, count ->\n        src.readFully(dst, count)\n    }.requireNoRemaining()\n}\n\nfun Input.readFully(destination: Memory, destinationOffset: Int, length: Int) {\n    readFully(destination, destinationOffset.toLong(), length.toLong())\n}\n\nfun Input.readFully(destination: Memory, destinationOffset: Long, length: Long) {\n    if (readAvailable(destination, destinationOffset, length) != length) {\n        prematureEndOfStream(length)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyBytesTemplate(offset, length) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 2) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\nfun Input.readAvailable(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    return length - readFullyBytesTemplate(0, length) { src, _, count ->\n        src.readFully(dst, count)\n    }\n}\n\nfun Input.readAvailable(destination: Memory, destinationOffset: Int, length: Int): Int {\n    return readAvailable(destination, destinationOffset.toLong(), length.toLong()).toInt()\n}\n\nfun Input.readAvailable(destination: Memory, destinationOffset: Long, length: Long): Long {\n    val remaining = readFullyBytesTemplate(destinationOffset, length) { src, srcOffset, dstOffset, count ->\n        src.copyTo(destination, srcOffset, count.toLong(), dstOffset)\n    }\n    val result = length - remaining\n    return when {\n        result == 0L && endOfInput -> -1\n        else -> result\n    }\n}\n\n/**\n * @return number of bytes remaining or 0 if all [length] bytes were copied\n */\nprivate inline fun Input.readFullyBytesTemplate(\n    initialDstOffset: Int,\n    length: Int,\n    readBlock: (src: Buffer, dstOffset: Int, count: Int) -> Unit\n): Int {\n    var remaining = length\n    var dstOffset = initialDstOffset\n\n    takeWhile { buffer ->\n        val count = minOf(remaining, buffer.readRemaining)\n        readBlock(buffer, dstOffset, count)\n        remaining -= count\n        dstOffset += count\n\n        remaining > 0\n    }\n\n    return remaining\n}\n\n/**\n * @return number of bytes remaining or 0 if all [length] bytes were copied\n */\nprivate inline fun Input.readFullyBytesTemplate(\n    initialDstOffset: Long,\n    length: Long,\n    readBlock: (src: Memory, srcOffset: Long, dstOffset: Long, count: Int) -> Unit\n): Long {\n    var remaining = length\n    var dstOffset = initialDstOffset\n\n    takeWhile { buffer ->\n        val count = minOf(remaining, buffer.readRemaining.toLong()).toInt()\n        readBlock(buffer.memory, buffer.readPosition.toLong(), dstOffset, count)\n        buffer.discardExact(count)\n        remaining -= count\n        dstOffset += count\n\n        remaining > 0\n    }\n\n    return remaining\n}\n\n/**\n * @return number of elements remaining or 0 if all [length] elements were copied\n */\nprivate inline fun Input.readFullyTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    readBlock: (src: Buffer, dstOffset: Int, count: Int) -> Unit\n): Int {\n    var remaining = length\n    var dstOffset = offset\n\n    takeWhileSize { buffer ->\n        val count = minOf(remaining, buffer.readRemaining / componentSize)\n        readBlock(buffer, dstOffset, count)\n        remaining -= count\n        dstOffset += count\n\n        when {\n            remaining > 0 -> componentSize\n            else -> 0\n        }\n    }\n\n    return remaining\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Int.requireNoRemaining() {\n    if (this > 0) {\n        prematureEndOfStream(this)\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.contracts.*\n\n/**\n * A read-write facade to actual buffer of fixed size. Multiple views could share the same actual buffer.\n * Concurrent unsafe. The only concurrent-safe operation is [release].\n * In most cases [ByteReadPacket] and [BytePacketBuilder] should be used instead.\n */\n@Suppress(\"DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES\", \"DEPRECATION\")\n@Deprecated(\"Use Memory, Input or Output instead.\")\nexpect class IoBuffer : Input, Output, ChunkBuffer {\n\n    @Suppress(\"ConvertSecondaryConstructorToPrimary\")\n    constructor(memory: Memory, origin: ChunkBuffer?)\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n            \"do readXXX/writeXXX with X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder\n\n    override fun close()\n\n    final override fun flush()\n\n    fun release(pool: ObjectPool<IoBuffer>)\n\n    @Suppress(\"DEPRECATION\")\n    companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [ChunkBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        val ReservedSize: Int\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        val Empty: IoBuffer\n\n        /**\n         * The default buffer pool\n         */\n        val Pool: ObjectPool<IoBuffer>\n\n        /**\n         * Pool that always instantiates new buffers instead of reusing it\n         */\n        val NoPool: ObjectPool<IoBuffer>\n\n        /**\n         * A pool that always returns [IoBuffer.Empty]\n         */\n        val EmptyPool: ObjectPool<IoBuffer>\n    }\n}\n\n/**\n * Read the specified number of bytes specified (optional, read all remaining by default)\n */\nfun Buffer.readBytes(count: Int = readRemaining): ByteArray {\n    if (count == 0) {\n        return EmptyByteArray\n    }\n\n    val result = ByteArray(count)\n    readFully(result)\n    return result\n}\n\n@Suppress(\"DEPRECATION\")\ninternal fun IoBuffer.releaseImpl(pool: ObjectPool<IoBuffer>) {\n    if (release()) {\n        val origin = origin\n        if (origin is IoBuffer) {\n            unlink()\n            origin.release(pool)\n        } else {\n            pool.recycle(this)\n        }\n    }\n}\n\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\ninternal object EmptyBufferPoolImpl : NoPoolImpl<IoBuffer>() {\n    override fun borrow() = IoBuffer.Empty\n}\n\ninternal tailrec fun ChunkBuffer?.releaseAll(pool: ObjectPool<ChunkBuffer>) {\n    if (this == null) return\n    val next = cleanNext()\n    release(pool)\n    next.releaseAll(pool)\n}\n\ninternal inline fun ChunkBuffer.forEachChunk(block: (ChunkBuffer) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    var current = this\n    do {\n        block(current)\n        current = current.next ?: break\n    } while (true)\n}\n\n/**\n * Copy every element of the chain starting from this and setup next links.\n */\ninternal fun ChunkBuffer.copyAll(): ChunkBuffer {\n    val copied = duplicate()\n    val next = this.next ?: return copied\n\n    return next.copyAll(copied, copied)\n}\n\nprivate tailrec fun ChunkBuffer.copyAll(head: ChunkBuffer, prev: ChunkBuffer): ChunkBuffer {\n    val copied = duplicate()\n    prev.next = copied\n\n    val next = this.next ?: return head\n\n    return next.copyAll(head, copied)\n}\n\ninternal tailrec fun ChunkBuffer.findTail(): ChunkBuffer {\n    val next = this.next ?: return this\n    return next.findTail()\n}\n\n/**\n * Summarize remainings of all elements of the chain\n */\n@DangerousInternalIoApi\nfun ChunkBuffer.remainingAll(): Long = remainingAll(0L)\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun remainingAll(buffer: IoBuffer): Long = buffer.remainingAll()\n\nprivate tailrec fun ChunkBuffer.remainingAll(n: Long): Long {\n    val rem = readRemaining.toLong() + n\n    val next = this.next ?: return rem\n\n    return next.remainingAll(rem)\n}\n\ninternal tailrec fun ChunkBuffer.isEmpty(): Boolean {\n    if (readRemaining > 0) return false\n    val next = this.next ?: return true\n    return next.isEmpty()\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxInt(): Int = minOf(this, Int.MAX_VALUE.toLong()).toInt()\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxIntOrFail(message: String): Int {\n    if (this > Int.MAX_VALUE.toLong()) throw IllegalArgumentException(message)\n    return this.toInt()\n}\n\ninternal fun Buffer.peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n    val size = minOf(\n        destination.size - destinationOffset,\n        max,\n        readRemaining.toLong()\n    )\n\n    memory.copyTo(\n        destination,\n        readPosition + offset,\n        size,\n        destinationOffset\n    )\n\n    return size\n}\n\nclass BufferLimitExceededException(message: String) : Exception(message)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous reading of sequences of bytes.\n * This is a **single-reader channel**.\n *\n * Operations on this channel cannot be invoked concurrently.\n */\nexpect interface ByteReadChannel {\n    /**\n     * Returns number of bytes that can be read without suspension. Read operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for read.\n     */\n    val availableForRead: Int\n\n    /**\n     * Returns `true` if the channel is closed and no remaining bytes are available for read.\n     * It implies that [availableForRead] is zero.\n     */\n    val isClosedForRead: Boolean\n\n    val isClosedForWrite: Boolean\n\n    /**\n     * Byte order that is used for multi-byte read operations\n     * (such as [readShort], [readInt], [readLong], [readFloat], and [readDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    var readByteOrder: ByteOrder\n\n    /**\n     * Number of bytes read from the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of long running read operation.\n     */\n    val totalBytesRead: Long\n\n    /**\n     * Reads all available bytes to [dst] buffer and returns immediately or suspends if no bytes available\n     * @return number of bytes were read or `-1` if the channel has been closed\n     */\n    suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    suspend fun readAvailable(dst: IoBuffer): Int\n\n    /**\n     * Reads all [length] bytes to [dst] buffer or fails if channel has been closed.\n     * Suspends if not enough bytes available.\n     */\n    suspend fun readFully(dst: ByteArray, offset: Int, length: Int)\n    suspend fun readFully(dst: IoBuffer, n: Int)\n\n    /**\n     * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n     * and not enough bytes available. Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n     * Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads a long number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    suspend fun readLong(): Long\n\n    /**\n     * Reads an int number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    suspend fun readInt(): Int\n\n    /**\n     * Reads a short number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    suspend fun readShort(): Short\n\n    /**\n     * Reads a byte (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    suspend fun readByte(): Byte\n\n    /**\n     * Reads a boolean value (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    suspend fun readBoolean(): Boolean\n\n    /**\n     * Reads double number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    suspend fun readDouble(): Double\n\n    /**\n     * Reads float number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    suspend fun readFloat(): Float\n\n\n    /**\n     * Starts non-suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * event if there are no bytes available for read yet.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    fun readSession(consumer: ReadSession.() -> Unit)\n\n    /**\n     * Starts a suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * even if there are no bytes available for read yet. [consumer] lambda could suspend as much as needed.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit)\n\n    /**\n     * Reads a line of UTF-8 characters to the specified [out] buffer up to [limit] characters.\n     * Supports both CR-LF and LF line endings. No line ending characters will be appended to [out] buffer.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return `true` if line has been read (possibly empty) or `false` if channel has been closed\n     * and no characters were read.\n     */\n    suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean\n\n    /**\n     * Reads a line of UTF-8 characters up to [limit] characters.\n     * Supports both CR-LF and LF line endings.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return a line string with no line endings or `null` of channel has been closed\n     * and no characters were read.\n     */\n    suspend fun readUTF8Line(limit: Int): String?\n\n    /**\n     * Close channel with optional [cause] cancellation. Unlike [ByteWriteChannel.close] that could close channel\n     * normally, cancel does always close with error so any operations on this channel will always fail\n     * and all suspensions will be resumed with exception.\n     *\n     * Please note that if the channel has been provided by [reader] or [writer] then the corresponding owning\n     * coroutine will be cancelled as well\n     *\n     * @see ByteWriteChannel.close\n     */\n    fun cancel(cause: Throwable?): Boolean\n\n    /**\n     * Discard up to [max] bytes\n     *\n     * @return number of bytes were discarded\n     */\n    suspend fun discard(max: Long): Long\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source suspending reading.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [isClosedForRead].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long = 0,\n        min: Long = 1,\n        max: Long = Long.MAX_VALUE\n    ): Long\n\n    companion object {\n        val Empty: ByteReadChannel\n    }\n}\n\n/**\n * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n * and not enough bytes available.\n */\nsuspend fun ByteReadChannel.readPacket(size: Int): ByteReadPacket = readPacket(size, 0)\n\n/**\n * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n */\nsuspend fun ByteReadChannel.readRemaining(limit: Long): ByteReadPacket = readRemaining(limit, 0)\n\n/**\n * Reads all remaining bytes and makes a byte packet\n */\nsuspend fun ByteReadChannel.readRemaining(): ByteReadPacket = readRemaining(Long.MAX_VALUE, 0)\n\nsuspend fun ByteReadChannel.readFully(dst: IoBuffer) = readFully(dst, dst.writeRemaining)\n\nsuspend fun ByteReadChannel.readUTF8LineTo(out: Appendable): Boolean {\n    return readUTF8LineTo(out, Int.MAX_VALUE)\n}\n\nsuspend fun ByteReadChannel.readUTF8Line(): String? {\n    return readUTF8Line(Int.MAX_VALUE)\n}\n\nfun ByteReadChannel.cancel(): Boolean = cancel(null)\n\n/**\n * Discards all bytes in the channel and suspends until end of stream.\n */\nsuspend fun ByteReadChannel.discard(): Long = discard(Long.MAX_VALUE)\n\n/**\n * Discards exactly [n] bytes or fails if not enough bytes in the channel\n */\nsuspend inline fun ByteReadChannel.discardExact(n: Long) {\n    if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes\")\n}\n\nsuspend fun ByteReadChannel.readAvailable(dst: ByteArray) = readAvailable(dst, 0, dst.size)\nsuspend fun ByteReadChannel.readFully(dst: ByteArray) = readFully(dst, 0, dst.size)\n\nexpect suspend fun ByteReadChannel.joinTo(dst: ByteWriteChannel, closeOnEnd: Boolean)\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\nexpect suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel, limit: Long = Long.MAX_VALUE): Long\n\n/**\n * Reads all the bytes from receiver channel and writes them to [dst] channel and then closes it.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\nsuspend fun ByteReadChannel.copyAndClose(dst: ByteWriteChannel, limit: Long = Long.MAX_VALUE): Long {\n    val count = copyTo(dst, limit)\n    dst.close()\n    return count\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2016-2017 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage io.ktor.utils.io\n\nimport kotlinx.coroutines.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous reading and writing of sequences of bytes.\n * This is a buffered **single-reader single-writer channel**.\n *\n * Read operations can be invoked concurrently with write operations, but multiple reads or multiple writes\n * cannot be invoked concurrently with themselves. Exceptions are [close] and [flush] which can be invoked\n * concurrently with any other operations and between themselves at any time.\n */\ninterface ByteChannel : ByteReadChannel, ByteWriteChannel {\n    fun attachJob(job: Job)\n}\n\n/**\n * Creates buffered channel for asynchronous reading and writing of sequences of bytes.\n */\nexpect fun ByteChannel(autoFlush: Boolean = false): ByteChannel\n\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy it's bytes depending on the platform\n */\nexpect fun ByteReadChannel(content: ByteArray, offset: Int = 0, length: Int = content.size): ByteReadChannel\n\nfun ByteReadChannel(text: String, charset: Charset = Charsets.UTF_8): ByteReadChannel =\n    ByteReadChannel(text.toByteArray(charset)) // TODO optimize to encode parts on demand\n\n\n/**\n * Byte channel that is always empty.\n */\n@Deprecated(\n    \"Use ByteReadChannel.Empty instead\", ReplaceWith(\"ByteReadChannel.Empty\"),\n    level = DeprecationLevel.ERROR\n)\nval EmptyByteReadChannel: ByteReadChannel\n    get() = ByteReadChannel.Empty\n\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun String.toByteArray(charset: Charset = Charsets.UTF_8): ByteArray =\n    charset.newEncoder().encodeToByteArray(this, 0, length)\n\n/**\n * Create an instance of [String] from the specified [bytes] range starting at [offset] and bytes [length]\n * interpreting characters in the specified [charset].\n */\n@Suppress(\"FunctionName\")\nexpect fun String(\n    bytes: ByteArray,\n    offset: Int = 0,\n    length: Int = bytes.size,\n    charset: Charset = Charsets.UTF_8\n): String\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\nfun ByteReadPacket.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    if (isEmpty) return null\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\nfun Input.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read UTF-8 line and append all line characters to [out] except line endings. Does support CR, LF and CR+LF\n * @return `true` if some characters were appended or line ending reached (empty line) or `false` if packet\n * if empty\n */\nfun Input.readUTF8LineTo(out: Appendable, limit: Int): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    takeWhileSize { buffer ->\n        var skip = 0\n        size = buffer.decodeUTF8 { ch ->\n            when (ch) {\n                '\\r' -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n                    cr = true\n                    true\n                }\n                '\\n' -> {\n                    end = true\n                    skip = 1\n                    false\n                }\n                else -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n\n                    if (decoded == limit) bufferLimitExceeded(limit)\n                    decoded++\n                    out.append(ch)\n                    true\n                }\n            }\n        }\n\n        if (skip > 0) {\n            buffer.discardExact(skip)\n        }\n\n        if (end) 0 else size.coerceAtLeast(1)\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded > 0 || !endOfInput\n}\n\n/**\n * Reads UTF-8 characters until one of the specified [delimiters] found, [limit] exceeded or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns a string of characters read before delimiter\n */\nfun Input.readUTF8UntilDelimiter(delimiters: String, limit: Int = Int.MAX_VALUE): String {\n    return buildString {\n        readUTF8UntilDelimiterTo(this, delimiters, limit)\n    }\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\nfun Input.readUTF8UntilDelimiterTo(out: Appendable, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n    }\n\n    if (!delimiter) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\nfun Input.readUTF8UntilDelimiterTo(out: Output, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    val delimitersCount = delimiters.length\n    if (delimitersCount == 1 && delimiters[0].isAsciiChar()) {\n        return readUntilDelimiter(delimiters[0].toByte(), out).toInt()\n    } else if (delimitersCount == 2 && delimiters[0].isAsciiChar() && delimiters[1].isAsciiChar()) {\n        return readUntilDelimiters(delimiters[0].toByte(), delimiters[1].toByte(), out).toInt()\n    }\n\n    return readUTFUntilDelimiterToSlowAscii(delimiters, limit, out)\n}\n\n@Suppress(\"unused\", \"DEPRECATION_ERROR\")\n@Deprecated(\"Use Output version instead\", level = DeprecationLevel.HIDDEN)\nfun Input.readUTF8UntilDelimiterTo(out: BytePacketBuilderBase, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    return readUTF8UntilDelimiterTo(out as Output, delimiters, limit)\n}\n\n/**\n * Read exactly [n] bytes (consumes all remaining if [n] is not specified but up to [Int.MAX_VALUE] bytes).\n * Does fail if not enough bytes remaining.\n */\nfun ByteReadPacket.readBytes(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to convert to a ByteArray: packet is too big\")\n): ByteArray = when {\n    n != 0 -> ByteArray(n).also { readFully(it, 0, n) }\n    else -> EmptyByteArray\n}\n\n/**\n * Reads exactly [n] bytes from the input or fails if not enough bytes available.\n */\nfun Input.readBytes(n: Int): ByteArray = readBytesOf(n, n)\n\n/**\n * Reads all remaining bytes from the input\n */\nfun Input.readBytes(): ByteArray = readBytesOf()\n\n/**\n * Reads at least [min] but no more than [max] bytes from the input to a new byte array\n * @throws EOFException if not enough bytes available to get [min] bytes\n */\nfun Input.readBytesOf(min: Int = 0, max: Int = Int.MAX_VALUE): ByteArray = if (min == max && min == 0) {\n    EmptyByteArray\n} else if (min == max) {\n    ByteArray(min).also { readFully(it, 0, min) }\n} else {\n    var array = ByteArray(max.toLong().coerceAtMost(sizeEstimate()).coerceAtLeast(min.toLong()).toInt())\n    var size = 0\n\n    while (size < max) {\n        val partSize = minOf(max, array.size) - size\n        val rc = readAvailable(array, size, partSize)\n        if (rc <= 0) break\n        size += rc\n        if (array.size == size) {\n            array = array.copyOf(size * 2)\n        }\n    }\n\n    if (size < min) {\n        throw EOFException(\"Not enough bytes available to read $min bytes: ${min - size} more required\")\n    }\n\n    if (size == array.size) array else array.copyOf(size)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, out, max)\", \"io.ktor.utils.io.charsets.decode\"),\n    level = DeprecationLevel.ERROR\n)\nfun Input.readText(out: Appendable, decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): Int {\n    return decoder.decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\nfun Input.readText(out: Appendable, charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): Int {\n    return charset.newDecoder().decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, max)\", \"io.ktor.utils.io.charsets.decode\")\n)\nfun Input.readText(decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): String {\n    return decoder.decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\nfun Input.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String {\n    return charset.newDecoder().decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\nfun Buffer.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String = buildString {\n    charset.newDecoder().decodeBuffer(this@readText, this, true, max)\n}\n\n/**\n * Read exactly [n] characters interpreting bytes in the specified [charset].\n */\n@Deprecated(\n    \"Use readTextExactCharacters instead.\",\n    ReplaceWith(\"readTextExactCharacters(n, charset)\")\n)\nfun Input.readTextExact(charset: Charset = Charsets.UTF_8, n: Int): String {\n    return readTextExactCharacters(n, charset)\n}\n\n/**\n * Read exactly [charactersCount] characters interpreting bytes in the specified [charset].\n */\nfun Input.readTextExactCharacters(charactersCount: Int, charset: Charset = Charsets.UTF_8): String {\n    val s = readText(charset, charactersCount)\n    if (s.length < charactersCount) {\n        prematureEndOfStreamToReadChars(charactersCount)\n    }\n    return s\n}\n\n/**\n * Read exactly the specified number of [bytes]\n * interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\n@Deprecated(\"Parameters order is changed.\", ReplaceWith(\"readTextExactBytes(bytes, charset)\"))\nfun Input.readTextExactBytes(charset: Charset = Charsets.UTF_8, bytes: Int): String {\n    return readTextExactBytes(bytes, charset)\n}\n\n/**\n * Read exactly [bytesCount] interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\nfun Input.readTextExactBytes(bytesCount: Int, charset: Charset = Charsets.UTF_8): String {\n    return charset.newDecoder().decodeExactBytes(this, inputLength = bytesCount)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [encoder]\n */\n@Deprecated(\n    \"Use the implementation with Charset instead\",\n    ReplaceWith(\"writeText(text, fromIndex, toIndex, encoder.charset)\", \"io.ktor.utils.io.charsets.charset\"),\n    level = DeprecationLevel.ERROR\n)\nfun Output.writeText(text: CharSequence, fromIndex: Int = 0, toIndex: Int = text.length, encoder: CharsetEncoder) {\n    encoder.encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\nfun Output.writeText(\n    text: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = text.length,\n    charset: Charset = Charsets.UTF_8\n) {\n    if (charset === Charsets.UTF_8) {\n        return writeTextUtf8(text, fromIndex, toIndex)\n    }\n\n    charset.newEncoder().encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\nfun Output.writeText(\n    text: CharArray,\n    fromIndex: Int = 0,\n    toIndex: Int = text.size,\n    charset: Charset = Charsets.UTF_8\n) {\n    if (charset === Charsets.UTF_8) {\n        return writeTextUtf8(CharArraySequence(text, 0, text.size), fromIndex, toIndex)\n    }\n\n    charset.newEncoder().encode(text, fromIndex, toIndex, this)\n}\n\nprivate fun Output.writeTextUtf8(text: CharSequence, fromIndex: Int, toIndex: Int) {\n    var index = fromIndex\n    writeWhileSize(1) { buffer ->\n        val memory = buffer.memory\n        val dstOffset = buffer.writePosition\n        val dstLimit = buffer.limit\n\n        val (characters, bytes) = memory.encodeUTF8(text, index, toIndex, dstOffset, dstLimit)\n\n        index += characters.toInt()\n        buffer.commitWritten(bytes.toInt())\n\n        when {\n            characters.toInt() == 0 && index < toIndex -> 8\n            index < toIndex -> 1\n            else -> 0\n        }\n    }\n}\n\ninternal expect fun String.getCharsInternal(dst: CharArray, dstOffset: Int)\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Char.isAsciiChar() = toInt() <= 0x7f\n\nprivate fun Input.readUTFUntilDelimiterToSlowAscii(delimiters: String, limit: Int, out: Output): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        val before = buffer.readRemaining\n\n        val rc = buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.rewind(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        rc\n    }\n\n    if (!delimiter && !endOfInput) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Output,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        val before = buffer.readRemaining\n\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.rewind(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Appendable,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun bufferLimitExceeded(limit: Int): Nothing {\n    throw BufferLimitExceededException(\"Too many characters before delimiter: limit $limit exceeded\")\n}\n\n@PublishedApi\ninternal fun prematureEndOfStream(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes\")\n\n@PublishedApi\ninternal fun prematureEndOfStream(size: Long): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes\")\n\nprivate fun prematureEndOfStreamToReadChars(charactersCount: Int): Nothing =\n    throw EOFException(\"Not enough input bytes to read $charactersCount characters.\")\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.concurrent\n\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.properties.*\nimport kotlin.reflect.*\n\n/**\n * Allows to create mutate property with frozen value.\n * Please note that any assigned value will be frozen.\n *\n * Usage:\n * ```kotlin\n * var myCounter by shared(0)\n * ```\n */\n@Suppress(\"NOTHING_TO_INLINE\")\n@DangerousInternalIoApi\npublic actual inline fun <T> shared(value: T): ReadWriteProperty<Any, T> = object : ReadWriteProperty<Any, T> {\n    private var value: T = value\n\n    override fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return this.value\n    }\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n}\n\n/**\n * Allow to create unsafe reference that will never freeze.\n *\n * This reference is allowed to use only from creation thread. Otherwise it will return null.\n */\n@DangerousInternalIoApi\npublic actual fun <T : Any> threadLocal(value: T): ReadOnlyProperty<Any, T?> = object : ReadOnlyProperty<Any, T?> {\n    override fun getValue(thisRef: Any, property: KProperty<*>): T? = value\n}\n","package io.ktor.utils.io.core.internal\n\nimport kotlin.contracts.*\n\n@PublishedApi\ninternal inline fun require(condition: Boolean, crossinline message: () -> String) {\n    contract {\n        returns() implies condition\n    }\n\n    if (!condition) {\n        val m = object : RequireFailureCapture() {\n            override fun doFail(): Nothing {\n                throw IllegalArgumentException(message())\n            }\n        }\n        m.doFail()\n    }\n}\n\n@PublishedApi\ninternal abstract class RequireFailureCapture {\n    abstract fun doFail(): Nothing\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.errors.*\nimport io.ktor.utils.io.pool.*\n\n@DangerousInternalIoApi\n@Deprecated(\n    \"Will be removed in the future releases. Use Input or AbstractInput instead.\",\n    ReplaceWith(\"AbstractInput\", \"io.ktor.utils.io.core.AbstractInput\")\n)\nabstract class ByteReadPacketBase(head: ChunkBuffer, remaining: Long, pool: ObjectPool<ChunkBuffer>) :\n    AbstractInput(head, remaining, pool) {\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    constructor(head: IoBuffer,\n                remaining: Long,\n                pool: ObjectPool<ChunkBuffer>) : this(head as ChunkBuffer, remaining, pool)\n\n    companion object {\n        @Deprecated(\n            \"Use ByteReadPacket.Empty instead\",\n            ReplaceWith(\"ByteReadPacket.Empty\"),\n            level = DeprecationLevel.ERROR\n        )\n        val Empty: ByteReadPacket\n            get() = ByteReadPacket.Empty\n    }\n}\n\nexpect class EOFException(message: String) : IOException\n\n/**\n * For streaming input it should be [Input.endOfInput] instead.\n */\n@Deprecated(\"Use endOfInput property instead\", ReplaceWith(\"endOfInput\"))\ninline val Input.isEmpty: Boolean\n    get() = endOfInput\n\n/**\n * For streaming input there is no reliable way to detect it without triggering bytes population from the underlying\n * source. Consider using [Input.endOfInput] or use [ByteReadPacket] instead.\n */\n@Deprecated(\n    \"This makes no sense for streaming inputs. Some use-cases are covered by endOfInput property\",\n    ReplaceWith(\"!endOfInput\")\n)\nval Input.isNotEmpty: Boolean\n    get() {\n        if (endOfInput) return false\n        prepareReadFirstHead(1)?.let { found ->\n            completeReadHead(found)\n            return true\n        }\n        return false\n    }\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\ninline val ByteReadPacket.isEmpty: Boolean\n    get() = endOfInput\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\ninline val ByteReadPacket.isNotEmpty: Boolean\n    get() = !endOfInput\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.errors.EOFException\nimport kotlin.contracts.*\n\n/**\n * Represents a buffer with read and write positions.\n *\n * Concurrent unsafe: the same memory could be shared between different instances of [Buffer] however you can't\n * read/write using the same [Buffer] instance from different threads.\n */\n@DangerousInternalIoApi\nopen class Buffer(val memory: Memory) {\n    /**\n     * Current read position. It is always non-negative and will never run ahead of the [writePosition].\n     * It is usually greater or equal to [startGap] reservation.\n     * This position is affected by [discard], [rewind], [resetForRead], [resetForWrite], [reserveStartGap]\n     * and [reserveEndGap].\n     */\n    var readPosition by shared(0)\n        private set\n\n    /**\n     * Current write position. It is always non-negative and will never run ahead of the [limit].\n     * It is always greater or equal to the [readPosition].\n     * * This position is affected by [resetForRead], [resetForWrite], [reserveStartGap]\n     * and [reserveEndGap].\n     */\n    var writePosition: Int by shared(0)\n        private set\n\n    /**\n     * Start gap is a reserved space in the beginning. The reserved space is usually used to write a packet length\n     * in the case when it's not known before the packet constructed.\n     */\n    var startGap: Int by shared(0)\n        private set\n\n    /**\n     * Write position limit. No bytes could be written ahead of this limit. When the limit is less than the [capacity]\n     * then this means that there are reserved bytes in the end ([endGap]). Such a reserved space in the end could be used\n     * to write size, hash and so on. Also it is useful when several buffers are connected into a chain and some\n     * primitive value (e.g. `kotlin.Int`) is separated into two chunks so bytes from the second chain could be copied\n     * to the reserved space of the first chunk and then the whole value could be read at once.\n     */\n    var limit: Int by shared(memory.size32)\n        private set\n\n    /**\n     * Number of bytes reserved in the end.\n     */\n    inline val endGap: Int get() = capacity - limit\n\n    /**\n     * Buffer's capacity (including reserved [startGap] and [endGap]. Value for released buffer is unspecified.\n     */\n    val capacity: Int = memory.size32\n\n    /**\n     * Number of bytes available for reading.\n     */\n    inline val readRemaining: Int get() = writePosition - readPosition\n\n    /**\n     * Size of the free space available for writing in bytes.\n     */\n    inline val writeRemaining: Int get() = limit - writePosition\n\n    /**\n     * User data: could be a session, connection or anything useful\n     */\n    @Deprecated(\"Will be removed. Inherit Buffer and add required fields instead.\")\n    @ExperimentalIoApi\n    var attachment: Any? by shared(null)\n\n    /**\n     * Discard [count] readable bytes.\n     *\n     * @throws EOFException if [count] is bigger than available bytes.\n     */\n    fun discardExact(count: Int = readRemaining) {\n        if (count == 0) return\n\n        val newReadPosition = readPosition + count\n        if (count < 0 || newReadPosition > writePosition) {\n            discardFailed(count, readRemaining)\n        }\n        readPosition = newReadPosition\n    }\n\n    @Deprecated(\"Use discardExact instead.\", level = DeprecationLevel.ERROR)\n    fun discard(count: Int): Int {\n        val size = minOf(count, readRemaining)\n        discardExact(size)\n        return size\n    }\n\n    @Deprecated(\"Use discardExact instead.\", level = DeprecationLevel.ERROR)\n    final fun discard(count: Long): Long {\n        val size = minOf(count, readRemaining.toLong()).toInt()\n        discardExact(size)\n        return size.toLong()\n    }\n\n    @DangerousInternalIoApi\n    fun commitWritten(count: Int) {\n        val newWritePosition = writePosition + count\n        if (count < 0 || newWritePosition > limit) {\n            commitWrittenFailed(count, writeRemaining)\n        }\n        writePosition = newWritePosition\n    }\n\n    /**\n     * @return `true` if there is free space\n     */\n    @PublishedApi\n    internal fun commitWrittenUntilIndex(position: Int): Boolean {\n        val limit = limit\n        if (position < writePosition) {\n            commitWrittenFailed(position - writePosition, writeRemaining)\n        }\n        if (position >= limit) {\n            if (position == limit) {\n                writePosition = position\n                return false\n            }\n            commitWrittenFailed(position - writePosition, writeRemaining)\n        }\n\n        writePosition = position\n        return true\n    }\n\n    internal fun discardUntilIndex(position: Int) {\n        if (position < 0 || position > writePosition) {\n            discardFailed(position - readPosition, readRemaining)\n        }\n\n        if (readPosition != position) {\n            readPosition = position\n        }\n    }\n\n    /**\n     * Rewind [readPosition] backward to make [count] bytes available for reading again.\n     * @throws IllegalArgumentException when [count] is too big and not enough bytes available before the [readPosition]\n     */\n    fun rewind(count: Int = readPosition - startGap) {\n        val newReadPosition = readPosition - count\n        if (newReadPosition < startGap) {\n            rewindFailed(count, readPosition - startGap)\n        }\n        readPosition = newReadPosition\n    }\n\n    /**\n     * Reserve [startGap] bytes in the beginning.\n     * May move [readPosition] and [writePosition] if no bytes available for reading.\n     */\n    fun reserveStartGap(startGap: Int) {\n        require(startGap >= 0) { \"startGap shouldn't be negative: $startGap\" }\n\n        if (readPosition >= startGap) {\n            this.startGap = startGap\n            return\n        }\n\n        if (readPosition == writePosition) {\n            if (startGap > limit) {\n                startGapReservationFailedDueToLimit(startGap)\n            }\n\n            this.writePosition = startGap\n            this.readPosition = startGap\n            this.startGap = startGap\n            return\n        }\n\n        startGapReservationFailed(startGap)\n    }\n\n    /**\n     * Reserve [endGap] bytes in the end.\n     * Could move [readPosition] and [writePosition] to reserve space but only when no bytes were written or\n     * all written bytes are marked as consumed (were read or discarded).\n     */\n    fun reserveEndGap(endGap: Int) {\n        require(endGap >= 0) { \"endGap shouldn't be negative: $endGap\" }\n\n        val newLimit = capacity - endGap\n        if (newLimit >= writePosition) {\n            limit = newLimit\n            return\n        }\n\n        if (newLimit < 0) {\n            endGapReservationFailedDueToCapacity(endGap)\n        }\n        if (newLimit < startGap) {\n            endGapReservationFailedDueToStartGap(endGap)\n        }\n\n        if (readPosition == writePosition) {\n            limit = newLimit\n            readPosition = newLimit\n            writePosition = newLimit\n            return\n        }\n\n        endGapReservationFailedDueToContent(endGap)\n    }\n\n    /**\n     * Marks the whole buffer available for read and no for write\n     */\n    fun resetForRead() {\n        startGap = 0\n        readPosition = 0\n\n        val capacity = capacity\n        writePosition = capacity\n    }\n\n    /**\n     * Marks all capacity writable except the start gap reserved before. The end gap reservation is discarded.\n     */\n    fun resetForWrite() {\n        resetForWrite(capacity - startGap)\n    }\n\n    /**\n     * Marks up to [limit] bytes of the buffer available for write and no bytes for read.\n     * It does respect [startGap] already reserved. All extra bytes after the specified [limit]\n     * are considered as [endGap].\n     */\n    fun resetForWrite(limit: Int) {\n        val startGap = startGap\n        readPosition = startGap\n        writePosition = startGap\n        this.limit = limit\n    }\n\n    /**\n     * Forget start/end gap reservations.\n     */\n    internal fun releaseGaps() {\n        releaseStartGap(0)\n        releaseEndGap()\n    }\n\n    internal fun releaseEndGap() {\n        limit = capacity\n    }\n\n    internal fun releaseStartGap(newReadPosition: Int) {\n        require(newReadPosition >= 0) { \"newReadPosition shouldn't be negative: $newReadPosition\" }\n        require(newReadPosition <= readPosition) {\n            \"newReadPosition shouldn't be ahead of the read position: $newReadPosition > $readPosition\"\n        }\n\n        readPosition = newReadPosition\n        if (startGap > newReadPosition) {\n            startGap = newReadPosition\n        }\n    }\n\n    protected open fun duplicateTo(copy: Buffer) {\n        copy.limit = limit\n        copy.startGap = startGap\n        copy.readPosition = readPosition\n        copy.writePosition = writePosition\n    }\n\n    /**\n     * Create a new [Buffer] instance pointing to the same memory and having the same positions.\n     */\n    open fun duplicate(): Buffer = Buffer(memory).apply {\n        duplicateTo(this)\n    }\n\n    /**\n     * Peek the next unsigned byte or return `-1` if no more bytes available for reading. No bytes will be marked\n     * as consumed in any case.\n     * @return an unsigned byte or `-1` if not even a byte is available for reading.\n     * @see tryReadByte\n     * @see readByte\n     */\n    fun tryPeekByte(): Int {\n        val readPosition = readPosition\n        if (readPosition == writePosition) return -1\n        return memory[readPosition].toInt() and 0xff\n    }\n\n    /**\n     * Read the next unsigned byte or return `-1` if no more bytes available for reading. The returned byte is marked\n     * as consumed.\n     * @return an unsigned byte or `-1` if not even a byte is available for reading.\n     * @see tryPeekByte\n     * @see readByte\n     */\n    fun tryReadByte(): Int {\n        val readPosition = readPosition\n        if (readPosition == writePosition) return -1\n        this.readPosition = readPosition + 1\n        return memory[readPosition].toInt() and 0xff\n    }\n\n    /**\n     * Read the next byte or fail with [EOFException] if it's not available. The returned byte is marked\n     * as consumed.\n     * @throws EOFException when not even a byte is available for reading.\n     * @see tryPeekByte\n     * @see tryReadByte\n     */\n    fun readByte(): Byte {\n        val readPosition = readPosition\n        if (readPosition == writePosition) {\n            throw EOFException(\"No readable bytes available.\")\n        }\n        this.readPosition = readPosition + 1\n        return memory[readPosition]\n    }\n\n    /**\n     * Write a byte [value] at [writePosition] (incremented when written successfully).\n     * @throws InsufficientSpaceException when no free space in the buffer.\n     */\n    fun writeByte(value: Byte) {\n        val writePosition = writePosition\n        if (writePosition == limit) {\n            throw InsufficientSpaceException(\"No free space in the buffer to write a byte\")\n        }\n        memory[writePosition] = value\n        this.writePosition = writePosition + 1\n    }\n\n    /**\n     * Clear buffer's state: read/write positions, gaps and so on. Byte content is not cleaned-up.\n     */\n    open fun reset() {\n        releaseGaps()\n        resetForWrite()\n    }\n\n    override fun toString(): String {\n        return \"Buffer($readRemaining used, $writeRemaining free, ${startGap + endGap} reserved of $capacity)\"\n    }\n\n    companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [io.ktor.utils.io.core.internal.ChunkBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        const val ReservedSize: Int = 8\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        @Suppress(\"DEPRECATION\")\n        val Empty: Buffer get() = IoBuffer.Empty\n    }\n}\n\n/**\n * @return `true` if there are available bytes to be read\n */\ninline fun Buffer.canRead() = writePosition > readPosition\n\n/**\n * @return `true` if there is free room to for write\n */\ninline fun Buffer.canWrite() = limit > writePosition\n\n/**\n * Apply [block] of code with buffer's memory providing read range indices. The returned value of [block] lambda should\n * return number of bytes to be marked as consumed.\n * No read/write functions on this buffer should be called inside of [block] otherwise an undefined behaviour may occur\n * including data damage.\n */\n@DangerousInternalIoApi\ninline fun Buffer.read(block: (memory: Memory, start: Int, endExclusive: Int) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val rc = block(memory, readPosition, writePosition)\n    discardExact(rc)\n    return rc\n}\n\n/**\n * Apply [block] of code with buffer's memory providing write range indices. The returned value of [block] lambda should\n * return number of bytes were written.\n * o read/write functions on this buffer should be called inside of [block] otherwise an undefined behaviour may occur\n * including data damage.\n */\n@DangerousInternalIoApi\ninline fun Buffer.write(block: (memory: Memory, start: Int, endExclusive: Int) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val rc = block(memory, writePosition, limit)\n    commitWritten(rc)\n    return rc\n}\n\ninternal fun discardFailed(count: Int, readRemaining: Int): Nothing {\n    throw EOFException(\"Unable to discard $count bytes: only $readRemaining available for reading\")\n}\n\ninternal fun commitWrittenFailed(count: Int, writeRemaining: Int): Nothing {\n    throw EOFException(\"Unable to discard $count bytes: only $writeRemaining available for writing\")\n}\n\ninternal fun rewindFailed(count: Int, rewindRemaining: Int): Nothing {\n    throw IllegalArgumentException(\"Unable to rewind $count bytes: only $rewindRemaining could be rewinded\")\n}\n\ninternal fun Buffer.startGapReservationFailedDueToLimit(startGap: Int): Nothing {\n    if (startGap > capacity) {\n        throw IllegalArgumentException(\"Start gap $startGap is bigger than the capacity $capacity\")\n    }\n\n    throw IllegalStateException(\n        \"Unable to reserve $startGap start gap: there are already $endGap bytes reserved in the end\"\n    )\n}\n\ninternal fun Buffer.startGapReservationFailed(startGap: Int): Nothing {\n    throw IllegalStateException(\n        \"Unable to reserve $startGap start gap: \" +\n            \"there are already $readRemaining content bytes starting at offset $readPosition\"\n    )\n}\n\ninternal fun Buffer.endGapReservationFailedDueToCapacity(endGap: Int) {\n    throw IllegalArgumentException(\"End gap $endGap is too big: capacity is $capacity\")\n}\n\n\ninternal fun Buffer.endGapReservationFailedDueToStartGap(endGap: Int) {\n    throw IllegalArgumentException(\n        \"End gap $endGap is too big: there are already $startGap bytes reserved in the beginning\"\n    )\n}\n\ninternal fun Buffer.endGapReservationFailedDueToContent(endGap: Int) {\n    throw IllegalArgumentException(\n        \"Unable to reserve end gap $endGap:\" +\n            \" there are already $readRemaining content bytes at offset $readPosition\"\n    )\n}\n\ninternal fun Buffer.restoreStartGap(size: Int) {\n    releaseStartGap(readPosition - size)\n}\n\n@ExperimentalIoApi\nclass InsufficientSpaceException(message: String = \"Not enough free space\") : Exception(message) {\n    constructor(\n        size: Int,\n        availableSpace: Int\n    ) : this(\"Not enough free space to write $size bytes, available $availableSpace bytes.\")\n\n    constructor(\n        name: String,\n        size: Int,\n        availableSpace: Int\n    ) : this(\"Not enough free space to write $name of $size bytes, available $availableSpace bytes.\")\n\n    constructor(\n        size: Long,\n        availableSpace: Long\n    ) : this(\"Not enough free space to write $size bytes, available $availableSpace bytes.\")\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous writing of sequences of bytes.\n * This is a **single-writer channel**.\n *\n * Operations on this channel cannot be invoked concurrently, unless explicitly specified otherwise\n * in description. Exceptions are [close] and [flush].\n */\nexpect interface ByteWriteChannel {\n    /**\n     * Returns number of bytes that can be written without suspension. Write operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for write.\n     */\n    val availableForWrite: Int\n\n    /**\n     * Returns `true` is channel has been closed and attempting to write to the channel will cause an exception.\n     */\n    val isClosedForWrite: Boolean\n\n    /**\n     * Returns `true` if channel flushes automatically all pending bytes after every write function call.\n     * If `false` then flush only happens at manual [flush] invocation or when the buffer is full.\n     */\n    val autoFlush: Boolean\n\n    /**\n     * Byte order that is used for multi-byte write operations\n     * (such as [writeShort], [writeInt], [writeLong], [writeFloat], and [writeDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    var writeByteOrder: ByteOrder\n\n    /**\n     * Number of bytes written to the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of write operation.\n     */\n    val totalBytesWritten: Long\n\n    /**\n     * An closure cause exception or `null` if closed successfully or not yet closed\n     */\n    val closedCause: Throwable?\n\n    /**\n     * Writes as much as possible and only suspends if buffer is full\n     */\n    suspend fun writeAvailable(src: ByteArray, offset: Int, length: Int): Int\n\n    suspend fun writeAvailable(src: IoBuffer): Int\n\n    /**\n     * Writes all [src] bytes and suspends until all bytes written. Causes flush if buffer filled up or when [autoFlush]\n     * Crashes if channel get closed while writing.\n     */\n    suspend fun writeFully(src: ByteArray, offset: Int, length: Int)\n\n    suspend fun writeFully(src: IoBuffer)\n\n    public suspend fun writeFully(src: Buffer)\n\n    public suspend fun writeFully(memory: Memory, startIndex: Int, endIndex: Int)\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use write { } instead.\")\n    suspend fun writeSuspendSession(visitor: suspend WriterSuspendSession.() -> Unit)\n\n    /**\n     * Writes a [packet] fully or fails if channel get closed before the whole packet has been written\n     */\n    suspend fun writePacket(packet: ByteReadPacket)\n\n    /**\n     * Writes long number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    suspend fun writeLong(l: Long)\n\n    /**\n     * Writes int number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    suspend fun writeInt(i: Int)\n\n    /**\n     * Writes short number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    suspend fun writeShort(s: Short)\n\n    /**\n     * Writes byte and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    suspend fun writeByte(b: Byte)\n\n    /**\n     * Writes double number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    suspend fun writeDouble(d: Double)\n\n    /**\n     * Writes float number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    suspend fun writeFloat(f: Float)\n\n    /**\n     * Invokes [block] when at least 1 byte is available for write.\n     */\n    @ExperimentalIoApi\n    public suspend fun awaitFreeSpace()\n\n    /**\n     * Closes this channel with an optional exceptional [cause].\n     * It flushes all pending write bytes (via [flush]).\n     * This is an idempotent operation -- repeated invocations of this function have no effect and return `false`.\n     *\n     * A channel that was closed without a [cause], is considered to be _closed normally_.\n     * A channel that was closed with non-null [cause] is called a _failed channel_. Attempts to read or\n     * write on a failed channel throw this cause exception.\n     *\n     * After invocation of this operation [isClosedForWrite] starts returning `true` and\n     * all subsequent write operations throw [ClosedWriteChannelException] or the specified [cause].\n     * However, [isClosedForRead][ByteReadChannel.isClosedForRead] on the side of [ByteReadChannel]\n     * starts returning `true` only after all written bytes have been read.\n     *\n     * Please note that if the channel has been closed with cause and it has been provided by [reader] or [writer]\n     * coroutine then the corresponding coroutine will be cancelled with [cause]. If no [cause] provided then no\n     * cancellation will be propagated.\n     */\n    fun close(cause: Throwable?): Boolean\n\n    /**\n     * Flushes all pending write bytes making them available for read.\n     *\n     * This function is thread-safe and can be invoked in any thread at any time.\n     * It does nothing when invoked on a closed channel.\n     */\n    fun flush()\n}\n\n\nsuspend fun ByteWriteChannel.writeAvailable(src: ByteArray) = writeAvailable(src, 0, src.size)\nsuspend fun ByteWriteChannel.writeFully(src: ByteArray) = writeFully(src, 0, src.size)\n\nsuspend fun ByteWriteChannel.writeShort(s: Int) {\n    return writeShort((s and 0xffff).toShort())\n}\n\nsuspend fun ByteWriteChannel.writeShort(s: Int, byteOrder: ByteOrder) {\n    return writeShort((s and 0xffff).toShort(), byteOrder)\n}\n\nsuspend fun ByteWriteChannel.writeByte(b: Int) {\n    return writeByte((b and 0xff).toByte())\n}\n\nsuspend fun ByteWriteChannel.writeInt(i: Long) {\n    return writeInt(i.toInt())\n}\n\nsuspend fun ByteWriteChannel.writeInt(i: Long, byteOrder: ByteOrder) {\n    return writeInt(i.toInt(), byteOrder)\n}\n\n/**\n * Closes this channel with no failure (successfully)\n */\nfun ByteWriteChannel.close(): Boolean = close(null)\n\nsuspend fun ByteWriteChannel.writeStringUtf8(s: CharSequence) {\n    val packet = buildPacket {\n        writeStringUtf8(s)\n    }\n\n    return writePacket(packet)\n}\n\n/*\nTODO\nsuspend fun ByteWriteChannel.writeStringUtf8(s: CharBuffer) {\n    val packet = buildPacket {\n        writeStringUtf8(s)\n    }\n\n    return writePacket(packet)\n}*/\n\nsuspend fun ByteWriteChannel.writeStringUtf8(s: String) {\n    val packet = buildPacket {\n        writeText(s)\n    }\n\n    return writePacket(packet)\n}\n\nsuspend fun ByteWriteChannel.writeBoolean(b: Boolean) {\n    return writeByte(if (b) 1 else 0)\n}\n\n/**\n * Writes UTF16 character\n */\nsuspend fun ByteWriteChannel.writeChar(ch: Char) {\n    return writeShort(ch.toInt())\n}\n\nsuspend inline fun ByteWriteChannel.writePacket(headerSizeHint: Int = 0, builder: BytePacketBuilder.() -> Unit) {\n    return writePacket(buildPacket(headerSizeHint, builder))\n}\n\nsuspend fun ByteWriteChannel.writePacketSuspend(builder: suspend BytePacketBuilder.() -> Unit) {\n    return writePacket(buildPacket { builder() })\n}\n\n/**\n * Indicates attempt to write on [isClosedForWrite][ByteWriteChannel.isClosedForWrite] channel\n * that was closed without a cause. A _failed_ channel rethrows the original [close][ByteWriteChannel.close] cause\n * exception on send attempts.\n */\nclass ClosedWriteChannelException(message: String?) : CancellationException(message)\n\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.contracts.*\n\nexpect val PACKET_MAX_COPY_SIZE: Int\n\n/**\n * Build a byte packet in [block] lambda. Creates a temporary builder and releases it in case of failure\n */\ninline fun buildPacket(headerSizeHint: Int = 0, block: BytePacketBuilder.() -> Unit): ByteReadPacket {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val builder = BytePacketBuilder(headerSizeHint)\n    try {\n        block(builder)\n        return builder.build()\n    } catch (t: Throwable) {\n        builder.release()\n        throw t\n    }\n}\n\nexpect fun BytePacketBuilder(headerSizeHint: Int = 0): BytePacketBuilder\n\n/**\n * Discard all written bytes and prepare to build another packet.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun BytePacketBuilder.reset() {\n    release()\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\nabstract class BytePacketBuilderPlatformBase\ninternal constructor(pool: ObjectPool<ChunkBuffer>) : BytePacketBuilderBase(pool)\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\nabstract class BytePacketBuilderBase\ninternal constructor(pool: ObjectPool<ChunkBuffer>) : AbstractOutput(pool)\n\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\nsuspend inline fun ByteReadChannel.readShort(byteOrder: ByteOrder): Short {\n    return readShort().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readInt(byteOrder: ByteOrder): Int {\n    return readInt().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readLong(byteOrder: ByteOrder): Long {\n    return readLong().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readFloat(byteOrder: ByteOrder): Float {\n    return readFloat().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readDouble(byteOrder: ByteOrder): Double {\n    return readDouble().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readShortLittleEndian(): Short {\n    return toLittleEndian(readShort()) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readIntLittleEndian(): Int {\n    return toLittleEndian(readInt()) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readLongLittleEndian(): Long {\n    return toLittleEndian(readLong()) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readFloatLittleEndian(): Float {\n    return toLittleEndian(readFloat()) { reverseByteOrder() }\n}\n\nsuspend inline fun ByteReadChannel.readDoubleLittleEndian(): Double {\n    return toLittleEndian(readDouble()) { reverseByteOrder() }\n}\n\nsuspend fun ByteWriteChannel.writeShort(value: Short, byteOrder: ByteOrder) {\n    writeShort(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeInt(value: Int, byteOrder: ByteOrder) {\n    writeInt(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeLong(value: Long, byteOrder: ByteOrder) {\n    writeLong(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeFloat(value: Float, byteOrder: ByteOrder) {\n    writeFloat(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeDouble(value: Double, byteOrder: ByteOrder) {\n    writeDouble(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeShortLittleEndian(value: Short) {\n    writeShort(toLittleEndian(value) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeIntLittleEndian(value: Int) {\n    writeInt(toLittleEndian(value) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeLongLittleEndian(value: Long) {\n    writeLong(toLittleEndian(value) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeFloatLittleEndian(value: Float) {\n    writeFloat(toLittleEndian(value) { reverseByteOrder() })\n}\n\nsuspend fun ByteWriteChannel.writeDoubleLittleEndian(value: Double) {\n    writeDouble(toLittleEndian(value) { reverseByteOrder() })\n}\n\n@PublishedApi\n@Suppress(\"DEPRECATION_ERROR\")\ninternal inline fun <T> ByteReadChannel.toLittleEndian(value: T, reverseBlock: T.() -> T): T {\n    return when (readByteOrder) {\n        ByteOrder.LITTLE_ENDIAN -> value\n        else -> value.reverseBlock()\n    }\n}\n\n@Suppress(\"DEPRECATION_ERROR\")\nprivate inline fun <T> ByteWriteChannel.toLittleEndian(value: T, reverseBlock: T.() -> T): T {\n    return when (writeByteOrder) {\n        ByteOrder.LITTLE_ENDIAN -> value\n        else -> value.reverseBlock()\n    }\n}\n\n@PublishedApi\ninternal inline fun <T> T.reverseIfNeeded(byteOrder: ByteOrder, reverseBlock: T.() -> T): T {\n    return when (byteOrder) {\n        ByteOrder.BIG_ENDIAN -> this\n        else -> reverseBlock()\n    }\n}\n","package io.ktor.utils.io\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * A coroutine job that is reading from a byte channel\n */\ninterface ReaderJob : Job {\n    /**\n     * A reference to the channel that this coroutine is reading from\n     */\n    val channel: ByteWriteChannel\n}\n\n/**\n * A coroutine job that is writing to a byte channel\n */\ninterface WriterJob : Job {\n    /**\n     * A reference to the channel that this coroutine is writing to\n     */\n    val channel: ByteReadChannel\n}\n\ninterface ReaderScope : CoroutineScope {\n    val channel: ByteReadChannel\n}\n\ninterface WriterScope : CoroutineScope {\n    val channel: ByteWriteChannel\n}\n\nfun CoroutineScope.reader(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    channel: ByteChannel,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob = launchChannel(coroutineContext, channel, attachJob = false, block = block)\n\nfun CoroutineScope.reader(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    autoFlush: Boolean = false,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob = launchChannel(coroutineContext, ByteChannel(autoFlush), attachJob = true, block = block)\n\n@Deprecated(\"Use scope.reader instead\")\nfun reader(\n    coroutineContext: CoroutineContext,\n    channel: ByteChannel,\n    parent: Job? = null,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob {\n    val newContext = if (parent != null) GlobalScope.newCoroutineContext(coroutineContext + parent)\n    else GlobalScope.newCoroutineContext(coroutineContext)\n\n    return CoroutineScope(newContext).reader(EmptyCoroutineContext, channel, block)\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use scope.reader instead\")\nfun reader(\n    coroutineContext: CoroutineContext,\n    autoFlush: Boolean = false, parent: Job? = null,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob {\n    val channel = ByteChannel(autoFlush)\n    return reader(coroutineContext, channel, parent, block).also {\n        channel.attachJob(it)\n    }\n}\n\nfun CoroutineScope.writer(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    channel: ByteChannel,\n    block: suspend WriterScope.() -> Unit\n): WriterJob = launchChannel(coroutineContext, channel, attachJob = false, block = block)\n\nfun CoroutineScope.writer(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    autoFlush: Boolean = false,\n    block: suspend WriterScope.() -> Unit\n): WriterJob = launchChannel(coroutineContext, ByteChannel(autoFlush), attachJob = true, block = block)\n\n@Deprecated(\"Use scope.writer instead\")\nfun writer(\n    coroutineContext: CoroutineContext,\n    channel: ByteChannel, parent: Job? = null,\n    block: suspend WriterScope.() -> Unit\n): WriterJob {\n    val newContext = if (parent != null) GlobalScope.newCoroutineContext(coroutineContext + parent)\n    else GlobalScope.newCoroutineContext(coroutineContext)\n\n    return CoroutineScope(newContext).writer(EmptyCoroutineContext, channel, block)\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use scope.writer instead\")\nfun writer(\n    coroutineContext: CoroutineContext,\n    autoFlush: Boolean = false, parent: Job? = null,\n    block: suspend WriterScope.() -> Unit\n): WriterJob {\n    val channel = ByteChannel(autoFlush)\n    return writer(coroutineContext, channel, parent, block).also {\n        channel.attachJob(it)\n    }\n}\n\n/**\n * @param S not exactly safe (unchecked cast is used) so should be [ReaderScope] or [WriterScope]\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun <S : CoroutineScope> CoroutineScope.launchChannel(\n    context: CoroutineContext,\n    channel: ByteChannel,\n    attachJob: Boolean,\n    block: suspend S.() -> Unit\n): ChannelJob {\n    val dispatcher = coroutineContext[CoroutineDispatcher]\n    val job = launch(context) {\n        if (attachJob) {\n            channel.attachJob(coroutineContext[Job]!!)\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val scope = ChannelScope(this, channel) as S\n\n        try {\n            block(scope)\n        } catch (cause: Throwable) {\n            if (dispatcher != Dispatchers.Unconfined && dispatcher != null) {\n                throw cause\n            }\n\n            channel.cancel(cause)\n        }\n    }\n\n    job.invokeOnCompletion { cause ->\n        channel.close(cause)\n    }\n\n    return ChannelJob(job, channel)\n}\n\nprivate class ChannelScope(\n    delegate: CoroutineScope,\n    override val channel: ByteChannel\n) : ReaderScope, WriterScope, CoroutineScope by delegate\n\nprivate class ChannelJob(\n    private val delegate: Job,\n    override val channel: ByteChannel\n) : ReaderJob, WriterJob, Job by delegate {\n    override fun toString(): String = \"ChannelJob[$delegate]\"\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * Await until at least [desiredSize] is available for read or EOF and invoke [block] function. The block function\n * should never capture a provided [Memory] instance outside otherwise an undefined behaviour may occur including\n * accidental crash or data corruption. Block function should return number of bytes consumed or 0.\n *\n * Specifying [desiredSize] larger than the channel's capacity leads to block function invocation earlier\n * when the channel is full. So specifying too big [desiredSize] is identical to specifying [desiredSize] equal to\n * the channel's capacity. The other case when a provided memory range could be less than [desiredSize] is that\n * all the requested bytes couldn't be represented as a single memory range due to internal implementation reasons.\n *\n * @return number of bytes consumed, possibly 0\n */\n@ExperimentalIoApi\nsuspend inline fun ByteReadChannel.read(\n    desiredSize: Int = 1,\n    block: (source: Memory, start: Long, endExclusive: Long) -> Int\n): Int {\n    val buffer = requestBuffer(desiredSize) ?: Buffer.Empty\n\n    try {\n        val bytesRead = block(buffer.memory, buffer.readPosition.toLong(), buffer.writePosition.toLong())\n        completeReadingFromBuffer(buffer, bytesRead)\n        return bytesRead\n    } catch (cause: Throwable) {\n        completeReadingFromBuffer(buffer, 0)\n        throw cause\n    }\n\n    // we don't use finally here because of KT-37279\n}\n\n@Deprecated(\"Use read { } instead.\")\ninterface ReadSession {\n    /**\n     * Number of bytes available for read. However it doesn't necessarily means that all available bytes could be\n     * requested at once\n     */\n    val availableForRead: Int\n\n    /**\n     * Discard at most [n] available bytes or 0 if no bytes available yet\n     * @return number of bytes actually discarded, could be 0\n     */\n    fun discard(n: Int): Int\n\n    /**\n     * Request buffer range [atLeast] bytes length\n     *\n     * There are the following reasons for this function to return `null`:\n     * - not enough bytes available yet (should be at least `atLeast` bytes available)\n     * - due to buffer fragmentation it is impossible to represent the requested range as a single buffer range\n     * - end of stream encountered and all bytes were consumed\n     *\n     * @return buffer for the requested range or `null` if it is impossible to provide such a buffer view\n     * @throws Throwable if the channel has been closed with an exception or cancelled\n     */\n    @Suppress(\"DEPRECATION\")\n    fun request(atLeast: Int = 1): IoBuffer?\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use read { } instead.\")\ninterface SuspendableReadSession : ReadSession {\n    /**\n     * Suspend until [atLeast] bytes become available or end of stream encountered (possibly due to exceptional close)\n     *\n     * @return true if there are [atLeast] bytes available or false if end of stream encountered (there still could be\n     * bytes available but less than [atLeast])\n     * @throws Throwable if the channel has been closed with an exception or cancelled\n     * @throws IllegalArgumentException if [atLeast] is negative to too big (usually bigger that 4088)\n     */\n    suspend fun await(atLeast: Int = 1): Boolean\n}\n\n@PublishedApi\ninternal suspend fun ByteReadChannel.requestBuffer(desiredSize: Int): Buffer? {\n    @Suppress(\"DEPRECATION\")\n    val readSession: SuspendableReadSession? = when {\n        this is SuspendableReadSession -> this\n        this is HasReadSession -> startReadSession()\n        else -> null\n    }\n\n    if (readSession != null) {\n        val buffer = readSession.request(desiredSize.coerceAtMost(Buffer.ReservedSize))\n        if (buffer != null) {\n            return buffer\n        }\n\n        return readSession.requestBufferSuspend(desiredSize)\n    }\n\n    return requestBufferFallback(desiredSize)\n}\n\n@PublishedApi\ninternal suspend fun ByteReadChannel.completeReadingFromBuffer(buffer: Buffer?, bytesRead: Int) {\n    check(bytesRead >= 0) { \"bytesRead shouldn't be negative: $bytesRead\" }\n    @Suppress(\"DEPRECATION\")\n    val readSession: SuspendableReadSession? = readSessionFor()\n\n    if (readSession != null) {\n        readSession.discard(bytesRead)\n        if (this is HasReadSession) {\n            endReadSession()\n        }\n        return\n    }\n\n    if (buffer is ChunkBuffer && buffer !== ChunkBuffer.Empty) {\n        buffer.release(ChunkBuffer.Pool)\n        discard(bytesRead.toLong())\n    }\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun SuspendableReadSession.requestBufferSuspend(desiredSize: Int): Buffer? {\n    await(desiredSize)\n    return request(1)\n}\n\nprivate suspend fun ByteReadChannel.requestBufferFallback(desiredSize: Int): ChunkBuffer {\n    val chunk = ChunkBuffer.Pool.borrow()\n    val copied =\n        peekTo(chunk.memory, chunk.writePosition.toLong(), 0L, desiredSize.toLong(), chunk.writeRemaining.toLong())\n    chunk.commitWritten(copied.toInt())\n\n    return chunk\n}\n\ninternal interface HasReadSession {\n    @Suppress(\"DEPRECATION\")\n    fun startReadSession(): SuspendableReadSession\n\n    fun endReadSession()\n}\n\n@Suppress(\"DEPRECATION\", \"NOTHING_TO_INLINE\")\nprivate inline fun ByteReadChannel.readSessionFor(): SuspendableReadSession? = when {\n    this is HasReadSession -> startReadSession()\n    else -> null\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.ChunkBuffer\n\n/**\n * Await for [desiredSpace] will be available for write and invoke [block] function providing [Memory] instance and\n * the corresponding range suitable for wiring in the memory. The block function should return number of bytes were\n * written, possibly 0.\n *\n * Similar to [ByteReadChannel.read], this function may invoke block function with lesser memory range when the\n * specified [desiredSpace] is bigger that the buffer's capacity\n * or when it is impossible to represent all [desiredSpace] bytes as a single memory range\n * due to internal implementation reasons.\n */\n@ExperimentalIoApi\nsuspend inline fun ByteWriteChannel.write(\n    desiredSpace: Int = 1,\n    block: (freeSpace: Memory, startOffset: Long, endExclusive: Long) -> Int\n): Int {\n    val buffer = requestWriteBuffer(desiredSpace) ?: Buffer.Empty\n    var bytesWritten = 0\n    try {\n        bytesWritten = block(buffer.memory, buffer.writePosition.toLong(), buffer.limit.toLong())\n        buffer.commitWritten(bytesWritten)\n        return bytesWritten\n    } finally {\n        completeWriting(buffer, bytesWritten)\n    }\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use writeMemory instead.\")\ninterface WriterSession {\n    fun request(min: Int): IoBuffer?\n    fun written(n: Int)\n    fun flush()\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use writeMemory instead.\")\ninterface WriterSuspendSession : WriterSession {\n    suspend fun tryAwait(n: Int)\n}\n\n@Suppress(\"DEPRECATION\")\ninternal interface HasWriteSession {\n    fun beginWriteSession(): WriterSuspendSession?\n    fun endWriteSession(written: Int)\n}\n\n@PublishedApi\ninternal suspend fun ByteWriteChannel.requestWriteBuffer(desiredSpace: Int): Buffer? {\n    val session = writeSessionFor()\n    if (session != null) {\n        val buffer = session.request(desiredSpace)\n        if (buffer != null) {\n            return buffer\n        }\n\n        return writeBufferSuspend(session, desiredSpace)\n    }\n\n    return writeBufferFallback()\n}\n\n@PublishedApi\ninternal suspend fun ByteWriteChannel.completeWriting(buffer: Buffer, written: Int) {\n    if (this is HasWriteSession) {\n        endWriteSession(written)\n        return\n    }\n\n    return completeWritingFallback(buffer)\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun ByteWriteChannel.completeWritingFallback(buffer: Buffer) {\n    if (buffer is IoBuffer) {\n        writeFully(buffer)\n        buffer.release(IoBuffer.Pool)\n        return\n    }\n\n    throw UnsupportedOperationException(\"Only IoBuffer instance is supported.\")\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun writeBufferSuspend(session: WriterSuspendSession, desiredSpace: Int): Buffer? {\n    session.tryAwait(desiredSpace)\n    return session.request(desiredSpace) ?: session.request(1)\n}\n\nprivate fun writeBufferFallback(): Buffer? {\n    return ChunkBuffer.Pool.borrow().also { it.resetForWrite(); it.reserveEndGap(Buffer.ReservedSize) }\n}\n\n@Suppress(\"DEPRECATION\", \"NOTHING_TO_INLINE\")\nprivate inline fun ByteWriteChannel.writeSessionFor(): WriterSuspendSession? = when {\n    this is HasWriteSession -> beginWriteSession()\n    else -> null\n}\n\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.ExperimentalIoApi\n\n/**\n * Reverse number's byte order\n */\nexpect fun Short.reverseByteOrder(): Short\n\n/**\n * Reverse number's byte order\n */\nexpect fun Int.reverseByteOrder(): Int\n\n/**\n * Reverse number's byte order\n */\nexpect fun Long.reverseByteOrder(): Long\n\n/**\n * Reverse number's byte order\n */\nexpect fun Float.reverseByteOrder(): Float\n\n/**\n * Reverse number's byte order\n */\nexpect fun Double.reverseByteOrder(): Double\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\nfun UShort.reverseByteOrder(): UShort = toShort().reverseByteOrder().toUShort()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\nfun UInt.reverseByteOrder(): UInt = toInt().reverseByteOrder().toUInt()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\nfun ULong.reverseByteOrder(): ULong = toLong().reverseByteOrder().toULong()\n\n@ExperimentalIoApi\ninline val Short.highByte: Byte get() = (toInt() ushr 8).toByte()\n\n@ExperimentalIoApi\ninline val Short.lowByte: Byte get() = (toInt() and 0xff).toByte()\n\n@ExperimentalIoApi\ninline val Int.highShort: Short get() = (this ushr 16).toShort()\n\n@ExperimentalIoApi\ninline val Int.lowShort: Short get() = (this and 0xffff).toShort()\n\n@ExperimentalIoApi\ninline val Long.highInt: Int get() = (this ushr 32).toInt()\n\n@ExperimentalIoApi\ninline val Long.lowInt: Int get() = (this and 0xffffffffL).toInt()\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.*\n\n/**\n * Represents a linear range of bytes.\n * All operations are guarded by range-checks by default however at some platforms they could be disabled\n * in release builds.\n *\n * Instance of this class has no additional state except the bytes themselves.\n */\n@ExperimentalIoApi\nexpect class Memory {\n    /**\n     * Size of memory range in bytes.\n     */\n    val size: Long\n\n    /**\n     * Size of memory range in bytes represented as signed 32bit integer\n     * @throws IllegalStateException when size doesn't fit into a signed 32bit integer\n     */\n    val size32: Int\n\n    /**\n     * Returns byte at [index] position.\n     */\n    inline fun loadAt(index: Int): Byte\n\n    /**\n     * Returns byte at [index] position.\n     */\n    inline fun loadAt(index: Long): Byte\n\n    /**\n     * Write [value] at the specified [index].\n     */\n    inline fun storeAt(index: Int, value: Byte)\n\n    /**\n     * Write [value] at the specified [index]\n     */\n    inline fun storeAt(index: Long, value: Byte)\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    fun slice(offset: Int, length: Int): Memory\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    fun slice(offset: Long, length: Long): Memory\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    fun copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int)\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    fun copyTo(destination: Memory, offset: Long, length: Long, destinationOffset: Long)\n\n    companion object {\n        /**\n         * Represents an empty memory region\n         */\n        val Empty: Memory\n    }\n}\n\n/**\n * Read byte at the specified [index].\n */\ninline operator fun Memory.get(index: Int): Byte = loadAt(index)\n\n/**\n * Read byte at the specified [index].\n */\ninline operator fun Memory.get(index: Long): Byte = loadAt(index)\n\n/**\n * Index write operator to write [value] at the specified [index]\n */\ninline operator fun Memory.set(index: Long, value: Byte) = storeAt(index, value)\n\n/**\n * Index write operator to write [value] at the specified [index]\n */\ninline operator fun Memory.set(index: Int, value: Byte) = storeAt(index, value)\n\n/**\n * Index write operator to write [value] at the specified [index]\n */\ninline fun Memory.storeAt(index: Long, value: UByte) = storeAt(index, value.toByte())\n\n/**\n * Index write operator to write [value] at the specified [index]\n */\ninline fun Memory.storeAt(index: Int, value: UByte) = storeAt(index, value.toByte())\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\nexpect fun Memory.fill(offset: Long, count: Long, value: Byte)\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\nexpect fun Memory.fill(offset: Int, count: Int, value: Byte)\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\nexpect fun Memory.copyTo(destination: ByteArray, offset: Int, length: Int, destinationOffset: Int = 0)\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\nexpect fun Memory.copyTo(destination: ByteArray, offset: Long, length: Int, destinationOffset: Int = 0)\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.require\n\n/**\n * Represents a linear range of bytes.\n */\nactual class Memory @DangerousInternalIoApi constructor(val view: DataView) {\n    /**\n     * Size of memory range in bytes.\n     */\n    actual inline val size: Long get() = view.byteLength.toLong()\n\n    /**\n     * Size of memory range in bytes represented as signed 32bit integer\n     * @throws IllegalStateException when size doesn't fit into a signed 32bit integer\n     */\n    actual inline val size32: Int get() = view.byteLength\n\n    /**\n     * Returns byte at [index] position.\n     */\n    actual inline fun loadAt(index: Int): Byte {\n        return view.getInt8(index)\n    }\n\n    /**\n     * Returns byte at [index] position.\n     */\n    actual inline fun loadAt(index: Long): Byte {\n        return view.getInt8(index.toIntOrFail(\"index\"))\n    }\n\n    /**\n     * Write [value] at the specified [index].\n     */\n    actual inline fun storeAt(index: Int, value: Byte) {\n        view.setInt8(index, value)\n    }\n\n    /**\n     * Write [value] at the specified [index]\n     */\n    actual inline fun storeAt(index: Long, value: Byte) {\n        view.setInt8(index.toIntOrFail(\"index\"), value)\n    }\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    actual fun slice(offset: Int, length: Int): Memory {\n        require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        if (offset + length > size) {\n            throw IndexOutOfBoundsException(\"offset + length > size: $offset + $length > $size\")\n        }\n\n        return Memory(\n            DataView(\n                view.buffer,\n                view.byteOffset + offset,\n                length\n            )\n        )\n    }\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    actual fun slice(offset: Long, length: Long): Memory {\n        return slice(offset.toIntOrFail(\"offset\"), length.toIntOrFail(\"length\"))\n    }\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    actual fun copyTo(\n        destination: Memory,\n        offset: Int,\n        length: Int,\n        destinationOffset: Int\n    ) {\n        val src = Int8Array(view.buffer, view.byteOffset + offset, length)\n        val dst = Int8Array(destination.view.buffer, destination.view.byteOffset + destinationOffset, length)\n\n        dst.set(src)\n    }\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    actual fun copyTo(\n        destination: Memory,\n        offset: Long,\n        length: Long,\n        destinationOffset: Long\n    ) {\n        copyTo(\n            destination,\n            offset.toIntOrFail(\"offset\"),\n            length.toIntOrFail(\"length\"),\n            destinationOffset.toIntOrFail(\"destinationOffset\")\n        )\n    }\n\n    actual companion object {\n        /**\n         * Represents an empty memory region\n         */\n        actual val Empty: Memory = Memory(DataView(ArrayBuffer(0)))\n    }\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\nactual fun Memory.copyTo(\n    destination: ByteArray,\n    offset: Int,\n    length: Int,\n    destinationOffset: Int\n) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to: Int8Array = destination.asDynamic()\n\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, destinationOffset)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\nactual fun Memory.copyTo(\n    destination: ByteArray,\n    offset: Long,\n    length: Int,\n    destinationOffset: Int\n) {\n    copyTo(destination, offset.toIntOrFail(\"offset\"), length, destinationOffset)\n}\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\nactual fun Memory.fill(offset: Int, count: Int, value: Byte) {\n    for (index in offset until offset + count) {\n        this[index] = value\n    }\n}\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\nactual fun Memory.fill(offset: Long, count: Long, value: Byte) {\n    fill(offset.toIntOrFail(\"offset\"), count.toIntOrFail(\"count\"), value)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\nfun Memory.copyTo(destination: ArrayBuffer, offset: Int, length: Int, destinationOffset: Int) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to = Int8Array(destination, destinationOffset, length)\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\nfun Memory.copyTo(destination: ArrayBufferView, offset: Int, length: Int, destinationOffset: Int) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to = Int8Array(destination.buffer, destinationOffset + destination.byteOffset, length)\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\nfun ArrayBuffer.copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int) {\n    val from = Int8Array(this, offset, length)\n    val to = Int8Array(destination.view.buffer, destination.view.byteOffset + destinationOffset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\nfun ArrayBufferView.copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int) {\n    buffer.copyTo(destination, offset + byteOffset, length, destinationOffset)\n}\n\ninternal val Memory.Int8ArrayView: Int8Array get() = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n","package io.ktor.utils.io.core.internal\n\n@PublishedApi\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.toIntOrFail(name: String): Int {\n    if (this >= Int.MAX_VALUE) failLongToIntConversion(this, name)\n    return toInt()\n}\n\n@PublishedApi\ninternal fun failLongToIntConversion(value: Long, name: String): Nothing =\n    throw IllegalArgumentException(\"Long value $value of $name doesn't fit into 32-bit integer\")\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n// TODO: length default argument should be this.size - offset but it doesn't work due to KT-29920\n/**\n * Execute [block] of code providing a temporary instance of [Memory] view of this byte array range\n * starting at the specified [offset] and having the specified bytes [length].\n * By default, if neither [offset] nor [length] specified, the whole array is used.\n * An instance of [Memory] provided into the [block] should be never captured and used outside of lambda.\n */\n@ExperimentalIoApi\nexpect fun <R> ByteArray.useMemory(offset: Int = 0, length: Int, block: (Memory) -> R): R\n\n/**\n * Invoke [block] function with a temporary [Memory] instance of the specified [size] in bytes.\n * The provided instance shouldn't be captured and used outside of the [block] otherwise an undefined behaviour\n * may occur including crash and/or data corruption.\n */\n@ExperimentalIoApi\ninline fun <R> withMemory(size: Int, block: (Memory) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return withMemory(size.toLong(), block)\n}\n\n/**\n * Invoke [block] function with a temporary [Memory] instance of the specified [size] in bytes.\n * The provided instance shouldn't be captured and used outside of the [block] otherwise an undefined behaviour\n * may occur including crash and/or data corruption.\n */\n@ExperimentalIoApi\ninline fun <R> withMemory(size: Long, block: (Memory) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val allocator = DefaultAllocator\n    val memory = allocator.alloc(size)\n    return try {\n        block(memory)\n    } finally {\n        allocator.free(memory)\n    }\n}\n\n@PublishedApi\ninternal expect object DefaultAllocator : Allocator\n\n@DangerousInternalIoApi\ninternal interface Allocator {\n    fun alloc(size: Int): Memory\n\n    fun alloc(size: Long): Memory\n\n    fun free(instance: Memory)\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Read short signed 16bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadShortAt(offset: Int): Short\n\n/**\n * Read short signed 16bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadShortAt(offset: Long): Short\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeShortAt(offset: Int, value: Short)\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeShortAt(offset: Long, value: Short)\n\n/**\n * Read short unsigned 16bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.loadUShortAt(offset: Int): UShort = loadShortAt(offset).toUShort()\n\n/**\n * Read short unsigned 16bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.loadUShortAt(offset: Long): UShort = loadShortAt(offset).toUShort()\n\n/**\n * Write short unsigned 16bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.storeUShortAt(offset: Int, value: UShort): Unit = storeShortAt(offset, value.toShort())\n\n/**\n * Write short unsigned 16bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.storeUShortAt(offset: Long, value: UShort): Unit = storeShortAt(offset, value.toShort())\n\n/**\n * Read regular signed 32bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadIntAt(offset: Int): Int\n\n/**\n * Read regular signed 32bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadIntAt(offset: Long): Int\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeIntAt(offset: Int, value: Int)\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeIntAt(offset: Long, value: Int)\n\n/**\n * Read regular unsigned 32bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.loadUIntAt(offset: Int): UInt = loadIntAt(offset).toUInt()\n\n/**\n * Read regular unsigned 32bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.loadUIntAt(offset: Long): UInt = loadIntAt(offset).toUInt()\n\n/**\n * Write regular unsigned 32bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.storeUIntAt(offset: Int, value: UInt): Unit = storeIntAt(offset, value.toInt())\n\n/**\n * Write regular unsigned 32bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.storeUIntAt(offset: Long, value: UInt): Unit = storeIntAt(offset, value.toInt())\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadLongAt(offset: Int): Long\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadLongAt(offset: Long): Long\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeLongAt(offset: Int, value: Long)\n\n/**\n * write short signed 64bit integer in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeLongAt(offset: Long, value: Long)\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.loadULongAt(offset: Int): ULong = loadLongAt(offset).toULong()\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.loadULongAt(offset: Long): ULong = loadLongAt(offset).toULong()\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.storeULongAt(offset: Int, value: ULong): Unit = storeLongAt(offset, value.toLong())\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\ninline fun Memory.storeULongAt(offset: Long, value: ULong): Unit = storeLongAt(offset, value.toLong())\n\n/**\n * Read short signed 32bit floating point number in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadFloatAt(offset: Int): Float\n\n/**\n * Read short signed 32bit floating point number in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadFloatAt(offset: Long): Float\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeFloatAt(offset: Int, value: Float)\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeFloatAt(offset: Long, value: Float)\n\n/**\n * Read short signed 64bit floating point number in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadDoubleAt(offset: Int): Double\n\n/**\n * Read short signed 64bit floating point number in the network byte order (Big Endian)\n */\nexpect inline fun Memory.loadDoubleAt(offset: Long): Double\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeDoubleAt(offset: Int, value: Double)\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\nexpect inline fun Memory.storeDoubleAt(offset: Long, value: Double)\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset].\n */\ninline fun Memory.loadByteArray(\n    offset: Int,\n    destination: ByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination, offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadByteArray(\n    offset: Long,\n    destination: ByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination, offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadUByteArray(\n    offset: Int,\n    destination: UByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination.asByteArray(), offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadUByteArray(\n    offset: Long,\n    destination: UByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination.asByteArray(), offset, count, destinationOffset)\n}\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadShortArray(\n    offset: Int,\n    destination: ShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadShortArray(\n    offset: Long,\n    destination: ShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadUShortArray(\n    offset: Int,\n    destination: UShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadShortArray(offset, destination.asShortArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadUShortArray(\n    offset: Long,\n    destination: UShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadShortArray(offset, destination.asShortArray(), destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadIntArray(\n    offset: Int,\n    destination: IntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadIntArray(\n    offset: Long,\n    destination: IntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadUIntArray(\n    offset: Int,\n    destination: UIntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadIntArray(offset, destination.asIntArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadUIntArray(\n    offset: Long,\n    destination: UIntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadIntArray(offset, destination.asIntArray(), destinationOffset, count)\n}\n\n/**\n * Copies long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadLongArray(\n    offset: Int,\n    destination: LongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadLongArray(\n    offset: Long,\n    destination: LongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadULongArray(\n    offset: Int,\n    destination: ULongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadLongArray(offset, destination.asLongArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\ninline fun Memory.loadULongArray(\n    offset: Long,\n    destination: ULongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadLongArray(offset, destination.asLongArray(), destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadFloatArray(\n    offset: Int,\n    destination: FloatArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadFloatArray(\n    offset: Long,\n    destination: FloatArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadDoubleArray(\n    offset: Int,\n    destination: DoubleArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nexpect fun Memory.loadDoubleArray(\n    offset: Long,\n    destination: DoubleArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\ninline fun Memory.storeByteArray(\n    offset: Int,\n    source: ByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    source.useMemory(sourceOffset, count) { sourceMemory ->\n        sourceMemory.copyTo(this, 0, count, offset)\n    }\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\ninline fun Memory.storeByteArray(\n    offset: Long,\n    source: ByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    source.useMemory(sourceOffset, count) { sourceMemory ->\n        sourceMemory.copyTo(this, 0L, count.toLong(), offset)\n    }\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\ninline fun Memory.storeUByteArray(\n    offset: Int,\n    source: UByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeByteArray(offset, source.asByteArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\ninline fun Memory.storeUByteArray(\n    offset: Long,\n    source: UByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeByteArray(offset, source.asByteArray(), sourceOffset, count)\n}\n\n/**\n * Copies shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeShortArray(\n    offset: Int,\n    source: ShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeShortArray(\n    offset: Long,\n    source: ShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\ninline fun Memory.storeUShortArray(\n    offset: Int,\n    source: UShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeShortArray(offset, source.asShortArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\ninline fun Memory.storeUShortArray(\n    offset: Long,\n    source: UShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeShortArray(offset, source.asShortArray(), sourceOffset, count)\n}\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeIntArray(\n    offset: Int,\n    source: IntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeIntArray(\n    offset: Long,\n    source: IntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\ninline fun Memory.storeUIntArray(\n    offset: Int,\n    source: UIntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeIntArray(offset, source.asIntArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\ninline fun Memory.storeUIntArray(\n    offset: Long,\n    source: UIntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeIntArray(offset, source.asIntArray(), sourceOffset, count)\n}\n\n/**\n * Copies long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeLongArray(\n    offset: Int,\n    source: LongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeLongArray(\n    offset: Long,\n    source: LongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\ninline fun Memory.storeULongArray(\n    offset: Int,\n    source: ULongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeLongArray(offset, source.asLongArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\ninline fun Memory.storeULongArray(\n    offset: Long,\n    source: ULongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeLongArray(offset, source.asLongArray(), sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeFloatArray(\n    offset: Int,\n    source: FloatArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeFloatArray(\n    offset: Long,\n    source: FloatArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeDoubleArray(\n    offset: Int,\n    source: DoubleArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nexpect fun Memory.storeDoubleArray(\n    offset: Long,\n    source: DoubleArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"UArraysKt\")\n@file:kotlin.jvm.JvmPackageName(\"kotlin.collections.unsigned\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component1(): UInt {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component1(): ULong {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component1(): UByte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component1(): UShort {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component2(): UInt {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component2(): ULong {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component2(): UByte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component2(): UShort {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component3(): UInt {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component3(): ULong {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component3(): UByte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component3(): UShort {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component4(): UInt {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component4(): ULong {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component4(): UByte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component4(): UShort {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component5(): UInt {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component5(): ULong {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component5(): UByte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component5(): UShort {\n    return get(4)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.elementAt(index: Int): UInt\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.elementAt(index: Int): ULong\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.elementAt(index: Int): UByte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.elementAt(index: Int): UShort\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrNull(index: Int): UInt? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrNull(index: Int): ULong? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrNull(index: Int): UByte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrNull(index: Int): UShort? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.find(predicate: (UInt) -> Boolean): UInt? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.find(predicate: (ULong) -> Boolean): ULong? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.find(predicate: (UByte) -> Boolean): UByte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.find(predicate: (UShort) -> Boolean): UShort? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.findLast(predicate: (UInt) -> Boolean): UInt? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.findLast(predicate: (ULong) -> Boolean): ULong? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.findLast(predicate: (UByte) -> Boolean): UByte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.findLast(predicate: (UShort) -> Boolean): UShort? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(): UInt {\n    return storage.first().toUInt()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(): ULong {\n    return storage.first().toULong()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(): UByte {\n    return storage.first().toUByte()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(): UShort {\n    return storage.first().toUShort()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(predicate: (UInt) -> Boolean): UInt {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(predicate: (ULong) -> Boolean): ULong {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(predicate: (UByte) -> Boolean): UByte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(predicate: (UShort) -> Boolean): UShort {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.firstOrNull(): UInt? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.firstOrNull(): ULong? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.firstOrNull(): UByte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.firstOrNull(): UShort? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.firstOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.firstOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.firstOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.firstOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.getOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.getOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.getOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.getOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.getOrNull(index: Int): UInt? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.getOrNull(index: Int): ULong? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.getOrNull(index: Int): UByte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.getOrNull(index: Int): UShort? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOf(element: UInt): Int {\n    return storage.indexOf(element.toInt())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOf(element: ULong): Int {\n    return storage.indexOf(element.toLong())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOf(element: UByte): Int {\n    return storage.indexOf(element.toByte())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOf(element: UShort): Int {\n    return storage.indexOf(element.toShort())\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfFirst(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfFirst(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfFirst(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfFirst(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUShort()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfLast(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfLast(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfLast(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfLast(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUShort()) }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(): UInt {\n    return storage.last().toUInt()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(): ULong {\n    return storage.last().toULong()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(): UByte {\n    return storage.last().toUByte()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(): UShort {\n    return storage.last().toUShort()\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(predicate: (UInt) -> Boolean): UInt {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(predicate: (ULong) -> Boolean): ULong {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(predicate: (UByte) -> Boolean): UByte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(predicate: (UShort) -> Boolean): UShort {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastIndexOf(element: UInt): Int {\n    return storage.lastIndexOf(element.toInt())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastIndexOf(element: ULong): Int {\n    return storage.lastIndexOf(element.toLong())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastIndexOf(element: UByte): Int {\n    return storage.lastIndexOf(element.toByte())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastIndexOf(element: UShort): Int {\n    return storage.lastIndexOf(element.toShort())\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.lastOrNull(): UInt? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.lastOrNull(): ULong? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.lastOrNull(): UByte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.lastOrNull(): UShort? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.random(): UInt {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.random(): ULong {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.random(): UByte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.random(): UShort {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.random(random: Random): UInt {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.random(random: Random): ULong {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.random(random: Random): UByte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.random(random: Random): UShort {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.randomOrNull(): UInt? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.randomOrNull(): ULong? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.randomOrNull(): UByte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.randomOrNull(): UShort? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\npublic fun UIntArray.randomOrNull(random: Random): UInt? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\npublic fun ULongArray.randomOrNull(random: Random): ULong? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\npublic fun UByteArray.randomOrNull(random: Random): UByte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\npublic fun UShortArray.randomOrNull(random: Random): UShort? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(): UInt {\n    return storage.single().toUInt()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(): ULong {\n    return storage.single().toULong()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(): UByte {\n    return storage.single().toUByte()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(): UShort {\n    return storage.single().toUShort()\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(predicate: (UInt) -> Boolean): UInt {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UInt\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(predicate: (ULong) -> Boolean): ULong {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as ULong\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(predicate: (UByte) -> Boolean): UByte {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UByte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(predicate: (UShort) -> Boolean): UShort {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UShort\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.singleOrNull(): UInt? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.singleOrNull(): ULong? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.singleOrNull(): UByte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.singleOrNull(): UShort? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.singleOrNull(predicate: (UInt) -> Boolean): UInt? {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.singleOrNull(predicate: (ULong) -> Boolean): ULong? {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.singleOrNull(predicate: (UByte) -> Boolean): UByte? {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.singleOrNull(predicate: (UShort) -> Boolean): UShort? {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.drop(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.drop(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.drop(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.drop(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.dropLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.dropLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.dropLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.dropLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    var yielding = false\n    val list = ArrayList<UInt>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    var yielding = false\n    val list = ArrayList<ULong>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    var yielding = false\n    val list = ArrayList<UByte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    var yielding = false\n    val list = ArrayList<UShort>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filter(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filter(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filter(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filter(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterIndexed(predicate: (index: Int, UInt) -> Boolean): List<UInt> {\n    return filterIndexedTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterIndexed(predicate: (index: Int, ULong) -> Boolean): List<ULong> {\n    return filterIndexedTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterIndexed(predicate: (index: Int, UByte) -> Boolean): List<UByte> {\n    return filterIndexedTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterIndexed(predicate: (index: Int, UShort) -> Boolean): List<UShort> {\n    return filterIndexedTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterIndexedTo(destination: C, predicate: (index: Int, UInt) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterIndexedTo(destination: C, predicate: (index: Int, ULong) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterIndexedTo(destination: C, predicate: (index: Int, UByte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterIndexedTo(destination: C, predicate: (index: Int, UShort) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterNot(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterNotTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterNot(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterNotTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterNot(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterNotTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterNot(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterNotTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterNotTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterNotTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterNotTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterNotTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: IntRange): List<UInt> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: IntRange): List<ULong> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: IntRange): List<UByte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: IntRange): List<UShort> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: Iterable<Int>): List<UInt> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UInt>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: Iterable<Int>): List<ULong> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<ULong>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: Iterable<Int>): List<UByte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UByte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: Iterable<Int>): List<UShort> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UShort>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: Collection<Int>): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: Collection<Int>): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: Collection<Int>): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: Collection<Int>): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: IntRange): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: IntRange): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: IntRange): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: IntRange): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.take(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UInt>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.take(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<ULong>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.take(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UByte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.take(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UShort>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.takeLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UInt>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.takeLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<ULong>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.takeLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UByte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.takeLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UShort>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    val list = ArrayList<UInt>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    val list = ArrayList<ULong>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    val list = ArrayList<UByte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    val list = ArrayList<UShort>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.reversed(): List<UInt> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.reversed(): List<ULong> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.reversed(): List<UByte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.reversed(): List<UShort> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reversedArray(): UIntArray {\n    return UIntArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reversedArray(): ULongArray {\n    return ULongArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reversedArray(): UByteArray {\n    return UByteArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reversedArray(): UShortArray {\n    return UShortArray(storage.reversedArray())\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sorted(): List<UInt> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sorted(): List<ULong> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sorted(): List<UByte> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sorted(): List<UShort> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArray(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArray(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArray(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArray(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArrayDescending(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArrayDescending(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArrayDescending(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArrayDescending(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedDescending(): List<UInt> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedDescending(): List<ULong> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedDescending(): List<UByte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedDescending(): List<UShort> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns an array of type [ByteArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.asByteArray(): ByteArray {\n    return storage\n}\n\n/**\n * Returns an array of type [IntArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.asIntArray(): IntArray {\n    return storage\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.asList(): List<UInt>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.asList(): List<ULong>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.asList(): List<UByte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.asList(): List<UShort>\n\n/**\n * Returns an array of type [LongArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.asLongArray(): LongArray {\n    return storage\n}\n\n/**\n * Returns an array of type [ShortArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.asShortArray(): ShortArray {\n    return storage\n}\n\n/**\n * Returns an array of type [UByteArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.asUByteArray(): UByteArray {\n    return UByteArray(this)\n}\n\n/**\n * Returns an array of type [UIntArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.asUIntArray(): UIntArray {\n    return UIntArray(this)\n}\n\n/**\n * Returns an array of type [ULongArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.asULongArray(): ULongArray {\n    return ULongArray(this)\n}\n\n/**\n * Returns an array of type [UShortArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.asUShortArray(): UShortArray {\n    return UShortArray(this)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.contentEquals(other: UIntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.contentEquals(other: ULongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.contentEquals(other: UByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.contentEquals(other: UShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray?.contentEquals(other: UIntArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray?.contentEquals(other: ULongArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray?.contentEquals(other: UByteArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray?.contentEquals(other: UShortArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyInto(destination: UIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UIntArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyInto(destination: ULongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ULongArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyInto(destination: UByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UByteArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyInto(destination: UShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UShortArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(): UIntArray {\n    return UIntArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(): ULongArray {\n    return ULongArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(): UByteArray {\n    return UByteArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(): UShortArray {\n    return UShortArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(newSize: Int): UIntArray {\n    return UIntArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(newSize: Int): ULongArray {\n    return ULongArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(newSize: Int): UByteArray {\n    return UByteArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(newSize: Int): UShortArray {\n    return UShortArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOfRange(fromIndex: Int, toIndex: Int): UIntArray {\n    return UIntArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOfRange(fromIndex: Int, toIndex: Int): ULongArray {\n    return ULongArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOfRange(fromIndex: Int, toIndex: Int): UByteArray {\n    return UByteArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOfRange(fromIndex: Int, toIndex: Int): UShortArray {\n    return UShortArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.fill(element: UInt, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toInt(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.fill(element: ULong, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toLong(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.fill(element: UByte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toByte(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.fill(element: UShort, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toShort(), fromIndex, toIndex)\n}\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray {\n    return UIntArray(storage + element.toInt())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray {\n    return ULongArray(storage + element.toLong())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray {\n    return UByteArray(storage + element.toByte())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray {\n    return UShortArray(storage + element.toShort())\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toInt()\n    return UIntArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toLong()\n    return ULongArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toByte()\n    return UByteArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toShort()\n    return UShortArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray {\n    return UIntArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray {\n    return ULongArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray {\n    return UByteArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray {\n    return UShortArray(storage + elements.storage)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns an array of type [ByteArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.toByteArray(): ByteArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [IntArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.toIntArray(): IntArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [LongArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.toLongArray(): LongArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [ShortArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.toShortArray(): ShortArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.toTypedArray(): Array<UInt> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.toTypedArray(): Array<ULong> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.toTypedArray(): Array<UByte> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.toTypedArray(): Array<UShort> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of UByte containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.toUByteArray(): UByteArray {\n    return UByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UByteArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.toUByteArray(): UByteArray {\n    return UByteArray(this.copyOf())\n}\n\n/**\n * Returns an array of UInt containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.toUIntArray(): UIntArray {\n    return UIntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UIntArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.toUIntArray(): UIntArray {\n    return UIntArray(this.copyOf())\n}\n\n/**\n * Returns an array of ULong containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.toULongArray(): ULongArray {\n    return ULongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [ULongArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.toULongArray(): ULongArray {\n    return ULongArray(this.copyOf())\n}\n\n/**\n * Returns an array of UShort containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.toUShortArray(): UShortArray {\n    return UShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UShortArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.toUShortArray(): UShortArray {\n    return UShortArray(this.copyOf())\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.associateWith(valueSelector: (UInt) -> V): Map<UInt, V> {\n    val result = LinkedHashMap<UInt, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.associateWith(valueSelector: (ULong) -> V): Map<ULong, V> {\n    val result = LinkedHashMap<ULong, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.associateWith(valueSelector: (UByte) -> V): Map<UByte, V> {\n    val result = LinkedHashMap<UByte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.associateWith(valueSelector: (UShort) -> V): Map<UShort, V> {\n    val result = LinkedHashMap<UShort, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UInt, in V>> UIntArray.associateWithTo(destination: M, valueSelector: (UInt) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in ULong, in V>> ULongArray.associateWithTo(destination: M, valueSelector: (ULong) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UByte, in V>> UByteArray.associateWithTo(destination: M, valueSelector: (UByte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UShort, in V>> UShortArray.associateWithTo(destination: M, valueSelector: (UShort) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMap(transform: (UInt) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMap(transform: (ULong) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMap(transform: (UByte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMap(transform: (UShort) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMapIndexed(transform: (index: Int, UInt) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMapIndexed(transform: (index: Int, ULong) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMapIndexed(transform: (index: Int, UByte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMapIndexed(transform: (index: Int, UShort) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapIndexedTo(destination: C, transform: (index: Int, UInt) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapIndexedTo(destination: C, transform: (index: Int, ULong) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, UByte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, UShort) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapTo(destination: C, transform: (UInt) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapTo(destination: C, transform: (ULong) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapTo(destination: C, transform: (UByte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapTo(destination: C, transform: (UShort) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UInt>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> {\n    return groupByTo(LinkedHashMap<K, MutableList<ULong>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UByte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UShort>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UInt>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UInt>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<ULong>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<ULong>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UByte>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UByte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UShort>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UShort>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K, valueTransform: (UInt) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K, valueTransform: (ULong) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K, valueTransform: (UByte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K, valueTransform: (UShort) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.map(transform: (UInt) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.map(transform: (ULong) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.map(transform: (UByte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.map(transform: (UShort) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.mapIndexed(transform: (index: Int, UInt) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.mapIndexed(transform: (index: Int, ULong) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.mapIndexed(transform: (index: Int, UByte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.mapIndexed(transform: (index: Int, UShort) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapIndexedTo(destination: C, transform: (index: Int, UInt) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapIndexedTo(destination: C, transform: (index: Int, ULong) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapIndexedTo(destination: C, transform: (index: Int, UByte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapIndexedTo(destination: C, transform: (index: Int, UShort) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapTo(destination: C, transform: (UInt) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapTo(destination: C, transform: (ULong) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapTo(destination: C, transform: (UByte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapTo(destination: C, transform: (UShort) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.withIndex(): Iterable<IndexedValue<UInt>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.withIndex(): Iterable<IndexedValue<ULong>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.withIndex(): Iterable<IndexedValue<UByte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.withIndex(): Iterable<IndexedValue<UShort>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.all(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.all(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.all(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.all(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.count(predicate: (UInt) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.count(predicate: (ULong) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.count(predicate: (UByte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.count(predicate: (UShort) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.fold(initial: R, operation: (acc: R, UInt) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.fold(initial: R, operation: (acc: R, ULong) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.fold(initial: R, operation: (acc: R, UByte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.fold(initial: R, operation: (acc: R, UShort) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRight(initial: R, operation: (UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRight(initial: R, operation: (ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRight(initial: R, operation: (UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRight(initial: R, operation: (UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRightIndexed(initial: R, operation: (index: Int, UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRightIndexed(initial: R, operation: (index: Int, ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRightIndexed(initial: R, operation: (index: Int, UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRightIndexed(initial: R, operation: (index: Int, UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEach(action: (UInt) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEach(action: (ULong) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEach(action: (UByte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEach(action: (UShort) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEachIndexed(action: (index: Int, UInt) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEachIndexed(action: (index: Int, ULong) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEachIndexed(action: (index: Int, UByte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEachIndexed(action: (index: Int, UShort) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.max(): UInt? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.max(): ULong? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.max(): UByte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.max(): UShort? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R): UInt? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R): ULong? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R): UByte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R): UShort? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxOrNull(): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxOrNull(): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxOrNull(): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxOrNull(): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWith(comparator: Comparator<in UInt>): UInt? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWith(comparator: Comparator<in ULong>): ULong? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWith(comparator: Comparator<in UByte>): UByte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWith(comparator: Comparator<in UShort>): UShort? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.min(): UInt? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.min(): ULong? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.min(): UByte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.min(): UShort? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R): UInt? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R): ULong? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R): UByte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R): UShort? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minOrNull(): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minOrNull(): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minOrNull(): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minOrNull(): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWith(comparator: Comparator<in UInt>): UInt? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWith(comparator: Comparator<in ULong>): ULong? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWith(comparator: Comparator<in UByte>): UByte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWith(comparator: Comparator<in UShort>): UShort? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEach(action: (UInt) -> Unit): UIntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEach(action: (ULong) -> Unit): ULongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEach(action: (UByte) -> Unit): UByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEach(action: (UShort) -> Unit): UShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEachIndexed(action: (index: Int, UInt) -> Unit): UIntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEachIndexed(action: (index: Int, ULong) -> Unit): ULongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEachIndexed(action: (index: Int, UByte) -> Unit): UByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEachIndexed(action: (index: Int, UShort) -> Unit): UShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduce(operation: (acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduce(operation: (acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduce(operation: (acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduce(operation: (acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexedOrNull(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexedOrNull(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexedOrNull(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexedOrNull(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceOrNull(operation: (acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceOrNull(operation: (acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceOrNull(operation: (acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceOrNull(operation: (acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRight(operation: (UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRight(operation: (ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRight(operation: (UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRight(operation: (UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexed(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexed(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexed(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexed(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexedOrNull(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexedOrNull(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexedOrNull(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexedOrNull(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightOrNull(operation: (UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightOrNull(operation: (ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightOrNull(operation: (UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightOrNull(operation: (UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFold(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFold(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFold(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFold(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduce(operation: (acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduce(operation: (acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduce(operation: (acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduce(operation: (acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scan(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scan(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scan(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scan(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.scanReduce(operation: (acc: UInt, UInt) -> UInt): List<UInt> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.scanReduce(operation: (acc: ULong, ULong) -> ULong): List<ULong> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.scanReduce(operation: (acc: UByte, UByte) -> UByte): List<UByte> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.scanReduce(operation: (acc: UShort, UShort) -> UShort): List<UShort> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.scanReduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): List<UInt> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.scanReduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): List<ULong> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.scanReduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): List<UByte> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.scanReduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): List<UShort> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumBy(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumBy(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumBy(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumBy(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumByDouble(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumByDouble(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumByDouble(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumByDouble(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Array<out R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Array<out R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Array<out R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Array<out R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Array<out R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Array<out R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Array<out R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Array<out R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Iterable<R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Iterable<R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Iterable<R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Iterable<R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Iterable<R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Iterable<R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Iterable<R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Iterable<R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.zip(other: UIntArray): List<Pair<UInt, UInt>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.zip(other: ULongArray): List<Pair<ULong, ULong>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.zip(other: UByteArray): List<Pair<UByte, UByte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.zip(other: UShortArray): List<Pair<UShort, UShort>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.zip(other: UIntArray, transform: (a: UInt, b: UInt) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.zip(other: ULongArray, transform: (a: ULong, b: ULong) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.zip(other: UByteArray, transform: (a: UByte, b: UByte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.zip(other: UShortArray, transform: (a: UShort, b: UShort) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.sum(): ULong {\n    var sum: ULong = 0uL\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUByte\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUShort\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sum(): UInt {\n    return storage.sum().toUInt()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sum(): ULong {\n    return storage.sum().toULong()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sum(): UInt {\n    return sumBy { it.toUInt() }\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sum(): UInt {\n    return sumBy { it.toUInt() }\n}\n\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.contracts.*\n\n/**\n * Execute [block] of code providing a temporary instance of [Memory] view of this byte array range\n * starting at the specified [offset] and having the specified bytes [length].\n * By default, if neither [offset] nor [length] specified, the whole array is used.\n * An instance of [Memory] provided into the [block] should be never captured and used outside of lambda.\n */\nactual inline fun <R> ByteArray.useMemory(offset: Int, length: Int, block: (Memory) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return Memory.of(this, offset, length).let(block)\n}\n\n/**\n * Create [Memory] view for the specified [array] range starting at [offset] and the specified bytes [length].\n */\nfun Memory.Companion.of(array: ByteArray, offset: Int = 0, length: Int = array.size - offset): Memory {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val typedArray: Int8Array = array.asDynamic()\n    return Memory.of(typedArray, offset, length)\n}\n\n/**\n * Create [Memory] view for the specified [buffer] range starting at [offset] and the specified bytes [length].\n */\nfun Memory.Companion.of(buffer: ArrayBuffer, offset: Int = 0, length: Int = buffer.byteLength - offset): Memory {\n    return Memory(DataView(buffer, offset, length))\n}\n\n/**\n * Create [Memory] view for the specified [view].\n */\nfun Memory.Companion.of(view: DataView): Memory {\n    return Memory(view)\n}\n\n/**\n * Create [Memory] view for the specified [view] range starting at [offset] and the specified bytes [length].\n */\nfun Memory.Companion.of(view: ArrayBufferView, offset: Int = 0, length: Int = view.byteLength): Memory {\n    return Memory.of(view.buffer, view.byteOffset + offset, length)\n}\n\n@PublishedApi\ninternal actual object DefaultAllocator : Allocator {\n    override fun alloc(size: Int): Memory = Memory(DataView(ArrayBuffer(size)))\n    override fun alloc(size: Long): Memory = Memory(DataView(ArrayBuffer(size.toIntOrFail(\"size\"))))\n    override fun free(instance: Memory) {\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\nexpect interface Output : Appendable, Closeable {\n    @Deprecated(\n        \"This is no longer supported. All operations are big endian by default. Use writeXXXLittleEndian \" +\n            \"to write primitives in little endian order\" +\n            \" or do X.reverseByteOrder() and then writeXXX instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    var byteOrder: ByteOrder\n\n    fun writeByte(v: Byte)\n\n    fun flush()\n\n    override fun close()\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeShort(v: Short) {\n        writeShort(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeInt(v: Int) {\n        writeInt(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeLong(v: Long) {\n        writeLong(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeFloat(v: Float) {\n        writeFloat(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeDouble(v: Double) {\n        writeDouble(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeFully(src: IntArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeFully(src: LongArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun writeFully(src: IoBuffer, length: Int) {\n        writeFully(src, length)\n    }\n\n    fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun fill(n: Long, v: Byte) {\n        fill(n, v)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.append(csq: CharSequence, start: Int = 0, end: Int = csq.length): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.append(csq: CharArray, start: Int = 0, end: Int = csq.size): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: ByteArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyBytesTemplate(offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: ShortArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(2, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: IntArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(4, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: LongArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(8, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: FloatArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(4, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: DoubleArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(8, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Output.writeFully(src: IoBuffer, length: Int = src.readRemaining) {\n    writeFully(src as Buffer, length)\n}\n\nfun Output.writeFully(src: Buffer, length: Int = src.readRemaining) {\n    writeFullyBytesTemplate(0, length) { buffer, _, count ->\n        buffer.writeFully(src, count)\n    }\n}\n\nfun Output.writeFully(src: Memory, offset: Int, length: Int) {\n    writeFully(src, offset.toLong(), length.toLong())\n}\n\nfun Output.writeFully(src: Memory, offset: Long, length: Long) {\n    writeFullyBytesTemplate(offset, length) { memory, destinationOffset, sourceOffset, count ->\n        src.copyTo(memory, sourceOffset, count, destinationOffset)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.fill(times: Long, value: Byte = 0) {\n    if (this is AbstractOutput) {\n        var written = 0L\n        writeWhile { buffer ->\n            val partTimes = minOf(buffer.writeRemaining.toLong(), times - written).toInt()\n            buffer.fill(partTimes, value)\n            written += partTimes\n            written < times\n        }\n    } else {\n        fillFallback(times, value)\n    }\n}\n\nprivate fun Output.fillFallback(times: Long, value: Byte) {\n    for (iterate in 0 until times) {\n        writeByte(value)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is true.\n * Depending on the output underlying implementation it could invoke [block] function with the same buffer several times\n * however it is guaranteed that it is always non-empty.\n */\n@DangerousInternalIoApi\ninline fun Output.writeWhile(block: (Buffer) -> Boolean) {\n    var tail: ChunkBuffer = prepareWriteHead(1, null)\n    try {\n        while (true) {\n            if (!block(tail)) break\n            tail = prepareWriteHead(1, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is positive.\n * If returned value is positive then it will be invoked again with a buffer having at least requested number of\n * bytes space (could be the same buffer as before if it complies to the restriction).\n * @param initialSize for the first buffer passed to [block] function\n */\n@DangerousInternalIoApi\ninline fun Output.writeWhileSize(initialSize: Int = 1, block: (Buffer) -> Int) {\n    var tail = prepareWriteHead(initialSize, null)\n\n    try {\n        var size: Int\n        while (true) {\n            size = block(tail)\n            if (size <= 0) break\n            tail = prepareWriteHead(size, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\nfun Output.writePacket(packet: ByteReadPacket) {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        writePacket(packet)\n        return\n    }\n\n    packet.takeWhile { from ->\n        writeFully(from)\n        true\n    }\n}\n\nprivate inline fun Output.writeFullyBytesTemplate(\n    offset: Int,\n    length: Int,\n    block: (Buffer, currentOffset: Int, count: Int) -> Unit\n) {\n    var currentOffset = offset\n    var remaining = length\n\n    writeWhile { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining)\n        block(buffer, currentOffset, size)\n        currentOffset += size\n        remaining -= size\n        remaining > 0\n    }\n}\n\nprivate inline fun Output.writeFullyBytesTemplate(\n    initialOffset: Long,\n    length: Long,\n    block: (destination: Memory, destinationOffset: Long, currentOffset: Long, count: Long) -> Unit\n) {\n    var currentOffset = initialOffset\n    var remaining = length\n\n    writeWhile { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining.toLong())\n        block(buffer.memory, buffer.writePosition.toLong(), currentOffset, size)\n        buffer.commitWritten(size.toInt())\n        currentOffset += size\n        remaining -= size\n        remaining > 0\n    }\n}\n\nprivate inline fun Output.writeFullyTemplate(\n    componentSize: Int,\n    offset: Int,\n    length: Int,\n    block: (Buffer, currentOffset: Int, count: Int) -> Unit\n) {\n    var currentOffset = offset\n    var remaining = length\n\n    writeWhileSize(componentSize) { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining)\n        block(buffer, currentOffset, size)\n        currentOffset += size\n        remaining -= size\n        remaining * componentSize\n    }\n}\n\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.pool.*\n\n/**\n * The default abstract base class implementing [Input] interface.\n * @see [AbstractInput.fill] and [AbstractInput.closeSource].\n */\nabstract class AbstractInput(\n    head: ChunkBuffer = ChunkBuffer.Empty,\n    remaining: Long = head.remainingAll(),\n    val pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n) : Input {\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    constructor(head: IoBuffer = IoBuffer.Empty,\n                remaining: Long = head.remainingAll(),\n                pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool) : this(head as ChunkBuffer, remaining, pool)\n\n    /**\n     * Read the next bytes into the [destination] starting at [offset] at most [length] bytes.\n     * May block until at least one byte is available.\n     * Usually bypass all exceptions from the underlying source.\n     *\n     * @param offset in bytes where result should be written\n     * @param length should be at least one byte\n     *\n     * @return number of bytes were copied or `0` if EOF encountered\n     */\n    protected abstract fun fill(destination: Memory, offset: Int, length: Int): Int\n\n    /**\n     * Should close the underlying bytes source. Could do nothing or throw exceptions.\n     */\n    protected abstract fun closeSource()\n\n    /**\n     * Current head chunk reference\n     */\n    private final var __head: ChunkBuffer by shared(head)\n    private final var _head: ChunkBuffer\n        get() = __head\n        set(newHead) {\n            __head = newHead\n            headMemory = newHead.memory\n            headPosition = newHead.readPosition\n            headEndExclusive = newHead.writePosition\n        }\n\n    @PublishedApi\n    @Suppress(\"CanBePrimaryConstructorProperty\")\n    internal var head: ChunkBuffer\n        get() = _head.also { it.discardUntilIndex(headPosition) }\n        @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.ERROR)\n        set(newHead) {\n            _head = newHead\n        }\n\n    @PublishedApi\n    internal final var headMemory: Memory by shared(head.memory)\n\n    @PublishedApi\n    internal final var headPosition by shared(head.readPosition)\n\n    @PublishedApi\n    internal final var headEndExclusive by shared(head.writePosition)\n\n    @PublishedApi\n    @Suppress(\"DEPRECATION_ERROR\")\n    internal final var headRemaining\n        inline get() = headEndExclusive - headPosition\n        @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n        set(newRemaining) {\n            updateHeadRemaining(newRemaining)\n        }\n\n    private var _tailRemaining: Long by shared(remaining - headRemaining)\n    private var tailRemaining: Long\n        get() = _tailRemaining\n        set(newValue) {\n            require(newValue >= 0) { \"tailRemaining shouldn't be negative: $newValue\" }\n            _tailRemaining = newValue\n        }\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default.\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            if (newOrder != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only BIG_ENDIAN is supported.\")\n            }\n        }\n\n    internal final fun prefetch(min: Long): Boolean {\n        if (min <= 0) return true\n        val headRemaining = headRemaining\n        if (headRemaining >= min || headRemaining + tailRemaining >= min) return true\n\n        return doPrefetch(min)\n    }\n\n    final override fun peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n        prefetch(min + offset)\n\n        var current: ChunkBuffer = head\n        var copied = 0L\n        var skip = offset\n        var writePosition = destinationOffset\n        val maxCopySize = minOf(max, destination.size - destinationOffset)\n\n        while (copied < min && copied < maxCopySize) {\n            val chunkSize = current.readRemaining\n            if (chunkSize > skip) {\n                val size = minOf(chunkSize - skip, maxCopySize - copied)\n                current.memory.copyTo(\n                    destination,\n                    current.readPosition + skip,\n                    size,\n                    writePosition\n                )\n                skip = 0\n                copied += size\n                writePosition += size\n            } else {\n                skip -= chunkSize\n            }\n\n            current = current.next ?: break\n        }\n\n        return copied\n    }\n\n    /**\n     * @see doFill for similar logic\n     * @see appendView for similar logic\n     */\n    private fun doPrefetch(min: Long): Boolean {\n        var tail = _head.findTail()\n        var available = headRemaining + tailRemaining\n\n        do {\n            val next = fill()\n            if (next == null) {\n                noMoreChunksAvailable = true\n                return false\n            }\n\n            val chunkSize = next.readRemaining\n            if (tail === ChunkBuffer.Empty) {\n                _head = next\n                tail = next\n            } else {\n                tail.next = next\n                tailRemaining += chunkSize\n            }\n\n            available += chunkSize\n        } while (available < min)\n\n        return true\n    }\n\n    /**\n     * Number of bytes available for read\n     */\n    final val remaining: Long get() = headRemaining.toLong() + tailRemaining\n\n    /**\n     * @return `true` if there is at least one byte to read\n     */\n    final fun canRead() = headPosition != headEndExclusive || tailRemaining != 0L\n\n    /**\n     * @return `true` if there are at least [n] bytes to read\n     */\n    final fun hasBytes(n: Int) = headRemaining + tailRemaining >= n\n\n    /**\n     * `true` if no bytes available for read\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final val isEmpty: Boolean\n        get() = endOfInput\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final val isNotEmpty: Boolean\n        get() = isNotEmpty\n\n    private var noMoreChunksAvailable = false\n\n    final override val endOfInput: Boolean\n        get() = headRemaining == 0 && tailRemaining == 0L && (noMoreChunksAvailable || doFill() == null)\n\n    /**\n     * Release packet. After this function invocation the packet becomes empty.\n     * If it has been copied via [ByteReadPacket.copy]\n     * then the copy should be released as well.\n     */\n    final fun release() {\n        val head = head\n        val empty = ChunkBuffer.Empty\n\n        if (head !== empty) {\n            this._head = empty\n            tailRemaining = 0\n            head.releaseAll(pool)\n        }\n    }\n\n    final override fun close() {\n        release()\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n        closeSource()\n    }\n\n    internal final fun stealAll(): ChunkBuffer? {\n        val head = head\n        val empty = ChunkBuffer.Empty\n\n        if (head === empty) return null\n        this._head = empty\n        tailRemaining = 0\n        return head\n    }\n\n    internal final fun steal(): ChunkBuffer? {\n        val head = head\n        val next = head.next\n        val empty = ChunkBuffer.Empty\n        if (head === empty) return null\n\n        if (next == null) {\n            this._head = empty\n            this.tailRemaining = 0\n        } else {\n            this._head = next\n            this.tailRemaining -= next.readRemaining\n        }\n\n        head.next = null\n        return head\n    }\n\n    internal final fun append(chain: ChunkBuffer) {\n        if (chain === ChunkBuffer.Empty) return\n\n        val size = chain.remainingAll()\n        if (_head === ChunkBuffer.Empty) {\n            _head = chain\n            tailRemaining = size - headRemaining\n        } else {\n            _head.findTail().next = chain\n            tailRemaining += size\n        }\n    }\n\n    internal final fun tryWriteAppend(chain: ChunkBuffer): Boolean {\n        val tail = head.findTail()\n        val size = chain.readRemaining\n\n        if (size == 0 || tail.writeRemaining < size) return false\n        tail.writeBufferAppend(chain, size)\n\n        if (head === tail) {\n            headEndExclusive = tail.writePosition\n        } else {\n            tailRemaining += size\n        }\n\n        return true\n    }\n\n    final override fun readByte(): Byte {\n        val index = headPosition\n        val nextIndex = index + 1\n        if (nextIndex < headEndExclusive) {\n            // fast-path when we are not reading the last byte\n            headPosition = nextIndex\n            return headMemory[index]\n        }\n\n        return readByteSlow()\n    }\n\n    private fun readByteSlow(): Byte {\n        val index = headPosition\n        if (index < headEndExclusive) {\n            val value = headMemory[index]\n            headPosition = index\n            val head = _head\n            head.discardUntilIndex(index)\n            ensureNext(head)\n            return value\n        }\n\n        val head = prepareRead(1) ?: prematureEndOfStream(1)\n        val byte = head.readByte()\n        completeReadHead(head)\n        return byte\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readShort() = readShort()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFloat() = readFloat()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readDouble() = readDouble()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readInt(): Int {\n        return readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readLong(): Long {\n        return readLong()\n    }\n\n    /**\n     * Read exactly [length] bytes to [dst] array at specified [offset]\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc != length) throw EOFException(\"Not enough data in packet to fill buffer: ${length - rc} more bytes required\")\n    }\n\n    /**\n     * Discards at most [n] bytes\n     * @return number of bytes has been discarded\n     */\n    final fun discard(n: Int): Int {\n        require(n >= 0) { \"Negative discard is not allowed: $n\" }\n        return discardAsMuchAsPossible(n, 0)\n    }\n\n    /**\n     * Discards exactly [n] bytes or fails with [EOFException]\n     */\n    final fun discardExact(n: Int) {\n        if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes due to end of packet\")\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal inline fun read(block: (Buffer) -> Unit) {\n        read(block = block)\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal inline fun read(n: Int, block: (Buffer) -> Unit) {\n        read(n, block)\n    }\n\n    /**\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    final override fun tryPeek(): Int {\n        val head = head\n        if (headRemaining > 0) {\n            return head.tryPeekByte()\n        }\n\n        if (tailRemaining == 0L && noMoreChunksAvailable) return -1\n\n        return prepareReadLoop(1, head)?.tryPeekByte() ?: -1\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun peekTo(buffer: IoBuffer): Int {\n        val head = prepareReadHead(1) ?: return -1\n\n        val size = minOf(buffer.writeRemaining, head.readRemaining)\n        (buffer as Buffer).writeFully(head, size)\n\n        return size\n    }\n\n    final override fun discard(n: Long): Long {\n        if (n <= 0) return 0L\n        return discardAsMuchAsPossible(n, 0)\n    }\n\n    internal fun readAvailableCharacters(destination: CharArray, off: Int, len: Int): Int {\n        if (endOfInput) return -1\n\n        val out = object : Appendable {\n            private var idx = off\n\n            override fun append(c: Char): Appendable {\n                destination[idx++] = c\n                return this\n            }\n\n            override fun append(csq: CharSequence?): Appendable {\n                if (csq is String) {\n                    csq.getCharsInternal(destination, idx)\n                    idx += csq.length\n                } else if (csq != null) {\n                    for (i in 0 until csq.length) {\n                        destination[idx++] = csq[i]\n                    }\n                }\n\n                return this\n            }\n\n            override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n                throw UnsupportedOperationException()\n            }\n        }\n\n        return readText(out, 0, len)\n    }\n\n    /**\n     * Read at least [min] and at most [max] characters and append them to [out]\n     * @return number of characters appended\n     */\n    fun readText(out: Appendable, min: Int = 0, max: Int = Int.MAX_VALUE): Int {\n        if (max.toLong() >= remaining) {\n            val s = readTextExactBytes(bytesCount = remaining.toInt() )\n            out.append(s)\n            return s.length\n        }\n        return readASCII(out, min, max)\n    }\n\n    /**\n     * Read exactly [exactCharacters] characters and append them to [out]\n     */\n    fun readTextExact(out: Appendable, exactCharacters: Int) {\n        readText(out, exactCharacters, exactCharacters)\n    }\n\n    /**\n     * Read a string at last [min] and at most [max] characters length\n     */\n    fun readText(min: Int = 0, max: Int = Int.MAX_VALUE): String {\n        if (min == 0 && (max == 0 || endOfInput)) return \"\"\n        val remaining = remaining\n        if (remaining > 0 && max.toLong() >= remaining) return readTextExactBytes(bytesCount = remaining.toInt() )\n\n        return buildString(min.coerceAtLeast(16).coerceAtMost(max)) {\n            readASCII(this, min, max)\n        }\n    }\n\n    /**\n     * Read a string exactly [exactCharacters] length\n     */\n    fun readTextExact(exactCharacters: Int): String {\n        return readText(exactCharacters, exactCharacters)\n    }\n\n    private fun readASCII(out: Appendable, min: Int, max: Int): Int {\n        when {\n            max == 0 && min == 0 -> return 0\n            endOfInput -> if (min == 0) return 0 else atLeastMinCharactersRequire(min)\n            max < min -> minShouldBeLess(min, max)\n        }\n\n        var copied = 0\n        var utf8 = false\n\n        takeWhile { buffer ->\n            val rc = buffer.decodeASCII {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                rc -> true\n                copied == max -> false\n                else -> {\n                    utf8 = true\n                    false\n                }\n            }\n        }\n\n        if (utf8) {\n            return copied + readUtf8(out, min - copied, max - copied)\n        }\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n        return copied\n    }\n\n    private fun atLeastMinCharactersRequire(min: Int): Nothing =\n        throw EOFException(\"at least $min characters required but no bytes available\")\n\n    private fun minShouldBeLess(min: Int, max: Int): Nothing =\n        throw IllegalArgumentException(\"min should be less or equal to max but min = $min, max = $max\")\n\n    private fun prematureEndOfStreamChars(min: Int, copied: Int): Nothing = throw MalformedUTF8InputException(\n        \"Premature end of stream: expected at least $min chars but had only $copied\"\n    )\n\n    private fun readUtf8(out: Appendable, min: Int, max: Int): Int {\n        var copied = 0\n\n        takeWhileSize { buffer ->\n            val size = buffer.decodeUTF8 {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                size == 0 -> 1\n                size > 0 -> size\n                else -> 0\n            }\n        }\n\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n\n        return copied\n    }\n\n    private tailrec fun discardAsMuchAsPossible(n: Long, skipped: Long): Long {\n        if (n == 0L) return skipped\n        val current = prepareRead(1) ?: return skipped\n        val size = minOf(current.readRemaining.toLong(), n).toInt()\n        current.discardExact(size)\n        headPosition += size\n        afterRead(current)\n\n        return discardAsMuchAsPossible(n - size, skipped + size)\n    }\n\n    private tailrec fun discardAsMuchAsPossible(n: Int, skipped: Int): Int {\n        if (n == 0) return skipped\n        val current = prepareRead(1) ?: return skipped\n        val size = minOf(current.readRemaining, n)\n        current.discardExact(size)\n        headPosition += size\n        afterRead(current)\n\n        return discardAsMuchAsPossible(n - size, skipped + size)\n    }\n\n    private tailrec fun readAsMuchAsPossible(array: ByteArray, offset: Int, length: Int, copied: Int): Int {\n        if (length == 0) return copied\n        val current = prepareRead(1) ?: return copied\n        val size = minOf(length, current.readRemaining)\n\n        current.readFully(array, offset, size)\n        headPosition = current.readPosition\n\n        return if (size != length || current.readRemaining == 0) {\n            afterRead(current)\n            readAsMuchAsPossible(array, offset + size, length - size, copied + size)\n        } else {\n            copied + size\n        }\n    }\n\n    private fun notEnoughBytesAvailable(n: Int): Nothing {\n        throw EOFException(\"Not enough data in packet ($remaining) to read $n byte(s)\")\n    }\n\n    @Deprecated(\"Not supported anymore.\", level = DeprecationLevel.ERROR)\n    fun updateHeadRemaining(remaining: Int) {\n        // the only external usages are from readDirect\n        // so after using head chunk directly we should fix positions instead\n        val newPosition = headEndExclusive - remaining\n\n        if (newPosition < 0) {\n            throw IllegalArgumentException(\"Unable to update position to negative. newRemaining is too big.\")\n        }\n\n        headPosition = newPosition\n    }\n\n    @DangerousInternalIoApi\n    fun prepareReadHead(minSize: Int): ChunkBuffer? = prepareReadLoop(minSize, head)\n\n    @DangerousInternalIoApi\n    fun ensureNextHead(current: ChunkBuffer): ChunkBuffer? = ensureNext(current)\n\n    @PublishedApi\n    internal fun ensureNext(current: ChunkBuffer) = ensureNext(\n        current,\n        ChunkBuffer.Empty\n    )\n\n    @DangerousInternalIoApi\n    fun fixGapAfterRead(current: ChunkBuffer) {\n        val next = current.next ?: return fixGapAfterReadFallback(current)\n\n        val remaining = current.readRemaining\n        val overrunSize = minOf(remaining, Buffer.ReservedSize - current.endGap)\n        if (next.startGap < overrunSize) {\n            return fixGapAfterReadFallback(current)\n        }\n\n        next.restoreStartGap(overrunSize)\n\n        if (remaining > overrunSize) {\n            current.releaseEndGap()\n\n            this.headEndExclusive = current.writePosition\n            this.tailRemaining += overrunSize\n        } else {\n            this._head = next\n            this.tailRemaining -= next.readRemaining - overrunSize\n            current.cleanNext()\n            current.release(pool)\n        }\n    }\n\n    private fun fixGapAfterReadFallback(current: ChunkBuffer) {\n        if (noMoreChunksAvailable && current.next == null) {\n            this.headPosition = current.readPosition\n            this.headEndExclusive = current.writePosition\n            this.tailRemaining = 0\n            return\n        }\n\n        val size = current.readRemaining\n        val overrun = minOf(size, Buffer.ReservedSize - current.endGap)\n\n        if (size > overrun) {\n            fixGapAfterReadFallbackUnreserved(current, size, overrun)\n        } else {\n            val new = pool.borrow()\n            new.reserveEndGap(Buffer.ReservedSize)\n            new.next = current.cleanNext()\n\n            new.writeBufferAppend(current, size)\n            this._head = new\n        }\n\n        current.release(pool)\n    }\n\n    private fun fixGapAfterReadFallbackUnreserved(current: ChunkBuffer, size: Int, overrun: Int) {\n        // if we have a chunk with no end reservation\n        // we can split it into two to fix it\n\n        val chunk1 = pool.borrow()\n        val chunk2 = pool.borrow()\n\n        chunk1.reserveEndGap(Buffer.ReservedSize)\n        chunk2.reserveEndGap(Buffer.ReservedSize)\n        chunk1.next = chunk2\n        chunk2.next = current.cleanNext()\n\n        chunk1.writeBufferAppend(current, size - overrun)\n        chunk2.writeBufferAppend(current, overrun)\n\n        this._head = chunk1\n        this.tailRemaining = chunk2.remainingAll()\n    }\n\n    private tailrec fun ensureNext(current: ChunkBuffer, empty: ChunkBuffer): ChunkBuffer? {\n        if (current === empty) {\n            return doFill()\n        }\n\n        val next = current.cleanNext()\n        current.release(pool)\n\n        return when {\n            next == null -> {\n                this._head = empty\n                this.tailRemaining = 0L\n                ensureNext(empty, empty)\n            }\n            next.canRead() -> {\n                _head = next\n                tailRemaining -= next.readRemaining\n                next\n            }\n            else -> ensureNext(next, empty)\n        }\n    }\n\n    /**\n     * Reads the next chunk suitable for reading or `null` if no more chunks available. It is also allowed\n     * to return a chain of chunks linked through [ChunkBuffer.next]. The last chunk should have `null` next reference.\n     * Could rethrow exceptions from the underlying source.\n     */\n    protected open fun fill(): ChunkBuffer? {\n        val buffer = pool.borrow()\n        try {\n            buffer.reserveEndGap(Buffer.ReservedSize)\n            val copied = fill(buffer.memory, buffer.writePosition, buffer.writeRemaining)\n\n            if (copied == 0) {\n                noMoreChunksAvailable = true\n\n                if (!buffer.canRead()) {\n                    buffer.release(pool)\n                    return null\n                }\n            }\n\n            buffer.commitWritten(copied)\n\n            return buffer\n        } catch (t: Throwable) {\n            buffer.release(pool)\n            throw t\n        }\n    }\n\n    protected final fun markNoMoreChunksAvailable() {\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n    }\n\n    /**\n     * see [prefetch] for similar logic\n     */\n    private final fun doFill(): ChunkBuffer? {\n        if (noMoreChunksAvailable) return null\n        val chunk = fill()\n        if (chunk == null) {\n            noMoreChunksAvailable = true\n            return null\n        }\n        appendView(chunk)\n        return chunk\n    }\n\n    private final fun appendView(chunk: ChunkBuffer) {\n        val tail = _head.findTail()\n        if (tail === ChunkBuffer.Empty) {\n            _head = chunk\n            require(tailRemaining == 0L) {\n                throw IllegalStateException(\"It should be no tail remaining bytes if current tail is EmptyBuffer\")\n            }\n            tailRemaining = chunk.next?.remainingAll() ?: 0L\n        } else {\n            tail.next = chunk\n            tailRemaining += chunk.remainingAll()\n        }\n    }\n\n    @PublishedApi\n    internal fun prepareRead(minSize: Int): ChunkBuffer? {\n        val head = head\n        if (headEndExclusive - headPosition >= minSize) return head\n        return prepareReadLoop(minSize, head)\n    }\n\n    @PublishedApi\n    internal final fun prepareRead(minSize: Int, head: ChunkBuffer): ChunkBuffer? {\n        if (headEndExclusive - headPosition >= minSize) return head\n        return prepareReadLoop(minSize, head)\n    }\n\n    private tailrec fun prepareReadLoop(minSize: Int, head: ChunkBuffer): ChunkBuffer? {\n        val headSize = headRemaining\n        if (headSize >= minSize) return head\n\n        val next = head.next ?: doFill() ?: return null\n\n        if (headSize == 0) {\n            if (head !== ChunkBuffer.Empty) {\n                releaseHead(head)\n            }\n\n            return prepareReadLoop(minSize, next)\n        } else {\n            val desiredExtraBytes = minSize - headSize\n            val copied = head.writeBufferAppend(next, desiredExtraBytes)\n            headEndExclusive = head.writePosition\n            tailRemaining -= copied\n            if (!next.canRead()) {\n                head.next = null\n                head.next = next.cleanNext()\n                next.release(pool)\n            } else {\n                next.reserveStartGap(copied)\n            }\n        }\n\n        if (head.readRemaining >= minSize) return head\n        if (minSize > Buffer.ReservedSize) minSizeIsTooBig(minSize)\n\n        return prepareReadLoop(minSize, head)\n    }\n\n    private fun minSizeIsTooBig(minSize: Int): Nothing {\n        throw IllegalStateException(\"minSize of $minSize is too big (should be less than ${Buffer.ReservedSize})\")\n    }\n\n    private fun afterRead(head: ChunkBuffer) {\n        if (head.readRemaining == 0) {\n            releaseHead(head)\n        }\n    }\n\n    internal final fun releaseHead(head: ChunkBuffer): ChunkBuffer {\n        val next = head.cleanNext() ?: ChunkBuffer.Empty\n        this._head = next\n        this.tailRemaining -= next.readRemaining\n        head.release(pool)\n\n        return next\n    }\n\n    companion object\n}\n","package io.ktor.utils.io.core\n\nimport kotlin.contracts.*\n\n@PublishedApi\ninternal inline fun AbstractInput.read(n: Int = 1, block: (Buffer) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val buffer = prepareRead(n) ?: prematureEndOfStream(n)\n    val positionBefore = buffer.readPosition\n    try {\n        block(buffer)\n    } finally {\n        val positionAfter = buffer.readPosition\n        if (positionAfter < positionBefore) {\n            throw IllegalStateException(\"Buffer's position shouldn't be rewinded\")\n        }\n        if (positionAfter == buffer.writePosition) {\n            ensureNext(buffer)\n        } else {\n            headPosition = positionAfter\n        }\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.bits.get\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.jvm.JvmName\n\n/**\n * Usually shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\nexpect interface Input : Closeable {\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    var byteOrder: ByteOrder\n\n    /**\n     * It is `true` when it is known that no more bytes will be available. When it is `false` then this means that\n     * it is not known yet or there are available bytes.\n     * Please note that `false` value doesn't guarantee that there are available bytes so `readByte()` may fail.\n     */\n    val endOfInput: Boolean\n\n    /**\n     * Read the next upcoming byte\n     * @throws EOFException if no more bytes available.\n     */\n    fun readByte(): Byte\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    fun tryPeek(): Int\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source reading that may lead to blocking I/O.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [endOfInput].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long = 0,\n        min: Long = 1,\n        max: Long = Long.MAX_VALUE\n    ): Long\n\n    /**\n     * Discard at most [n] bytes\n     */\n    fun discard(n: Long): Long\n\n    /**\n     * Close input including the underlying source. All pending bytes will be discarded.\n     * It is not recommended to invoke it with read operations in-progress concurrently.\n     */\n    override fun close()\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * The underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available.\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readShort(): Short {\n        return readShort()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readInt(): Int {\n        return readInt()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readLong(): Long {\n        return readLong()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFloat(): Float {\n        return readFloat()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readDouble(): Double {\n        return readDouble()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: IntArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: LongArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: IoBuffer, length: Int) {\n        readFully(dst, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return readAvailable(dst, length)\n    }\n}\n\n/**\n * Discard all remaining bytes.\n * @return number of bytes were discarded\n */\nfun Input.discard(): Long {\n    return discard(Long.MAX_VALUE)\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes in the input to be discarded.\n */\nfun Input.discardExact(n: Long) {\n    val discarded = discard(n)\n    if (discarded != n) {\n        throw IllegalStateException(\"Only $discarded bytes were discarded of $n requested\")\n    }\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes in the input to be discarded.\n */\nfun Input.discardExact(n: Int) {\n    discardExact(n.toLong())\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return `false`\n * [block] function returns `true` to request more chunks or `false` to stop loop\n *\n * It is not guaranteed that every chunk will have fixed size but it will be never empty.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@DangerousInternalIoApi\ninline fun Input.takeWhile(block: (Buffer) -> Boolean) {\n    var release = true\n    var current = prepareReadFirstHead(1) ?: return\n\n    try {\n        do {\n            if (!block(current)) {\n                break\n            }\n            release = false\n            val next = prepareReadNextHead(current) ?: break\n            current = next\n            release = true\n        } while (true)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return zero\n * [block] function returns number of bytes required to read next primitive and shouldn't require too many bytes at once\n * otherwise it could fail with an exception.\n * It is not guaranteed that every chunk will have fixed size but it will be always at least requested bytes length.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@DangerousInternalIoApi\ninline fun Input.takeWhileSize(initialSize: Int = 1, block: (Buffer) -> Int) {\n    var release = true\n    var current = prepareReadFirstHead(initialSize) ?: return\n    var size = initialSize\n\n    try {\n        do {\n            val before = current.readRemaining\n            val after: Int\n\n            if (before >= size) {\n                try {\n                    size = block(current)\n                } finally {\n                    after = current.readRemaining\n                }\n            } else {\n                after = before\n            }\n\n            release = false\n\n            val next = when {\n                after == 0 -> prepareReadNextHead(current)\n                after < size || current.endGap < Buffer.ReservedSize -> {\n                    completeReadHead(current)\n                    prepareReadFirstHead(size)\n                }\n                else -> current\n            }\n\n            if (next == null) {\n                break\n            }\n\n            current = next\n            release = true\n        } while (size > 0)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n@ExperimentalIoApi\nfun Input.peekCharUtf8(): Char {\n    val rc = tryPeek()\n    if (rc and 0x80 == 0) return rc.toChar()\n    if (rc == -1) throw EOFException(\"Failed to peek a char: end of input\")\n\n    return peekCharUtf8Impl(rc)\n}\n\n/**\n * For every byte from this input invokes [block] function giving it as parameter.\n */\n@ExperimentalIoApi\ninline fun Input.forEach(block: (Byte) -> Unit) {\n    takeWhile { buffer ->\n        buffer.forEach(block)\n        true\n    }\n}\n\nprivate fun Input.peekCharUtf8Impl(first: Int): Char {\n    var rc = '?'\n    var found = false\n\n    takeWhileSize(byteCountUtf8(first)) {\n        it.decodeUTF8 { ch ->\n            found = true\n            rc = ch\n            false\n        }\n    }\n\n    if (!found) {\n        throw MalformedUTF8InputException(\"No UTF-8 character found\")\n    }\n\n    return rc\n}\n\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Input.readAvailable(dst: IoBuffer, size: Int = dst.writeRemaining): Int = readAvailable(dst, size)\n\n@JvmName(\"readAvailable\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Input.readAvailableOld(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\nfun Input.readAvailableOld(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\nfun Input.readAvailableOld(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\nfun Input.readAvailableOld(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\nfun Input.readAvailableOld(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\nfun Input.readAvailableOld(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Input.readFully(dst: IoBuffer, size: Int = dst.writeRemaining): Unit = readFully(dst, size)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\nfun Input.readFullyOld(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\nfun Input.readFullyOld(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\nfun Input.readFullyOld(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\nfun Input.readFullyOld(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\nfun Input.readFullyOld(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\nfun Input.readFullyOld(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n","package io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\n\ninternal inline fun Buffer.decodeASCII(consumer: (Char) -> Boolean): Boolean {\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            val codepoint = memory[index].toInt() and 0xff\n            if (codepoint and 0x80 == 0x80 || !consumer(codepoint.toChar())) {\n                discardExact(index - start)\n                return false\n            }\n        }\n\n        endExclusive - start\n    }\n\n    return true\n}\n\n@DangerousInternalIoApi\nsuspend fun decodeUTF8LineLoopSuspend(\n    out: Appendable,\n    limit: Int,\n    nextChunk: suspend (Int) -> AbstractInput?\n): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    while (!end && size != 0) {\n        val chunk = nextChunk(size) ?: break\n        chunk.takeWhileSize { buffer ->\n            var skip = 0\n            size = buffer.decodeUTF8 { ch ->\n                when (ch) {\n                    '\\r' -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n                        cr = true\n                        true\n                    }\n                    '\\n' -> {\n                        end = true\n                        skip = 1\n                        false\n                    }\n                    else -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n\n                        if (decoded == limit) {\n                            throw BufferLimitExceededException(\"Too many characters in line: limit $limit exceeded\")\n                        }\n                        decoded++\n                        out.append(ch)\n                        true\n                    }\n                }\n            }\n\n            if (skip > 0) {\n                buffer.discardExact(skip)\n            }\n\n            size = if (end) 0 else size.coerceAtLeast(1)\n\n            size\n        }\n    }\n\n    if (size > 1) prematureEndOfStreamUtf(size)\n    if (cr) {\n        end = true\n    }\n\n    return decoded > 0 || end\n}\n\nprivate fun prematureEndOfStreamUtf(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes to decode UTF-8 char\")\n\n@DangerousInternalIoApi\ninternal fun byteCountUtf8(firstByte: Int): Int {\n    var byteCount = 0\n    var mask = 0x80\n    var value = firstByte\n\n    for (i in 1..6) {\n        if (value and mask != 0) {\n            value = value and mask.inv()\n            mask = mask shr 1\n            byteCount++\n        } else {\n            break\n        }\n    }\n\n    return byteCount\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\ninline fun IoBuffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    return (this as Buffer).decodeUTF8(consumer)\n}\n\n/**\n * Decodes all the bytes to utf8 applying every character on [consumer] until or consumer return `false`.\n * If a consumer returned false then a character will be pushed back (including all surrogates will be pushed back as well)\n * and [decodeUTF8] returns -1\n * @return number of bytes required to decode incomplete utf8 character or 0 if all bytes were processed\n * or -1 if consumer rejected loop\n */\n@DangerousInternalIoApi\ninline fun Buffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    var byteCount = 0\n    var value = 0\n    var lastByteCount = 0\n\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            val v = memory[index].toInt() and 0xff\n            when {\n                v and 0x80 == 0 -> {\n                    if (byteCount != 0) malformedByteCount(byteCount)\n                    if (!consumer(v.toChar())) {\n                        discardExact(index - start)\n                        return -1\n                    }\n                }\n                byteCount == 0 -> {\n                    // first unicode byte\n\n                    var mask = 0x80\n                    value = v\n\n                    for (i in 1..6) { // TODO do we support 6 bytes unicode?\n                        if (value and mask != 0) {\n                            value = value and mask.inv()\n                            mask = mask shr 1\n                            byteCount++\n                        } else {\n                            break\n                        }\n                    }\n\n                    lastByteCount = byteCount\n                    byteCount--\n\n                    if (lastByteCount > endExclusive - index) {\n                        discardExact(index - start)\n                        return lastByteCount\n                    }\n                }\n                else -> {\n                    // trailing unicode byte\n                    value = (value shl 6) or (v and 0x7f)\n                    byteCount--\n\n                    if (byteCount == 0) {\n                        if (isBmpCodePoint(value)) {\n                            if (!consumer(value.toChar())) {\n                                discardExact(index - start - lastByteCount + 1)\n                                return -1\n                            }\n                        } else if (!isValidCodePoint(value)) {\n                            malformedCodePoint(value)\n                        } else {\n                            if (!consumer(highSurrogate(value).toChar()) ||\n                                !consumer(lowSurrogate(value).toChar())\n                            ) {\n                                discardExact(index - start - lastByteCount + 1)\n                                return -1\n                            }\n                        }\n\n                        value = 0\n                    }\n                }\n            }\n        }\n\n        endExclusive - start\n    }\n\n    return 0\n}\n\n@Suppress(\"RedundantModalityModifier\")\ninternal class CharArraySequence(\n    private val array: CharArray,\n    private val offset: Int,\n    final override val length: Int\n) : CharSequence {\n    final override fun get(index: Int): Char {\n        if (index >= length) {\n            indexOutOfBounds(index)\n        }\n        return array[index + offset]\n    }\n\n    final override fun subSequence(startIndex: Int, endIndex: Int): CharSequence {\n        require(startIndex >= 0) { \"startIndex shouldn't be negative: $startIndex\" }\n        require(startIndex <= length) { \"startIndex is too large: $startIndex > $length\" }\n        require(startIndex + endIndex <= length) { \"endIndex is too large: $endIndex > $length\" }\n        require(endIndex >= startIndex) { \"endIndex should be greater or equal to startIndex: $startIndex > $endIndex\" }\n\n        return CharArraySequence(array, offset + startIndex, endIndex - startIndex)\n    }\n\n    private fun indexOutOfBounds(index: Int): Nothing {\n        throw IndexOutOfBoundsException(\"String index out of bounds: $index > $length\")\n    }\n}\n\n@Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\")\ninternal inline class EncodeResult(val value: Int) {\n    constructor(characters: UShort, bytes: UShort) : this(characters.toInt() shl 16 or bytes.toInt())\n\n    inline val characters: UShort get() = value.highShort.toUShort()\n    inline val bytes: UShort get() = value.lowShort.toUShort()\n\n    inline operator fun component1(): UShort = characters\n    inline operator fun component2(): UShort = bytes\n}\n\ninternal fun Memory.encodeUTF8(text: CharSequence, from: Int, to: Int, dstOffset: Int, dstLimit: Int): EncodeResult {\n    // encode single-byte characters\n    val lastCharIndex = minOf(to, from + UShort.MAX_VALUE.toInt())\n    val resultLimit = dstLimit.coerceAtMost(UShort.MAX_VALUE.toInt())\n    var resultPosition = dstOffset\n    var index = from\n\n    do {\n        if (resultPosition >= resultLimit || index >= lastCharIndex) {\n            return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n        }\n\n        val character = text[index++].toInt() and 0xffff\n        if (character and 0xff80 == 0) {\n            storeAt(resultPosition++, character.toByte())\n        } else {\n            break\n        }\n    } while (true)\n\n    index--\n    return encodeUTF8Stage1(text, index, lastCharIndex, from, resultPosition, resultLimit, dstOffset)\n}\n\n/**\n * Encode UTF-8 multibytes characters when we for sure have enough free space\n */\nprivate fun Memory.encodeUTF8Stage1(\n    text: CharSequence,\n    index1: Int,\n    lastCharIndex: Int,\n    from: Int,\n    resultPosition1: Int,\n    resultLimit: Int,\n    dstOffset: Int\n): EncodeResult {\n    var index = index1\n    var resultPosition: Int = resultPosition1\n    val stage1Limit = resultLimit - 3\n\n    do {\n        val freeSpace = stage1Limit - resultPosition\n        if (freeSpace <= 0 || index >= lastCharIndex) {\n            break\n        }\n\n        val character = text[index++]\n        val codepoint = when {\n            character.isHighSurrogate() -> {\n                if (index == lastCharIndex || !text[index].isLowSurrogate()) {\n                    63\n                } else {\n                    codePoint(character, text[index++])\n                }\n            }\n            else -> character.toInt()\n        }\n        val size = putUtf8Char(resultPosition, codepoint)\n\n        resultPosition += size\n    } while (true)\n\n    if (resultPosition == stage1Limit) {\n        return encodeUTF8Stage2(text, index, lastCharIndex, from, resultPosition, resultLimit, dstOffset)\n    }\n\n    return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n}\n\nprivate fun Memory.encodeUTF8Stage2(\n    text: CharSequence,\n    index1: Int,\n    lastCharIndex: Int,\n    from: Int,\n    resultPosition1: Int,\n    resultLimit: Int,\n    dstOffset: Int\n): EncodeResult {\n    var index = index1\n    var resultPosition: Int = resultPosition1\n\n    do {\n        val freeSpace = resultLimit - resultPosition\n        if (freeSpace <= 0 || index >= lastCharIndex) {\n            break\n        }\n\n        val character = text[index++]\n        val codepoint = when {\n            !character.isHighSurrogate() -> character.toInt()\n            else -> {\n                if (index == lastCharIndex || !text[index].isLowSurrogate()) {\n                    63\n                } else {\n                    codePoint(character, text[index++])\n                }\n            }\n        }\n        if (charactersSize(codepoint) > freeSpace) {\n            index--\n            break\n        }\n        val size = putUtf8Char(resultPosition, codepoint)\n        resultPosition += size\n    } while (true)\n\n    return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun charactersSize(v: Int) = when {\n    v in 1..0x7f -> 1\n    v in 0x80..0x7ff -> 2\n    v in 0x800..0xffff -> 3\n    v in 0x10000..0x10ffff -> 4\n    else -> malformedCodePoint(v)\n}\n\n// TODO optimize it, now we are simply do naive encoding here\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Memory.putUtf8Char(offset: Int, v: Int): Int = when {\n    v in 0..0x7f -> {\n        storeAt(offset, v.toByte())\n        1\n    }\n    v in 0x80..0x7ff -> {\n        this[offset] = (0xc0 or ((v shr 6) and 0x1f)).toByte()\n        this[offset + 1] = (0x80 or (v and 0x3f)).toByte()\n        2\n    }\n    v in 0x800..0xffff -> {\n        this[offset] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n        this[offset + 1] = (0x80 or ((v shr 6) and 0x3f)).toByte()\n        this[offset + 2] = (0x80 or (v and 0x3f)).toByte()\n        3\n    }\n    v in 0x10000..0x10ffff -> {\n        this[offset] = (0xf0 or ((v shr 18) and 0x07)).toByte() // 3 bits\n        this[offset + 1] = (0x80 or ((v shr 12) and 0x3f)).toByte() // 6 bits\n        this[offset + 2] = (0x80 or ((v shr 6) and 0x3f)).toByte() // 6 bits\n        this[offset + 3] = (0x80 or (v and 0x3f)).toByte() // 6 bits\n        4\n    }\n    else -> malformedCodePoint(v)\n}\n\n@PublishedApi\ninternal fun malformedByteCount(byteCount: Int): Nothing =\n    throw MalformedUTF8InputException(\"Expected $byteCount more character bytes\")\n\n@PublishedApi\ninternal fun malformedCodePoint(value: Int): Nothing =\n    throw IllegalArgumentException(\"Malformed code-point $value found\")\n\nprivate const val MaxCodePoint = 0x10ffff\nprivate const val MinLowSurrogate = 0xdc00\nprivate const val MinHighSurrogate = 0xd800\nprivate const val MinSupplementary = 0x10000\nprivate const val HighSurrogateMagic = MinHighSurrogate - (MinSupplementary ushr 10)\n\n@PublishedApi\ninternal fun isBmpCodePoint(cp: Int) = cp ushr 16 == 0\n\n@PublishedApi\ninternal fun isValidCodePoint(codePoint: Int) = codePoint <= MaxCodePoint\n\n@PublishedApi\ninternal fun lowSurrogate(cp: Int) = (cp and 0x3ff) + MinLowSurrogate\n\n@PublishedApi\ninternal fun highSurrogate(cp: Int) = (cp ushr 10) + HighSurrogateMagic\n\ninternal fun codePoint(high: Char, low: Char): Int {\n//    check(high.isHighSurrogate())\n//    check(low.isLowSurrogate())\n\n    val highValue = high.toInt() - HighSurrogateMagic\n    val lowValue = low.toInt() - MinLowSurrogate\n\n    return highValue shl 10 or lowValue\n}\n\nclass MalformedUTF8InputException(message: String) : Exception(message)\n","@file:Suppress(\"LocalVariableName\", \"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * The default [Output] implementation.\n * @see flush\n * @see closeDestination\n */\n@ExperimentalIoApi\nabstract class AbstractOutput\ninternal constructor(\n    private val headerSizeHint: Int,\n    protected val pool: ObjectPool<ChunkBuffer>\n) : Appendable, Output {\n    constructor(pool: ObjectPool<ChunkBuffer>) : this(0, pool)\n\n    constructor() : this(ChunkBuffer.Pool)\n\n    /**\n     * An implementation should write [source] to the destination exactly [length] bytes.\n     * It should never capture the [source] instance\n     * longer than this method execution since it may be disposed after return.\n     */\n    protected abstract fun flush(source: Memory, offset: Int, length: Int)\n\n    /**\n     * An implementation should only close the destination.\n     */\n    protected abstract fun closeDestination()\n\n    private var _head: ChunkBuffer? by shared(null)\n    private var _tail: ChunkBuffer? by shared(null)\n\n    internal val head: ChunkBuffer\n        get() = _head ?: ChunkBuffer.Empty\n\n    @PublishedApi\n    @Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.HIDDEN)\n    internal val tail: ChunkBuffer\n        get() {\n            return prepareWriteHead(1)\n        }\n\n    @Deprecated(\"Will be removed. Override flush(buffer) properly.\", level = DeprecationLevel.ERROR)\n    protected var currentTail: ChunkBuffer\n        get() = prepareWriteHead(1)\n        set(newValue) {\n            appendChain(newValue)\n        }\n\n    internal var tailMemory: Memory by shared(Memory.Empty)\n    internal var tailPosition by shared(0)\n    internal var tailEndExclusive by shared(0)\n        private set\n\n    private var tailInitialPosition by shared(0)\n\n    /**\n     * Number of bytes buffered in the chain except the tail chunk\n     */\n    private var chainedSize: Int by shared(0)\n\n    internal inline val tailRemaining: Int get() = tailEndExclusive - tailPosition\n\n    /**\n     * Number of bytes currently buffered (pending).\n     */\n    protected final var _size: Int\n        get() = chainedSize + (tailPosition - tailInitialPosition)\n        @Deprecated(\"There is no need to update/reset this value anymore.\")\n        set(_) {\n        }\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\n        \"This is no longer supported. All operations are big endian by default. Use readXXXLittleEndian \" +\n            \"to read primitives in little endian\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(value) {\n            field = value\n            if (value != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\n                    \"Only BIG_ENDIAN is supported. Use corresponding functions to read/write\" +\n                        \"in the little endian\"\n                )\n            }\n        }\n\n    final override fun flush() {\n        flushChain()\n    }\n\n    private fun flushChain() {\n        val oldTail = stealAll() ?: return\n\n        try {\n            oldTail.forEachChunk { chunk ->\n                flush(chunk.memory, chunk.readPosition, chunk.readRemaining)\n            }\n        } finally {\n            oldTail.releaseAll(pool)\n        }\n    }\n\n    /**\n     * Detach all chunks and cleanup all internal state so builder could be reusable again\n     * @return a chain of buffer views or `null` of it is empty\n     */\n    internal fun stealAll(): ChunkBuffer? {\n        val head = this._head ?: return null\n\n        _tail?.commitWrittenUntilIndex(tailPosition)\n\n        this._head = null\n        this._tail = null\n        tailPosition = 0\n        tailEndExclusive = 0\n        tailInitialPosition = 0\n        chainedSize = 0\n        tailMemory = Memory.Empty\n\n        return head\n    }\n\n    internal fun afterBytesStolen() {\n        val head = head\n        if (head !== ChunkBuffer.Empty) {\n            check(head.next == null)\n            head.resetForWrite()\n            head.reserveStartGap(headerSizeHint)\n            head.reserveEndGap(Buffer.ReservedSize)\n            tailPosition = head.writePosition\n            tailInitialPosition = tailPosition\n            tailEndExclusive = head.limit\n        }\n    }\n\n    internal final fun appendSingleChunk(buffer: ChunkBuffer) {\n        check(buffer.next == null) { \"It should be a single buffer chunk.\" }\n        appendChainImpl(buffer, buffer, 0)\n    }\n\n    internal final fun appendChain(head: ChunkBuffer) {\n        val tail = head.findTail()\n        val chainedSizeDelta = (head.remainingAll() - tail.readRemaining).toIntOrFail(\"total size increase\")\n        appendChainImpl(head, tail, chainedSizeDelta)\n    }\n\n    private fun appendNewChunk(): ChunkBuffer {\n        val new = pool.borrow()\n        new.reserveEndGap(Buffer.ReservedSize)\n\n        appendSingleChunk(new)\n\n        return new\n    }\n\n    private final fun appendChainImpl(head: ChunkBuffer, newTail: ChunkBuffer, chainedSizeDelta: Int) {\n        val _tail = _tail\n        if (_tail == null) {\n            _head = head\n            chainedSize = 0\n        } else {\n            _tail.next = head\n            val tailPosition = tailPosition\n            _tail.commitWrittenUntilIndex(tailPosition)\n            chainedSize += tailPosition - tailInitialPosition\n        }\n\n        this._tail = newTail\n        chainedSize += chainedSizeDelta\n        tailMemory = newTail.memory\n        tailPosition = newTail.writePosition\n        tailInitialPosition = newTail.readPosition\n        tailEndExclusive = newTail.limit\n    }\n\n    final override fun writeByte(v: Byte) {\n        val index = tailPosition\n        if (index < tailEndExclusive) {\n            tailPosition = index + 1\n            tailMemory[index] = v\n            return\n        }\n\n        return writeByteFallback(v)\n    }\n\n    private fun writeByteFallback(v: Byte) {\n        appendNewChunk().writeByte(v)\n        tailPosition++\n    }\n\n    /**\n     * Should flush and close the destination\n     */\n    final override fun close() {\n        try {\n            flush()\n        } finally {\n            closeDestination() // TODO check what should be done here\n        }\n    }\n\n    /**\n     * Append single UTF-8 character\n     */\n    override fun append(c: Char): AbstractOutput {\n        val tailPosition = tailPosition\n        if (tailEndExclusive - tailPosition >= 3) {\n            val size = tailMemory.putUtf8Char(tailPosition, c.toInt())\n            this.tailPosition = tailPosition + size\n            return this\n        }\n\n        appendCharFallback(c)\n        return this\n    }\n\n    private fun appendCharFallback(c: Char) {\n        write(3) { buffer ->\n            val size = buffer.memory.putUtf8Char(buffer.writePosition, c.toInt())\n            buffer.commitWritten(size)\n            size\n        }\n    }\n\n    override fun append(csq: CharSequence?): AbstractOutput {\n        if (csq == null) {\n            append(\"null\", 0, 4)\n        } else {\n            append(csq, 0, csq.length)\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): AbstractOutput {\n        if (csq == null) {\n            return append(\"null\", start, end)\n        }\n\n        writeText(csq, start, end, Charsets.UTF_8)\n\n        return this\n    }\n\n    /**\n     * Writes another packet to the end. Please note that the instance [p] gets consumed so you don't need to release it\n     */\n    fun writePacket(p: ByteReadPacket) {\n        val foreignStolen = p.stealAll()\n        if (foreignStolen == null) {\n            p.release()\n            return\n        }\n\n        val _tail = _tail\n        if (_tail == null) {\n            appendChain(foreignStolen)\n            return\n        }\n\n        writePacketMerging(_tail, foreignStolen, p.pool)\n    }\n\n    /**\n     * Write chunk buffer to current [Output]. Assuming that chunk buffer is from current pool.\n     */\n    internal fun writeChunkBuffer(chunkBuffer: ChunkBuffer) {\n        val _tail = _tail\n        if (_tail == null) {\n            appendChain(chunkBuffer)\n            return\n        }\n\n        writePacketMerging(_tail, chunkBuffer, pool)\n    }\n\n    private fun writePacketMerging(tail: ChunkBuffer, foreignStolen: ChunkBuffer, pool: ObjectPool<ChunkBuffer>) {\n        tail.commitWrittenUntilIndex(tailPosition)\n\n        val lastSize = tail.readRemaining\n        val nextSize = foreignStolen.readRemaining\n\n        // at first we evaluate if it is reasonable to merge chunks\n        val maxCopySize = PACKET_MAX_COPY_SIZE\n        val appendSize = if (nextSize < maxCopySize && nextSize <= (tail.endGap + tail.writeRemaining)) {\n            nextSize\n        } else -1\n\n        val prependSize =\n            if (lastSize < maxCopySize && lastSize <= foreignStolen.startGap && foreignStolen.isExclusivelyOwned()) {\n                lastSize\n            } else -1\n\n        if (appendSize == -1 && prependSize == -1) {\n            // simply enqueue if there is no reason to merge\n            appendChain(foreignStolen)\n        } else if (prependSize == -1 || appendSize <= prependSize) {\n            // do append\n            tail.writeBufferAppend(foreignStolen, tail.writeRemaining + tail.endGap)\n            afterHeadWrite()\n            foreignStolen.cleanNext()?.let { next ->\n                appendChain(next)\n            }\n\n            foreignStolen.release(pool)\n        } else if (appendSize == -1 || prependSize < appendSize) {\n            writePacketSlowPrepend(foreignStolen, tail)\n        } else {\n            throw IllegalStateException(\"prep = $prependSize, app = $appendSize\")\n        }\n    }\n\n    /**\n     * Do prepend current [tail] to the beginning of [foreignStolen].\n     */\n    private fun writePacketSlowPrepend(foreignStolen: ChunkBuffer, tail: ChunkBuffer) {\n        foreignStolen.writeBufferPrepend(tail)\n\n        val _head = _head ?: error(\"head should't be null since it is already handled in the fast-path\")\n        if (_head === tail) {\n            this._head = foreignStolen\n        } else {\n            // we need to fix next reference of the previous chunk before the tail\n            // we have to traverse from the beginning to find it\n            var pre = _head\n            while (true) {\n                val next = pre.next!!\n                if (next === tail) break\n                pre = next\n            }\n\n            pre.next = foreignStolen\n        }\n\n        tail.release(pool)\n\n        this._tail = foreignStolen.findTail()\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    fun writePacket(p: ByteReadPacket, n: Int) {\n        var remaining = n\n\n        while (remaining > 0) {\n            val headRemaining = p.headRemaining\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                appendSingleChunk(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining)\n                }\n                break\n            }\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    fun writePacket(p: ByteReadPacket, n: Long) {\n        var remaining = n\n\n        while (remaining > 0L) {\n            val headRemaining = p.headRemaining.toLong()\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                appendSingleChunk(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining.toInt())\n                }\n                break\n            }\n        }\n    }\n\n    override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        writeText(csq, start, end, Charsets.UTF_8)\n        return this\n    }\n\n    private inline fun appendCharsTemplate(\n        start: Int,\n        end: Int,\n        block: Buffer.(index: Int) -> Int\n    ): Int {\n        var idx = start\n        if (idx >= end) return idx\n        idx = prepareWriteHead(1).block(idx)\n        afterHeadWrite()\n\n        while (idx < end) {\n            idx = appendNewChunk().block(idx)\n            afterHeadWrite()\n        }\n\n        return idx\n    }\n\n    @Deprecated(\"Use writeText instead\", ReplaceWith(\"writeText(s)\"))\n    fun writeStringUtf8(s: String) {\n        writeText(s)\n    }\n\n    @Deprecated(\"Use writeText instead\", ReplaceWith(\"this.writeText(cs)\"))\n    fun writeStringUtf8(cs: CharSequence) {\n        writeText(cs)\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Buffer.putUtf8Char(v: Int) = when {\n        v in 1..0x7f -> {\n            writeByte(v.toByte())\n            1\n        }\n        v > 0x7ff -> {\n            writeExact(3, \"3 bytes character\") { memory, offset ->\n                memory[offset] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n                memory[offset + 1] = (0x80 or ((v shr 6) and 0x3f)).toByte()\n                memory[offset + 2] = (0x80 or (v and 0x3f)).toByte()\n            }\n            3\n        }\n        else -> {\n            writeExact(2, \"2 bytes character\") { memory, offset ->\n                memory[offset] = (0xc0 or ((v shr 6) and 0x1f)).toByte()\n                memory[offset + 1] = (0x80 or (v and 0x3f)).toByte()\n            }\n            2\n        }\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    final fun release() {\n        close()\n    }\n\n    @DangerousInternalIoApi\n    fun prepareWriteHead(n: Int): ChunkBuffer {\n        if (tailRemaining >= n) {\n            _tail?.let {\n                it.commitWrittenUntilIndex(tailPosition)\n                return it\n            }\n        }\n        return appendNewChunk()\n    }\n\n    @DangerousInternalIoApi\n    fun afterHeadWrite() {\n        _tail?.let { tailPosition = it.writePosition }\n    }\n\n    @PublishedApi\n    internal inline fun write(size: Int, block: (Buffer) -> Int): Int {\n        val buffer = prepareWriteHead(size)\n        try {\n            val result = block(buffer)\n            check(result >= 0) { \"The returned value shouldn't be negative\" }\n\n            return result\n        } finally {\n            afterHeadWrite()\n        }\n    }\n\n    @PublishedApi\n    @Deprecated(\"There is no need to do that anymore.\", level = DeprecationLevel.HIDDEN)\n    internal fun addSize(n: Int) {\n        check(n >= 0) { \"It should be non-negative size increment: $n\" }\n        check(n <= tailRemaining) { \"Unable to mark more bytes than available: $n > $tailRemaining\" }\n\n        // For binary compatibility we need to update pointers\n        tailPosition += n\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal open fun last(buffer: IoBuffer) {\n        appendSingleChunk(buffer as ChunkBuffer)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use appendNewChunk instead\",\n        replaceWith = ReplaceWith(\"appendNewChunk()\"),\n        level = DeprecationLevel.HIDDEN)\n    fun appendNewBuffer(): IoBuffer = appendNewChunk() as IoBuffer\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    open fun reset() {\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport kotlin.contracts.*\nimport io.ktor.utils.io.core.internal.require\n\n/**\n * For every byte from this buffer invokes [block] function giving it as parameter.\n */\n@ExperimentalIoApi\ninline fun Buffer.forEach(block: (Byte) -> Unit) {\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            block(memory[index])\n        }\n        endExclusive - start\n    }\n}\n\n/**\n * Read an unsigned byte or fail if no bytes available for reading.\n */\nfun Buffer.readUByte(): UByte = readByte().toUByte()\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readUByte(): UByte = (this as Buffer).readUByte()\n\n/**\n * Write an unsigned byte or fail if not enough space available for writing.\n */\nfun Buffer.writeUByte(value: UByte) {\n    writeByte(value.toByte())\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\nfun IoBuffer.writeUByte(value: UByte) {\n    (this as Buffer).writeUByte(value)\n}\n\n/**\n * Read a short integer or fail if no bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\nfun Buffer.readShort(): Short = readExact(2, \"short integer\") { memory, offset ->\n    memory.loadShortAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readShort(): Short = (this as Buffer).readShort()\n\n/**\n * Read an unsigned short integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\nfun Buffer.readUShort(): UShort = readExact(2, \"short unsigned integer\") { memory, offset ->\n    memory.loadUShortAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readUShort(): UShort = (this as Buffer).readUShort()\n\n\n/**\n * Read an integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\nfun Buffer.readInt(): Int = readExact(4, \"regular integer\") { memory, offset ->\n    memory.loadIntAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readInt(): Int = (this as Buffer).readInt()\n\n\n/**\n * Read an unsigned integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\nfun Buffer.readUInt(): UInt = readExact(4, \"regular unsigned integer\") { memory, offset ->\n    memory.loadUIntAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readUInt(): UInt = (this as Buffer).readUInt()\n\n\n/**\n * Read a long integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\nfun Buffer.readLong(): Long = readExact(8, \"long integer\") { memory, offset ->\n    memory.loadLongAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readLong(): Long = (this as Buffer).readLong()\n\n/**\n * Read an unsigned long integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\nfun Buffer.readULong(): ULong = readExact(8, \"long unsigned integer\") { memory, offset ->\n    memory.loadULongAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readULong(): ULong = (this as Buffer).readULong()\n\n\n/**\n * Read a floating point number or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\nfun Buffer.readFloat(): Float = readExact(4, \"floating point number\") { memory, offset ->\n    memory.loadFloatAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readFloat(): Float = (this as Buffer).readFloat()\n\n\n/**\n * Read a floating point number or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\nfun Buffer.readDouble(): Double = readExact(8, \"long floating point number\") { memory, offset ->\n    memory.loadDoubleAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readDouble(): Double = (this as Buffer).readDouble()\n\n\n/**\n * Write a short integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\nfun Buffer.writeShort(value: Short): Unit = writeExact(2, \"short integer\") { memory, offset ->\n    memory.storeShortAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\ninline fun IoBuffer.writeShort(value: Short): Unit = (this as Buffer).writeShort(value)\n\n/**\n * Write an unsigned short integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\nfun Buffer.writeUShort(value: UShort): Unit = writeExact(2, \"short unsigned integer\") { memory, offset ->\n    memory.storeUShortAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\ninline fun IoBuffer.writeUShort(value: UShort): Unit = (this as Buffer).writeUShort(value)\n\n/**\n * Write an integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\nfun Buffer.writeInt(value: Int): Unit = writeExact(4, \"regular integer\") { memory, offset ->\n    memory.storeIntAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\ninline fun IoBuffer.writeInt(value: Int): Unit = (this as Buffer).writeInt(value)\n\n/**\n * Write an unsigned integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\nfun Buffer.writeUInt(value: UInt): Unit = writeExact(4, \"regular unsigned integer\") { memory, offset ->\n    memory.storeUIntAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\ninline fun IoBuffer.writeUInt(value: UInt): Unit = (this as Buffer).writeUInt(value)\n\n/**\n * Write a long integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\nfun Buffer.writeLong(value: Long): Unit = writeExact(8, \"long integer\") { memory, offset ->\n    memory.storeLongAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\ninline fun IoBuffer.writeLong(value: Long): Unit = (this as Buffer).writeLong(value)\n\n/**\n * Write an unsigned long integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\nfun Buffer.writeULong(value: ULong): Unit = writeExact(8, \"long unsigned integer\") { memory, offset ->\n    memory.storeULongAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\ninline fun IoBuffer.writeULong(value: ULong): Unit = (this as Buffer).writeULong(value)\n\n/**\n * Write a floating point number or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\nfun Buffer.writeFloat(value: Float): Unit = writeExact(4, \"floating point number\") { memory, offset ->\n    memory.storeFloatAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\ninline fun IoBuffer.writeFloat(value: Float): Unit = (this as Buffer).writeFloat(value)\n\n/**\n * Write a floating point number or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\nfun Buffer.writeDouble(value: Double): Unit = writeExact(8, \"long floating point number\") { memory, offset ->\n    memory.storeDoubleAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\ninline fun IoBuffer.writeDouble(value: Double): Unit = (this as Buffer).writeDouble(value)\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n */\nfun Buffer.readFully(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length, \"byte array\") { memory, srcOffset ->\n        memory.loadByteArray(srcOffset, destination, offset, length)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\ninline fun IoBuffer.readFully(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    (this as Buffer).readFully(destination, offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n */\nfun Buffer.readFully(destination: UByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asByteArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] bytes.\n * If less than [length] bytes available then less bytes will be copied and the corresponding number\n * will be returned as result.\n * @return number of bytes copied to the [destination] or `-1` if the buffer is empty\n */\nfun Buffer.readAvailable(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\ninline fun IoBuffer.readAvailable(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return (this as Buffer).readAvailable(destination, offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] bytes.\n * If less than [length] bytes available then less bytes will be copied and the corresponding number\n * will be returned as result.\n * @return number of bytes copied to the [destination] or `-1` if the buffer is empty\n */\nfun Buffer.readAvailable(destination: UByteArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asByteArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified bytes [length].\n */\nfun Buffer.writeFully(source: ByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length, \"byte array\") { memory, dstOffset ->\n        memory.storeByteArray(dstOffset, source, offset, length)\n    }\n}\n\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\ninline fun IoBuffer.writeFully(source: ByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    (this as Buffer).writeFully(source, offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified bytes [length].\n */\nfun Buffer.writeFully(source: UByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asByteArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.readFully(destination: ShortArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 2, \"short integers array\") { memory, srcOffset ->\n        memory.loadShortArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.readFully(destination: UShortArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asShortArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\nfun Buffer.readAvailable(destination: ShortArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 2, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\nfun Buffer.readAvailable(destination: UShortArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asShortArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.writeFully(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 2, \"short integers array\") { memory, dstOffset ->\n        memory.storeShortArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.writeFully(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asShortArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.readFully(destination: IntArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 4, \"integers array\") { memory, srcOffset ->\n        memory.loadIntArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.readFully(destination: UIntArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asIntArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\nfun Buffer.readAvailable(destination: IntArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 4, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\nfun Buffer.readAvailable(destination: UIntArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asIntArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.writeFully(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 4, \"integers array\") { memory, dstOffset ->\n        memory.storeIntArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.writeFully(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asIntArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.readFully(destination: LongArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 8, \"long integers array\") { memory, srcOffset ->\n        memory.loadLongArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.readFully(destination: ULongArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asLongArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\nfun Buffer.readAvailable(destination: LongArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 8, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\nfun Buffer.readAvailable(destination: ULongArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asLongArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.writeFully(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 8, \"long integers array\") { memory, dstOffset ->\n        memory.storeLongArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.writeFully(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asLongArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.readFully(destination: FloatArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 4, \"floating point numbers array\") { memory, srcOffset ->\n        memory.loadFloatArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\nfun Buffer.readAvailable(destination: FloatArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 4, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.writeFully(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 4, \"floating point numbers array\") { memory, dstOffset ->\n        memory.storeFloatArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.readFully(destination: DoubleArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 8, \"floating point numbers array\") { memory, srcOffset ->\n        memory.loadDoubleArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\nfun Buffer.readAvailable(destination: DoubleArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 8, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\nfun Buffer.writeFully(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 8, \"floating point numbers array\") { memory, dstOffset ->\n        memory.storeDoubleArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Read at most [length] bytes from this buffer to the [dst] buffer.\n * @return number of bytes copied\n */\nfun Buffer.readFully(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    require(length >= 0)\n    require(length <= dst.writeRemaining)\n\n    readExact(length, \"buffer content\") { memory, offset ->\n        memory.copyTo(dst.memory, offset, length, dst.writePosition)\n        dst.commitWritten(length)\n    }\n\n    return length\n}\n\n/**\n * Read at most [length] available bytes to the [dst] buffer or `-1` if no bytes available for read.\n * @return number of bytes copied or `-1` if empty\n */\nfun Buffer.readAvailable(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    if (!canRead()) return -1\n\n    val readSize = minOf(dst.writeRemaining, readRemaining, length)\n\n    readExact(readSize, \"buffer content\") { memory, offset ->\n        memory.copyTo(dst.memory, offset, readSize, dst.writePosition)\n        dst.commitWritten(readSize)\n    }\n\n    return readSize\n}\n\n/**\n * Write all readable bytes from [src] to this buffer. Fails if not enough space available to write all bytes.\n */\nfun Buffer.writeFully(src: Buffer) {\n    val length = src.readRemaining\n\n    writeExact(length, \"buffer readable content\") { memory, offset ->\n        src.memory.copyTo(memory, src.readPosition, length, offset)\n        src.discardExact(length)\n    }\n}\n\n/**\n * Write at most [length] readable bytes from [src] to this buffer.\n * Fails if not enough space available to write all bytes.\n */\nfun Buffer.writeFully(src: Buffer, length: Int) {\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(length <= src.readRemaining) {\n        \"length shouldn't be greater than the source read remaining: $length > ${src.readRemaining}\"\n    }\n    require(length <= writeRemaining) {\n        \"length shouldn't be greater than the destination write remaining space: $length > $writeRemaining\"\n    }\n\n    writeExact(length, \"buffer readable content\") { memory, offset ->\n        src.memory.copyTo(memory, src.readPosition, length, offset)\n        src.discardExact(length)\n    }\n}\n\n@PublishedApi\ninternal inline fun <R> Buffer.readExact(size: Int, name: String, block: (memory: Memory, offset: Int) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    var value: R\n\n    read { memory, start, endExclusive ->\n        io.ktor.utils.io.core.internal.require(endExclusive - start >= size) {\n            throw EOFException(\"Not enough bytes to read a $name of size $size.\")\n        }\n        value = block(memory, start)\n        size\n    }\n\n    return value\n}\n\n@PublishedApi\ninternal inline fun Buffer.writeExact(size: Int, name: String, block: (memory: Memory, offset: Int) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    write { memory, start, endExclusive ->\n        val writeRemaining = endExclusive - start\n        if (writeRemaining < size) {\n            throw InsufficientSpaceException(name, size, writeRemaining)\n        }\n        block(memory, start)\n        size\n    }\n}\n","package io.ktor.utils.io.core\n\n/**\n * Append at most [maxSize] bytes from the specified [other] buffer into this using the end gap reservation if required.\n * @return number of bytes copied\n * @throws IllegalArgumentException if not enough space including end gap\n */\ninternal fun Buffer.writeBufferAppend(other: Buffer, maxSize: Int): Int {\n    val size = minOf(other.readRemaining, maxSize)\n\n    if (writeRemaining <= size) {\n        writeBufferAppendUnreserve(size)\n    }\n\n    return write { dst, dstOffset, _ ->\n        other.read { src, srcOffset, _ ->\n            src.copyTo(dst, srcOffset, size, dstOffset)\n            size\n        }\n    }\n}\n\n/**\n * Prepend readable content of the specified [other] buffer to the beginning of this buffer using start gap reservation\n * if required.\n * @return number of bytes copied\n * @throws IllegalArgumentException if not enough space in the beginning to prepend bytes even with start gap\n */\ninternal fun Buffer.writeBufferPrepend(other: Buffer): Int {\n    val size = other.readRemaining\n    val readPosition = readPosition\n\n    if (readPosition < size) {\n        throw IllegalArgumentException(\"Not enough space in the beginning to prepend bytes\")\n    }\n\n    val newReadPosition = readPosition - size\n    other.memory.copyTo(memory, other.readPosition, size, newReadPosition)\n    other.discardExact(size)\n    releaseStartGap(newReadPosition)\n\n    return size\n}\n\nprivate fun Buffer.writeBufferAppendUnreserve(writeSize: Int) {\n    if (writeRemaining + endGap < writeSize) {\n        throw IllegalArgumentException(\"Can't append buffer: not enough free space at the end\")\n    }\n    val newWritePosition = writePosition + writeSize\n    val overrunSize = newWritePosition - limit\n\n    if (overrunSize > 0) {\n        releaseEndGap()\n    }\n}\n","@file:Suppress(\"DeprecatedCallableAddReplaceWith\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.errors.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * Write byte [value] repeated the specified [times].\n */\nfun Buffer.fill(times: Int, value: Byte) {\n    require(times >= 0) { \"times shouldn't be negative: $times\" }\n    require(times <= writeRemaining) { \"times shouldn't be greater than the write remaining space: $times > $writeRemaining\" }\n\n    memory.fill(writePosition, times, value)\n    commitWritten(times)\n}\n\n/**\n * Write unsigned byte [value] repeated the specified [times].\n */\nfun Buffer.fill(times: Int, value: UByte) {\n    fill(times, value.toByte())\n}\n\n/**\n * Write byte [v] value repeated [n] times.\n */\n@Deprecated(\"Use fill with n with type Int\")\nfun Buffer.fill(n: Long, v: Byte) {\n    fill(n.toIntOrFail(\"n\"), v)\n}\n\n/**\n * Push back [n] bytes: only possible if there were at least [n] bytes read before this operation.\n */\n@Deprecated(\"Use rewind instead\", ReplaceWith(\"rewind(n)\"))\nfun Buffer.pushBack(n: Int): Unit = rewind(n)\n\n@Deprecated(\"Use duplicate instead\", ReplaceWith(\"duplicate()\"))\nfun Buffer.makeView(): Buffer = duplicate()\n\n@Deprecated(\"Use duplicate instead\", ReplaceWith(\"duplicate()\"))\nfun ChunkBuffer.makeView(): ChunkBuffer = duplicate()\n\n@Deprecated(\"Does nothing.\")\nfun Buffer.flush() {\n}\n\ninternal fun Buffer.appendChars(csq: CharArray, start: Int, end: Int): Int {\n    return appendChars(CharArraySequence(csq, 0, csq.size), start, end)\n}\n\ninternal fun Buffer.appendChars(csq: CharSequence, start: Int, end: Int): Int {\n    var charactersWritten: Int\n\n    write { dst, dstStart, dstEndExclusive ->\n        val result = dst.encodeUTF8(csq, start, end, dstStart, dstEndExclusive)\n        charactersWritten = result.characters.toInt()\n        result.bytes.toInt()\n    }\n\n    return start + charactersWritten\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\nfun Buffer.append(c: Char): Buffer {\n    write { memory, start, endExclusive ->\n        val size = memory.putUtf8Char(start, c.toInt())\n        when {\n            size > endExclusive - start -> appendFailed(1)\n            else -> size\n        }\n    }\n\n    return this\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\nfun Buffer.append(csq: CharSequence?): Buffer {\n    if (csq == null) {\n        return append(\"null\")\n    }\n\n    return append(csq, 0, csq.length)\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\nfun Buffer.append(csq: CharSequence?, start: Int, end: Int): Buffer = apply {\n    if (csq == null) {\n        return append(\"null\", start, end)\n    }\n\n    if (appendChars(csq, start, end) != end) {\n        appendFailed(end - start)\n    }\n}\n\nprivate fun appendFailed(length: Int): Nothing {\n    throw BufferLimitExceededException(\"Not enough free space available to write $length character(s).\")\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\nfun Buffer.append(csq: CharArray, start: Int, end: Int): Buffer {\n    return append(CharArraySequence(csq, 0, csq.size), start, end)\n}\n\n@Deprecated(\"This is no longer supported. Read from a packet instead.\")\nfun Buffer.readText(decoder: CharsetDecoder, out: Appendable, lastBuffer: Boolean, max: Int = Int.MAX_VALUE): Int {\n    return decoder.decodeBuffer(this, out, lastBuffer, max)\n}\n\n/**\n * releases buffer view and returns it to the [pool] if there are no more usages. Based on simple ref-counting so\n * it is very fragile.\n */\n@Suppress(\"DEPRECATION\")\nfun IoBuffer.release(pool: ObjectPool<IoBuffer>) {\n    // TODO ???\n    @Suppress(\"UNCHECKED_CAST\")\n    (this as ChunkBuffer).release(pool as ObjectPool<ChunkBuffer>)\n}\n\n/**\n * Peek the next unsigned byte or return `-1` if no more bytes available for reading. No bytes will be marked\n * as consumed in any case.\n * @see [Buffer.tryPeekByte]\n */\n@Deprecated(\"Use tryPeekByte instead\", replaceWith = ReplaceWith(\"tryPeekByte()\"))\nfun Buffer.tryPeek(): Int = tryPeekByte()\n\nfun Buffer.readFully(dst: Array<Byte>, offset: Int = 0, length: Int = dst.size - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        for (index in 0 until length) {\n            dst[index + offset] = memory[index + start]\n        }\n\n        length\n    }\n}\n\n@Deprecated(\n    \"This is no longer supported. All operations are big endian by default. Use readXXXLittleEndian \" +\n        \"to read primitives in little endian\",\n    level = DeprecationLevel.ERROR\n)\nvar Buffer.byteOrder: ByteOrder\n    get() = ByteOrder.BIG_ENDIAN\n    set(newOrder) {\n        if (newOrder != ByteOrder.BIG_ENDIAN) throw UnsupportedOperationException(\"Only BIG_ENDIAN is supported\")\n    }\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.ChunkBuffer\nimport io.ktor.utils.io.pool.DefaultPool\nimport io.ktor.utils.io.pool.ObjectPool\nimport kotlin.native.concurrent.ThreadLocal\n\ninternal const val DEFAULT_BUFFER_SIZE: Int = 4096\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance of the specified [size] in bytes.\n * The provided instance shouldn't be captured and used outside of the [block] otherwise an undefined behaviour\n * may occur including crash and/or data corruption.\n */\n@ExperimentalIoApi\ninline fun <R> withBuffer(size: Int, block: Buffer.() -> R): R {\n    return with(Buffer(DefaultAllocator.alloc(size)), block)\n}\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance taken from the specified [pool].\n * Depending on the pool it may be safe or unsafe to capture and use the provided buffer outside of the [block].\n * Usually it is always recommended to NOT capture an instance outside.\n */\n@ExperimentalIoApi\ninline fun <R> withBuffer(pool: ObjectPool<Buffer>, block: Buffer.() -> R): R {\n    val instance = pool.borrow()\n    return try {\n        block(instance)\n    } finally {\n        pool.recycle(instance)\n    }\n}\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance taken from the specified [pool].\n * Depending on the pool it may be safe or unsafe to capture and use the provided buffer outside of the [block].\n * Usually it is always recommended to NOT capture an instance outside.\n * However since [ChunkBuffer] is reference counted, you can create a [Buffer.duplicate] (this is simply a view) and use\n * it outside of the [block] function but it is important to release the duplicate properly once not needed anymore\n * otherwise memory leak may occur on some platforms.\n */\ninternal inline fun <R> withChunkBuffer(pool: ObjectPool<ChunkBuffer>, block: ChunkBuffer.() -> R): R {\n    val instance = pool.borrow()\n    return try {\n        block(instance)\n    } finally {\n        instance.release(pool)\n    }\n}\n\n@ThreadLocal\n@Suppress(\"DEPRECATION\")\ninternal val DefaultChunkedBufferPool: ObjectPool<IoBuffer> = DefaultBufferPool()\n\n@Suppress(\"DEPRECATION\")\ninternal class DefaultBufferPool(\n    private val bufferSize: Int = DEFAULT_BUFFER_SIZE,\n\n    capacity: Int = 1000,\n    private val allocator: Allocator = DefaultAllocator\n) : DefaultPool<IoBuffer>(capacity) {\n    override fun produceInstance(): IoBuffer {\n        return IoBuffer(allocator.alloc(bufferSize), null)\n    }\n\n    override fun disposeInstance(instance: IoBuffer) {\n        allocator.free(instance.memory)\n        super.disposeInstance(instance)\n        instance.unlink()\n    }\n\n    override fun validateInstance(instance: IoBuffer) {\n        super.validateInstance(instance)\n\n        if (instance === IoBuffer.Empty) {\n            error(\"IoBuffer.Empty couldn't be recycled\")\n        }\n\n        check(instance !== IoBuffer.Empty) { \"Empty instance couldn't be recycled\" }\n        check(instance !== Buffer.Empty) { \"Empty instance couldn't be recycled\" }\n        check(instance !== ChunkBuffer.Empty) { \"Empty instance couldn't be recycled\" }\n\n        check(instance.referenceCount == 0) { \"Unable to clear buffer: it is still in use.\" }\n        check(instance.next == null) { \"Recycled instance shouldn't be a part of a chain.\" }\n        check(instance.origin == null) { \"Recycled instance shouldn't be a view or another buffer.\" }\n    }\n\n    override fun clearInstance(instance: IoBuffer): IoBuffer {\n        return super.clearInstance(instance).apply {\n            unpark()\n            reset()\n        }\n    }\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.pool.*\nimport kotlin.Boolean\nimport kotlin.Char\nimport kotlin.CharSequence\nimport kotlin.Deprecated\nimport kotlin.DeprecationLevel\nimport kotlin.Int\nimport kotlin.PublishedApi\nimport kotlin.Suppress\nimport kotlin.check\nimport kotlin.jvm.JvmName\n\n/**\n * A builder that provides ability to build byte packets with no knowledge of it's size.\n * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows\n * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate\n * a new [ByteReadPacket]. Once a byte packet has been built via [build] function call, the builder could be\n * reused again. You also can discard all written bytes via [reset] or [release]. Please note that an instance of\n * builder need to be terminated either via [build] function invocation or via [release] call otherwise it will\n * cause byte buffer leak so that may have performance impact.\n *\n * Byte packet builder is also an [Appendable] so it does append UTF-8 characters to a packet\n *\n * ```\n * buildPacket {\n *     listOf(1,2,3).joinTo(this, separator = \",\")\n * }\n * ```\n */\nclass BytePacketBuilder(private var headerSizeHint: Int = 0, pool: ObjectPool<ChunkBuffer>) :\n    @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderPlatformBase(pool) {\n    init {\n        require(headerSizeHint >= 0) { \"shouldn't be negative: headerSizeHint = $headerSizeHint\" }\n    }\n\n    /**\n     * Number of bytes written to the builder after the creation or the last reset.\n     */\n    val size: Int\n        get() = _size\n\n    /**\n     * If no bytes were written or the builder has been reset.\n     */\n    val isEmpty: Boolean\n        get() = _size == 0\n\n    /**\n     * If at least one byte was written after the creation or the last reset.\n     */\n    val isNotEmpty: Boolean\n        get() = _size > 0\n\n    @PublishedApi\n    internal val _pool: ObjectPool<ChunkBuffer>\n        get() = pool\n\n    /**\n     * Does nothing for memory-backed output\n     */\n    final override fun closeDestination() {\n    }\n\n    /**\n     * Does nothing for memory-backed output\n     */\n    final override fun flush(source: Memory, offset: Int, length: Int) {\n    }\n\n    override fun append(c: Char): BytePacketBuilder {\n        return super.append(c) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?): BytePacketBuilder {\n        return super.append(csq) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): BytePacketBuilder {\n        return super.append(csq, start, end) as BytePacketBuilder\n    }\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    fun appendOld(c: Char): BytePacketBuilderBase = append(c)\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    fun appendOld(csq: CharSequence?): BytePacketBuilderBase = append(csq)\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    fun appendOld(csq: CharSequence?, start: Int, end: Int): BytePacketBuilderBase = append(csq, start, end)\n\n    /**\n     * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n     * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n     * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n     * otherwise an unexpected behaviour may occur.\n     */\n    @Suppress(\"unused\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun <R> preview(block: (tmp: ByteReadPacket) -> R): R {\n        return preview(block)\n    }\n\n    /**\n     * Builds byte packet instance and resets builder's state to be able to build another one packet if needed\n     */\n    fun build(): ByteReadPacket {\n        val size = size\n        val head = stealAll()\n\n        return when (head) {\n            null -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head, size.toLong(), pool)\n        }\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun reset() {\n        release()\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"unused\")\n    internal fun preview(): ByteReadPacket {\n        return preview()\n    }\n\n    override fun toString(): String {\n        return \"BytePacketBuilder($size bytes written)\"\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.contracts.*\n\n/**\n * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n * otherwise an unexpected behaviour may occur.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\ninline fun <R> BytePacketBuilder.preview(block: (tmp: ByteReadPacket) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val packet = preview()\n    return try {\n        block(packet)\n    } finally {\n        packet.release()\n    }\n}\n\n@PublishedApi\ninternal fun BytePacketBuilder.preview(): ByteReadPacket {\n    val head = head\n    return when {\n        head === ChunkBuffer.Empty -> ByteReadPacket.Empty\n        else -> ByteReadPacket(head.copyAll(), _pool)\n    }\n}\n","@file:Suppress(\"RedundantModalityModifier\", \"FunctionName\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * Read-only immutable byte packet. Could be consumed only once however it does support [copy] that doesn't copy every byte\n * but creates a new view instead. Once packet created it should be either completely read (consumed) or released\n * via [release].\n */\nclass ByteReadPacket internal constructor(head: ChunkBuffer, remaining: Long, pool: ObjectPool<ChunkBuffer>) :\n    @Suppress(\"DEPRECATION_ERROR\") ByteReadPacketPlatformBase(head, remaining, pool), Input {\n    constructor(head: ChunkBuffer, pool: ObjectPool<ChunkBuffer>) : this(head, head.remainingAll(), pool)\n\n    @Suppress(\"DEPRECATION\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    constructor(head: IoBuffer, pool: ObjectPool<ChunkBuffer>) : this(head, head.remainingAll(), pool)\n\n    init {\n        markNoMoreChunksAvailable()\n    }\n\n    /**\n     * Returns a copy of the packet. The original packet and the copy could be used concurrently. Both need to be\n     * either completely consumed or released via [release]\n     */\n    final fun copy(): ByteReadPacket = ByteReadPacket(head.copyAll(), remaining, pool)\n\n    final override fun fill() = null\n\n    final override fun fill(destination: Memory, offset: Int, length: Int): Int {\n        return 0\n    }\n\n    final override fun closeSource() {\n    }\n\n    override fun toString(): String {\n        return \"ByteReadPacket($remaining bytes remaining)\"\n    }\n\n    companion object {\n        val Empty: ByteReadPacket = ByteReadPacket(ChunkBuffer.Empty, 0L, ChunkBuffer.EmptyPool)\n\n        @DangerousInternalIoApi\n        val ReservedSize: Int\n            get() = Buffer.ReservedSize\n    }\n}\n\n@Suppress(\"DEPRECATION\")\n@DangerousInternalIoApi\n@Deprecated(\n    \"Will be removed in future releases.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"AbstractInput\", \"io.ktor.utils.io.core.AbstractInput\")\n)\nabstract class ByteReadPacketPlatformBase protected constructor(\n    head: ChunkBuffer,\n    remaining: Long,\n    pool: ObjectPool<ChunkBuffer>\n) : ByteReadPacketBase(head, remaining, pool) {\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    constructor(head: IoBuffer,\n                remaining: Long,\n                pool: ObjectPool<ChunkBuffer>) : this(head as ChunkBuffer, remaining, pool)\n}\n\nexpect fun ByteReadPacket(\n    array: ByteArray, offset: Int = 0, length: Int = array.size,\n    block: (ByteArray) -> Unit\n): ByteReadPacket\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun ByteReadPacket(array: ByteArray, offset: Int = 0, length: Int = array.size): ByteReadPacket {\n    return ByteReadPacket(array, offset, length) {}\n}\n","package io.ktor.utils.io.core\n\nexpect interface Closeable {\n    fun close()\n}\n\ninline fun <C : Closeable, R> C.use(block: (C) -> R): R {\n    var closed = false\n\n    return try {\n        block(this)\n    } catch (first: Throwable) {\n        try {\n            closed = true\n            close()\n        } catch (second: Throwable) {\n            first.addSuppressedInternal(second)\n        }\n\n        throw first\n    } finally {\n        if (!closed) {\n            close()\n        }\n    }\n}\n\n@PublishedApi\ninternal expect fun Throwable.addSuppressedInternal(other: Throwable)\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * Copy all bytes to the [output].\n * Depending on actual input and output implementation it could be zero-copy or copy byte per byte.\n * All regular types such as [ByteReadPacket], [BytePacketBuilder], [AbstractInput] and [AbstractOutput]\n * are always optimized so no bytes will be copied.\n */\nfun Input.copyTo(output: Output): Long {\n    if (this !is AbstractInput || output !is AbstractOutput) {\n        // slow-path\n        return copyToFallback(output)\n    }\n\n    var copied = 0L\n    do {\n        val head = stealAll()\n        if (head == null) {\n            if (prepareRead(1) == null) break\n            continue\n        }\n\n        copied += head.remainingAll()\n        output.appendChain(head)\n    } while (true)\n\n    return copied\n}\n\nprivate fun Input.copyToFallback(output: Output): Long {\n    val buffer = ChunkBuffer.Pool.borrow()\n    var copied = 0L\n\n    try {\n        do {\n            buffer.resetForWrite()\n            val rc = readAvailable(buffer)\n            if (rc == -1) break\n            copied += rc\n            output.writeFully(buffer)\n        } while (true)\n\n        return copied\n    } finally {\n        buffer.release(ChunkBuffer.Pool)\n    }\n}\n","package io.ktor.utils.io.core\n\n/**\n * API marked with this annotation is experimental and could be changed\n */\n@Suppress(\"DEPRECATION\")\n@RequiresOptIn(level = RequiresOptIn.Level.WARNING)\n@Experimental(Experimental.Level.WARNING)\nannotation class ExperimentalIoApi\n","@file:Suppress(\"Duplicates\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\nfun Input.readShort(byteOrder: ByteOrder): Short =\n    readPrimitiveTemplate(byteOrder, { readShort() }, { reverseByteOrder() })\n\nfun Input.readInt(byteOrder: ByteOrder): Int =\n    readPrimitiveTemplate(byteOrder, { readInt() }, { reverseByteOrder() })\n\nfun Input.readLong(byteOrder: ByteOrder): Long =\n    readPrimitiveTemplate(byteOrder, { readLong() }, { reverseByteOrder() })\n\nfun Input.readFloat(byteOrder: ByteOrder): Float =\n    readPrimitiveTemplate(byteOrder, { readFloat() }, { reverseByteOrder() })\n\nfun Input.readDouble(byteOrder: ByteOrder): Double =\n    readPrimitiveTemplate(byteOrder, { readDouble() }, { reverseByteOrder() })\n\nfun Input.readShortLittleEndian(): Short = readPrimitiveTemplate({ readShort() }, { reverseByteOrder() })\n\nfun Input.readIntLittleEndian(): Int = readPrimitiveTemplate({ readInt() }, { reverseByteOrder() })\n\nfun Input.readLongLittleEndian(): Long = readPrimitiveTemplate({ readLong() }, { reverseByteOrder() })\n\nfun Input.readFloatLittleEndian(): Float = readPrimitiveTemplate({ readFloat() }, { reverseByteOrder() })\n\nfun Input.readDoubleLittleEndian(): Double = readPrimitiveTemplate({ readDouble() }, { reverseByteOrder() })\n\nfun Buffer.readShortLittleEndian(): Short = readPrimitiveTemplate({ readShort() }, { reverseByteOrder() })\n\nfun Buffer.readIntLittleEndian(): Int = readPrimitiveTemplate({ readInt() }, { reverseByteOrder() })\n\nfun Buffer.readLongLittleEndian(): Long = readPrimitiveTemplate({ readLong() }, { reverseByteOrder() })\n\nfun Buffer.readFloatLittleEndian(): Float = readPrimitiveTemplate({ readFloat() }, { reverseByteOrder() })\n\nfun Buffer.readDoubleLittleEndian(): Double = readPrimitiveTemplate({ readDouble() }, { reverseByteOrder() })\n\nfun Input.readFullyLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asShortArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asIntArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asLongArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Input.readAvailableLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asShortArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asIntArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asLongArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Buffer.readFullyLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asShortArray(), offset, length)\n}\n\nfun Buffer.readFullyLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Buffer.readFullyLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asIntArray(), offset, length)\n}\n\nfun Buffer.readFullyLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Buffer.readFullyLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asLongArray(), offset, length)\n}\n\nfun Buffer.readFullyLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Buffer.readFullyLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Buffer.readFullyLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\nfun Buffer.readAvailableLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asShortArray(), offset, length)\n}\n\nfun Buffer.readAvailableLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    val lastIndex = offset + result - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n    return result\n}\n\nfun Buffer.readAvailableLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asIntArray(), offset, length)\n}\n\nfun Buffer.readAvailableLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    val lastIndex = offset + result - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n    return result\n}\n\nfun Buffer.readAvailableLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asLongArray(), offset, length)\n}\n\nfun Buffer.readAvailableLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Buffer.readAvailableLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Buffer.readAvailableLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nprivate inline fun <T : Any> readPrimitiveTemplate(read: () -> T, reverse: T.() -> T): T {\n    return read().reverse()\n}\n\nprivate inline fun <T : Any> readPrimitiveTemplate(\n    byteOrder: ByteOrder,\n    read: () -> T,\n    reverse: T.() -> T\n): T {\n    return when (byteOrder) {\n        ByteOrder.BIG_ENDIAN -> read()\n        else -> read().reverse()\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.errors.checkPeekTo\n\n/**\n * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n * it simply return number of available bytes with no exception so the returned value need\n * to be checked.\n * It is safe to specify `max > destination.writeRemaining` but\n * `min` shouldn't be bigger than the [destination] free space.\n * This function could trigger the underlying source reading that may lead to blocking I/O.\n * It is safe to specify too big [offset] so in this case this function will always return `0`.\n * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n * When `0` is returned with `offset = 0` then it makes sense to check [Input.endOfInput].\n *\n * @param destination to write bytes\n * @param offset to skip input\n * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n * @return number of bytes copied to the [destination] possibly `0`\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Input.peekTo(destination: IoBuffer, offset: Int = 0, min: Int = 1, max: Int = Int.MAX_VALUE): Int {\n    return peekTo(destination as Buffer, offset, min, max)\n}\n\n/**\n * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n * it simply return number of available bytes with no exception so the returned value need\n * to be checked.\n * It is safe to specify `max > destination.writeRemaining` but\n * `min` shouldn't be bigger than the [destination] free space.\n * This function could trigger the underlying source reading that may lead to blocking I/O.\n * It is safe to specify too big [offset] so in this case this function will always return `0`.\n * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n * When `0` is returned with `offset = 0` then it makes sense to check [Input.endOfInput].\n *\n * @param destination to write bytes\n * @param offset to skip input\n * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n * @return number of bytes copied to the [destination] possibly `0`\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"Use peekTo(Memory) instead.\")\nfun Input.peekTo(destination: Buffer, offset: Int = 0, min: Int = 1, max: Int = Int.MAX_VALUE): Int {\n    checkPeekTo(destination, offset, min, max)\n\n    val copied = peekTo(\n        destination.memory,\n        destination.writePosition.toLong(),\n        offset.toLong(),\n        min.toLong(),\n        max.coerceAtMost(destination.writeRemaining).toLong()\n    ).toInt()\n\n    destination.commitWritten(copied)\n    return copied\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readShort(): Short {\n    return readPrimitive(2, { memory, index -> memory.loadShortAt(index) }, { readShortFallback() })\n}\n\nprivate fun Input.readShortFallback(): Short {\n    return readPrimitiveFallback(2) { it.readShort() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readInt(): Int {\n    return readPrimitive(4, { memory, index -> memory.loadIntAt(index) }, { readIntFallback() })\n}\n\nprivate fun Input.readIntFallback(): Int {\n    return readPrimitiveFallback(4) { it.readInt() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readLong(): Long {\n    return readPrimitive(8, { memory, index -> memory.loadLongAt(index) }, { readLongFallback() })\n}\n\nprivate fun Input.readLongFallback(): Long {\n    return readPrimitiveFallback(8) { it.readLong() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFloat(): Float {\n    return readPrimitive(4, { memory, index -> memory.loadFloatAt(index) }, { readFloatFallback() })\n}\n\nfun Input.readFloatFallback(): Float {\n    return readPrimitiveFallback(4) { it.readFloat() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readDouble(): Double {\n    return readPrimitive(8, { memory, index -> memory.loadDoubleAt(index) }, { readDoubleFallback() })\n}\n\nfun Input.readDoubleFallback(): Double {\n    return readPrimitiveFallback(8) { it.readDouble() }\n}\n\nprivate inline fun <R> Input.readPrimitive(size: Int, main: (Memory, Int) -> R, fallback: () -> R): R {\n    if (this is AbstractInput && headRemaining > size) {\n        val index = headPosition\n        headPosition = index + size\n        return main(headMemory, index)\n    }\n\n    return fallback()\n}\n\nprivate inline fun <R> Input.readPrimitiveFallback(size: Int, read: (Buffer) -> R): R {\n    val head = prepareReadFirstHead(size) ?: prematureEndOfStream(size)\n    val value = read(head)\n    completeReadHead(head)\n    return value\n}\n","@file:Suppress(\"MoveLambdaOutsideParentheses\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\n\nfun Output.writeShort(value: Short, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeShort(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeInt(value: Int, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeInt(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeLong(value: Long, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeLong(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFloat(value: Float, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeFloat(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeDouble(value: Double, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeDouble(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeShortLittleEndian(value: Short) {\n    writePrimitiveTemplate(value, { writeShort(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeIntLittleEndian(value: Int) {\n    writePrimitiveTemplate(value, { writeInt(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeLongLittleEndian(value: Long) {\n    writePrimitiveTemplate(value, { writeLong(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFloatLittleEndian(value: Float) {\n    writePrimitiveTemplate(value, { writeFloat(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeDoubleLittleEndian(value: Double) {\n    writePrimitiveTemplate(value, { writeDouble(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFullyLittleEndian(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asShortArray(), offset, length)\n}\n\nfun Buffer.writeShortLittleEndian(value: Short) {\n    writePrimitiveTemplate(value, { writeShort(it) }, { reverseByteOrder() })\n}\n\nfun Buffer.writeIntLittleEndian(value: Int) {\n    writePrimitiveTemplate(value, { writeInt(it) }, { reverseByteOrder() })\n}\n\nfun Buffer.writeLongLittleEndian(value: Long) {\n    writePrimitiveTemplate(value, { writeLong(it) }, { reverseByteOrder() })\n}\n\nfun Buffer.writeFloatLittleEndian(value: Float) {\n    writePrimitiveTemplate(value, { writeFloat(it) }, { reverseByteOrder() })\n}\n\nfun Buffer.writeDoubleLittleEndian(value: Double) {\n    writePrimitiveTemplate(value, { writeDouble(it) }, { reverseByteOrder() })\n}\n\nfun Buffer.writeFullyLittleEndian(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asShortArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        2,\n        { writeShort(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asIntArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeInt(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asLongArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeLong(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeFloat(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeDouble(source[it].reverseByteOrder()) })\n}\n\nfun Buffer.writeFullyLittleEndian(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        2,\n        { writeShort(source[it].reverseByteOrder()) })\n}\n\nfun Buffer.writeFullyLittleEndian(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asIntArray(), offset, length)\n}\n\nfun Buffer.writeFullyLittleEndian(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeInt(source[it].reverseByteOrder()) })\n}\n\nfun Buffer.writeFullyLittleEndian(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asLongArray(), offset, length)\n}\n\nfun Buffer.writeFullyLittleEndian(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeLong(source[it].reverseByteOrder()) })\n}\n\nfun Buffer.writeFullyLittleEndian(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeFloat(source[it].reverseByteOrder()) })\n}\n\nfun Buffer.writeFullyLittleEndian(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeDouble(source[it].reverseByteOrder()) })\n}\n\nprivate inline fun <T : Any> writePrimitiveTemplate(value: T, write: (T) -> Unit, reverse: T.() -> T) {\n    write(value.reverse())\n}\n\nprivate inline fun <T : Any> writePrimitiveTemplate(\n    value: T,\n    byteOrder: ByteOrder,\n    write: (T) -> Unit,\n    reverse: T.() -> T\n) {\n    write(\n        when (byteOrder) {\n            ByteOrder.BIG_ENDIAN -> value\n            else -> value.reverse()\n        }\n    )\n}\n\nprivate inline fun Output.writeArrayTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    writeComponent: Buffer.(Int) -> Unit\n) {\n    val untilIndex = offset + length\n    var start = offset\n    writeWhileSize(componentSize) { buffer ->\n        val size = minOf(buffer.writeRemaining / componentSize, untilIndex - start)\n        val lastIndex = start + size - 1\n        for (index in start..lastIndex) {\n            writeComponent(buffer, index)\n        }\n        start += size\n        when {\n            start < untilIndex -> componentSize\n            else -> 0\n        }\n    }\n}\n\nprivate inline fun Buffer.writeArrayTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    writeComponent: Buffer.(Int) -> Unit\n) {\n    val untilIndex = offset + length\n    var start = offset\n    val buffer = this\n\n    val size = minOf(buffer.writeRemaining / componentSize, untilIndex - start)\n    val lastIndex = start + size - 1\n    for (index in start..lastIndex) {\n        writeComponent(buffer, index)\n    }\n    start += size\n}\n","@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\nfun Output.writeShort(value: Short) {\n    if (!writePrimitiveTemplate(2) { memory, index -> memory.storeShortAt(index, value) }) {\n        writeShortFallback(value)\n    }\n}\n\nprivate fun Output.writeShortFallback(value: Short) {\n    if (!writePrimitiveFallbackTemplate(2) { it.writeShort(value) }) {\n        writeByte(value.highByte)\n        writeByte(value.lowByte)\n    }\n}\n\nfun Output.writeInt(value: Int) {\n    if (!writePrimitiveTemplate(4) { memory, index -> memory.storeIntAt(index, value) }) {\n        writeIntFallback(value)\n    }\n}\n\nprivate fun Output.writeIntFallback(value: Int) {\n    if (!writePrimitiveFallbackTemplate(4) { it.writeInt(value) }) {\n        writeIntByteByByte(value)\n    }\n}\n\nprivate fun Output.writeIntByteByByte(value: Int) {\n    value.highShort.let {\n        writeByte(it.highByte)\n        writeByte(it.lowByte)\n    }\n    value.lowShort.let {\n        writeByte(it.highByte)\n        writeByte(it.lowByte)\n    }\n}\n\nfun Output.writeLong(value: Long) {\n    if (!writePrimitiveTemplate(8) { memory, index -> memory.storeLongAt(index, value) }) {\n        writeLongFallback(value)\n    }\n}\n\nprivate fun Output.writeLongFallback(value: Long) {\n    if (!writePrimitiveFallbackTemplate(8) { it.writeLong(value) }) {\n        writeIntByteByByte(value.highInt)\n        writeIntByteByByte(value.lowInt)\n    }\n}\n\nfun Output.writeFloat(value: Float) {\n    if (!writePrimitiveTemplate(4) { memory, index -> memory.storeFloatAt(index, value) }) {\n        writeIntFallback(value.toRawBits())\n    }\n}\n\nfun Output.writeDouble(value: Double) {\n    if (!writePrimitiveTemplate(8) { memory, index -> memory.storeDoubleAt(index, value) }) {\n        writeLongFallback(value.toRawBits())\n    }\n}\n\nprivate inline fun Output.writePrimitiveTemplate(\n    componentSize: Int,\n    block: (Memory, index: Int) -> Unit\n): Boolean {\n    if (this is AbstractOutput) {\n        val index = tailPosition\n        if (tailEndExclusive - index > componentSize) {\n            tailPosition = index + componentSize\n            block(tailMemory, index)\n            return true\n        }\n    }\n\n    return false\n}\n\nprivate inline fun Output.writePrimitiveFallbackTemplate(\n    componentSize: Int,\n    writeOperation: (Buffer) -> Unit\n): Boolean {\n    if (this is AbstractOutput) {\n        val tail = prepareWriteHead(componentSize)\n        writeOperation(tail)\n        afterHeadWrite()\n        return true\n    }\n\n    return false\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.get\nimport io.ktor.utils.io.bits.loadByteArray\n\n/**\n * Discards bytes until [delimiter] occurred\n * @return number of bytes discarded\n */\nfun Input.discardUntilDelimiter(delimiter: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimiterImpl(delimiter)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Discards bytes until of of the specified delimiters [delimiter1] or [delimiter2] occurred\n * @return number of bytes discarded\n */\nfun Input.discardUntilDelimiters(delimiter1: Byte, delimiter2: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimitersImpl(delimiter1, delimiter2)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\nfun Input.readUntilDelimiter(delimiter: Byte, dst: ByteArray, offset: Int = 0, length: Int = dst.size): Int {\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        dstRemaining > 0 && !chunk.canRead()\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\nfun Input.readUntilDelimiters(delimiter1: Byte, delimiter2: Byte,\n                              dst: ByteArray, offset: Int = 0, length: Int = dst.size): Int {\n    if (delimiter1 == delimiter2) return readUntilDelimiter(delimiter1, dst, offset, length)\n\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile {  chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        !chunk.canRead() && dstRemaining > 0\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] output until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\nfun Input.readUntilDelimiter(delimiter: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\n/**\n * Copies to [dst] output until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\nfun Input.readUntilDelimiters(delimiter1: Byte, delimiter2: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\ninternal expect fun Buffer.discardUntilDelimiterImpl(delimiter: Byte): Int\n\ninternal fun discardUntilDelimiterImplMemory(buffer: Buffer, delimiter: Byte): Int {\n    val start = buffer.readPosition\n    var i = start\n    val limit = buffer.writePosition\n    val memory = buffer.memory\n\n    while (i < limit) {\n        if (memory[i] == delimiter) break\n        i++\n    }\n\n    buffer.discardUntilIndex(i)\n    return i - start\n}\n\ninternal expect fun Buffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int\n\ninternal fun discardUntilDelimitersImplMemory(buffer: Buffer, delimiter1: Byte, delimiter2: Byte): Int {\n    val start = buffer.readPosition\n    var i = start\n    val limit = buffer.writePosition\n    val memory = buffer.memory\n\n    while (i < limit) {\n        val v = memory[i]\n        if (v == delimiter1 || v == delimiter2) break\n        i++\n    }\n\n    buffer.discardUntilIndex(i)\n    return i - start\n}\n\ninternal expect fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n                                                    dst: ByteArray, offset: Int, length: Int): Int\n\ninternal expect fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte, delimiter2: Byte,\n    dst: ByteArray, offset: Int, length: Int): Int\n\ninternal expect fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: Output): Int\n\ninternal expect fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte, delimiter2: Byte,\n    dst: Output): Int\n\ninternal inline fun Buffer.copyUntil(predicate: (Byte) -> Boolean, dst: ByteArray, offset: Int, length: Int): Int {\n    val readPosition = readPosition\n    var end = minOf(writePosition, readPosition + length)\n    val memory = memory\n    for (index in readPosition until end) {\n        if (predicate(memory.loadAt(index))) {\n            end = index\n            break\n        }\n    }\n\n    val copySize = end - readPosition\n    memory.loadByteArray(readPosition, dst, offset, copySize)\n    return copySize\n}\n\ninternal inline fun Buffer.copyUntil(predicate: (Byte) -> Boolean, dst: Output): Int {\n    var index = readPosition\n    val end = writePosition\n    val memory = memory\n    do {\n        if (index == end || predicate(memory.loadAt(index))) {\n            break\n        }\n        index++\n    } while (true)\n\n    val size = index - readPosition\n    dst.writeFully(this, size)\n    return size\n}\n\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUByte(): UByte = readByte().toUByte()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUShort(): UShort = readShort().toUShort()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUInt(): UInt = readInt().toUInt()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readULong(): ULong = readLong().toULong()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asByteArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asShortArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asIntArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asLongArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUByte(v: UByte) {\n    writeByte(v.toByte())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUShort(v: UShort) {\n    writeShort(v.toShort())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUInt(v: UInt) {\n    writeInt(v.toInt())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeULong(v: ULong) {\n    writeLong(v.toLong())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UByteArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asByteArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UShortArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asShortArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UIntArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asIntArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: ULongArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asLongArray(), offset, length)\n}\n","package io.ktor.utils.io.core\n\ninline fun <I : Input, R> I.use(block: (I) -> R): R {\n    return try {\n        block(this)\n    } finally {\n        close()\n    }\n}\n\ninline fun <O : Output, R> O.use(block: (O) -> R): R {\n    return try {\n        block(this)\n    } finally {\n        close()\n    }\n}\n","package io.ktor.utils.io.core.internal\n\nimport kotlinx.atomicfu.AtomicRef\nimport kotlinx.atomicfu.atomic\nimport kotlinx.atomicfu.update\nimport kotlinx.atomicfu.updateAndGet\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.bits.DefaultAllocator\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.pool.*\n\n@DangerousInternalIoApi\nopen class ChunkBuffer internal constructor(memory: Memory, origin: ChunkBuffer?) : Buffer(memory) {\n    init {\n        require(origin !== this) { \"A chunk couldn't be a view of itself.\" }\n    }\n\n    private val nextRef: AtomicRef<ChunkBuffer?> = atomic(null)\n    private val refCount = atomic(1)\n\n    /**\n     * Reference to an origin buffer view this was copied from\n     */\n    var origin: ChunkBuffer? by shared(origin)\n        private set\n\n    /**\n     * Reference to next buffer view. Useful to chain multiple views.\n     * @see appendNext\n     * @see cleanNext\n     */\n    var next: ChunkBuffer? get() = nextRef.value\n        set(newValue) {\n            if (newValue == null) {\n                cleanNext()\n            } else {\n                appendNext(newValue)\n            }\n        }\n\n    val referenceCount: Int get() = refCount.value\n\n    private fun appendNext(chunk: ChunkBuffer) {\n        if (!nextRef.compareAndSet(null, chunk)) {\n            throw IllegalStateException(\"This chunk has already a next chunk.\")\n        }\n    }\n\n    fun cleanNext(): ChunkBuffer? {\n        return nextRef.getAndSet(null)\n    }\n\n    override fun duplicate(): ChunkBuffer = (origin ?: this).let { newOrigin ->\n        newOrigin.acquire()\n        ChunkBuffer(memory, newOrigin).also { copy ->\n            duplicateTo(copy)\n        }\n    }\n\n    open fun release(pool: ObjectPool<ChunkBuffer>) {\n        if (release()) {\n            val origin = origin\n            if (origin != null) {\n                unlink()\n                origin.release(pool)\n            } else {\n                pool.recycle(this)\n            }\n        }\n    }\n\n    internal fun unlink() {\n        if (!refCount.compareAndSet(0, -1)) {\n            throw IllegalStateException(\"Unable to unlink: buffer is in use.\")\n        }\n\n        cleanNext()\n        origin = null\n    }\n\n    /**\n     * Increase ref-count. May fail if already released.\n     */\n    internal fun acquire() {\n        refCount.update { old ->\n            if (old <= 0) throw IllegalStateException(\"Unable to acquire chunk: it is already released.\")\n            old + 1\n        }\n    }\n\n    /**\n     * Invoked by a pool before return the instance to a user.\n     */\n    internal fun unpark() {\n        refCount.update { old ->\n            if (old < 0) {\n                throw IllegalStateException(\"This instance is already disposed and couldn't be borrowed.\")\n            }\n            if (old > 0) {\n                throw IllegalStateException(\"This instance is already in use but somehow appeared in the pool.\")\n            }\n\n            1\n        }\n    }\n\n    /**\n     * Release ref-count.\n     * @return `true` if the last usage was released\n     */\n    internal fun release(): Boolean {\n        return refCount.updateAndGet { old ->\n            if (old <= 0) throw IllegalStateException(\"Unable to release: it is already released.\")\n            old - 1\n        } == 0\n    }\n\n    final override fun reset() {\n        require(origin == null) { \"Unable to reset buffer with origin\" }\n\n        super.reset()\n        @Suppress(\"DEPRECATION\")\n        attachment = null\n        nextRef.value = null\n    }\n\n    companion object {\n        val Pool: ObjectPool<ChunkBuffer> = object : ObjectPool<ChunkBuffer> {\n            override val capacity: Int\n                get() = DefaultChunkedBufferPool.capacity\n\n            override fun borrow(): ChunkBuffer {\n                return DefaultChunkedBufferPool.borrow()\n            }\n\n            @Suppress(\"DEPRECATION\")\n            override fun recycle(instance: ChunkBuffer) {\n                if (instance !is IoBuffer) {\n                    throw IllegalArgumentException(\"Only IoBuffer instances can be recycled.\")\n                }\n\n                DefaultChunkedBufferPool.recycle(instance)\n            }\n\n            override fun dispose() {\n                DefaultChunkedBufferPool.dispose()\n            }\n        }\n\n        @Suppress(\"DEPRECATION\")\n        val Empty: ChunkBuffer get() = IoBuffer.Empty\n\n        /**\n         * A pool that always returns [ChunkBuffer.Empty]\n         */\n        val EmptyPool: ObjectPool<ChunkBuffer> = object : ObjectPool<ChunkBuffer> {\n            override val capacity: Int get() = 1\n\n            override fun borrow() = Empty\n\n            override fun recycle(instance: ChunkBuffer) {\n                require(instance === ChunkBuffer.Empty) { \"Only ChunkBuffer.Empty instance could be recycled.\" }\n            }\n\n            override fun dispose() {\n            }\n        }\n\n        @Suppress(\"DEPRECATION\")\n        internal val NoPool: ObjectPool<ChunkBuffer> = object : NoPoolImpl<ChunkBuffer>() {\n            override fun borrow(): ChunkBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null)\n            }\n\n            override fun recycle(instance: ChunkBuffer) {\n                if (instance !is IoBuffer) {\n                    throw IllegalArgumentException(\"Only IoBuffer instances can be recycled.\")\n                }\n\n                DefaultAllocator.free(instance.memory)\n            }\n        }\n\n        internal val NoPoolManuallyManaged: ObjectPool<ChunkBuffer> = object : NoPoolImpl<ChunkBuffer>() {\n            override fun borrow(): ChunkBuffer {\n                throw UnsupportedOperationException(\"This pool doesn't support borrow\")\n            }\n\n            override fun recycle(instance: ChunkBuffer) {\n                // do nothing: manually managed objects should be disposed manually\n            }\n        }\n    }\n}\n\n\n/**\n * @return `true` if and only if the are no buffer views that share the same actual buffer. This actually does\n * refcount and only work guaranteed if other views created/not created via [Buffer.duplicate] function.\n * One can instantiate multiple buffers with the same buffer and this function will return `true` in spite of\n * the fact that the buffer is actually shared.\n */\ninternal fun ChunkBuffer.isExclusivelyOwned(): Boolean = referenceCount == 1\n",null,"@file:Suppress(\"KDocMissingDocumentation\")\n\npackage io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.core.*\nimport kotlin.jvm.*\nimport kotlin.native.concurrent.*\n\n/**\n * API marked with this annotation is internal and extremely fragile and not intended to be used by library users.\n * Such API could be changed without notice including rename, removal and behaviour change.\n * Also using API marked with this annotation could cause data loss or any other damage.\n */\n@Suppress(\"DEPRECATION\")\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Experimental(level = Experimental.Level.ERROR)\nannotation class DangerousInternalIoApi\n\n@DangerousInternalIoApi\nfun ByteReadPacket.`$unsafeAppend$`(builder: BytePacketBuilder) {\n    val builderHead = builder.stealAll() ?: return\n    val builderSize = builder.size\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return\n    }\n\n    append(builderHead)\n}\n\ninternal fun ByteReadPacket.unsafeAppend(builder: BytePacketBuilder): Int {\n    val builderSize = builder.size\n    val builderHead = builder.stealAll() ?: return 0\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return builderSize\n    }\n\n    append(builderHead)\n    return builderSize\n}\n\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@JvmName(\"prepareReadFirstHead\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Input.prepareReadFirstHeadOld(minSize: Int): IoBuffer? {\n    return prepareReadFirstHead(minSize) as IoBuffer?\n}\n\n@DangerousInternalIoApi\nfun Input.prepareReadFirstHead(minSize: Int): ChunkBuffer? {\n    if (this is AbstractInput) {\n        return prepareReadHead(minSize)\n    }\n    if (this is ChunkBuffer) {\n        return if (canRead()) this else null\n    }\n\n    return prepareReadHeadFallback(minSize)\n}\n\nprivate fun Input.prepareReadHeadFallback(minSize: Int): ChunkBuffer? {\n    if (endOfInput) return null\n\n    val buffer = ChunkBuffer.Pool.borrow()\n    val copied = peekTo(\n        buffer.memory,\n        buffer.writePosition.toLong(),\n        0L,\n        minSize.toLong(),\n        buffer.writeRemaining.toLong()\n    ).toInt()\n    buffer.commitWritten(copied)\n\n    if (copied < minSize) {\n        prematureEndOfStream(minSize)\n    }\n\n    return buffer\n}\n\n@Suppress(\"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Input.completeReadHead(current: IoBuffer) {\n    completeReadHead(current)\n}\n\n@DangerousInternalIoApi\nfun Input.completeReadHead(current: ChunkBuffer) {\n    if (current === this) {\n        return\n    }\n    if (this is AbstractInput) {\n        if (!current.canRead()) {\n            ensureNext(current)\n        } else if (current.endGap < Buffer.ReservedSize) {\n            fixGapAfterRead(current)\n        } else {\n            headPosition = current.readPosition\n        }\n        return\n    }\n\n    completeReadHeadFallback(current)\n}\n\nprivate fun Input.completeReadHeadFallback(current: ChunkBuffer) {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.release(ChunkBuffer.Pool)\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@JvmName(\"prepareReadNextHead\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Input.prepareReadNextHeadOld(current: IoBuffer): IoBuffer? {\n    return prepareReadNextHead(current) as IoBuffer?\n}\n\n@DangerousInternalIoApi\nfun Input.prepareReadNextHead(current: ChunkBuffer): ChunkBuffer? {\n    if (current === this) {\n        return if (canRead()) this else null\n    }\n    if (this is AbstractInput) {\n        return ensureNextHead(current)\n    }\n\n    return prepareNextReadHeadFallback(current)\n}\n\nprivate fun Input.prepareNextReadHeadFallback(current: ChunkBuffer): ChunkBuffer? {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.resetForWrite()\n\n    if (endOfInput || peekTo(current) <= 0) {\n        current.release(ChunkBuffer.Pool)\n        return null\n    }\n\n    return current\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Output.prepareWriteHead(capacity: Int, current: IoBuffer?): IoBuffer {\n    return prepareWriteHead(capacity, current) as IoBuffer\n}\n\n@DangerousInternalIoApi\nfun Output.prepareWriteHead(capacity: Int, current: ChunkBuffer?): ChunkBuffer {\n    if (this is AbstractOutput) {\n        if (current != null) {\n            afterHeadWrite()\n        }\n        return prepareWriteHead(capacity)\n    }\n\n    return prepareWriteHeadFallback(current)\n}\n\nprivate fun Output.prepareWriteHeadFallback(current: ChunkBuffer?): ChunkBuffer {\n    if (current != null) {\n        writeFully(current)\n        current.resetForWrite()\n        return current\n    }\n\n    return ChunkBuffer.Pool.borrow()\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\nfun Output.afterHeadWrite(current: IoBuffer) {\n    return afterHeadWrite(current)\n}\n\n@DangerousInternalIoApi\nfun Output.afterHeadWrite(current: ChunkBuffer) {\n    if (this is AbstractOutput) {\n        return afterHeadWrite()\n    }\n\n    afterWriteHeadFallback(current)\n}\n\n@JvmField\n@SharedImmutable\ninternal val EmptyByteArray = ByteArray(0)\n\nprivate fun Output.afterWriteHeadFallback(current: ChunkBuffer) {\n    writeFully(current)\n    current.release(ChunkBuffer.Pool)\n}\n","package io.ktor.utils.io.errors\n\nimport io.ktor.utils.io.core.*\n\nexpect open class IOException(message: String, cause: Throwable?) : Exception {\n    constructor(message: String)\n}\n\nexpect open class EOFException(message: String) : IOException\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\"Not implemented.\", level = DeprecationLevel.ERROR)\nfun <R> TODO_ERROR(value: R): Nothing = TODO(\"Not implemented. Value is $value\")\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\"Not implemented.\", level = DeprecationLevel.ERROR)\nfun TODO_ERROR(): Nothing = TODO(\"Not implemented.\")\n\ninternal fun checkPeekTo(destination: Buffer, offset: Int, min: Int, max: Int) {\n    io.ktor.utils.io.core.internal.require(offset >= 0) { \"offset shouldn't be negative: $offset.\" }\n    io.ktor.utils.io.core.internal.require(min >= 0) { \"min shouldn't be negative: $min.\" }\n    io.ktor.utils.io.core.internal.require(max >= min) { \"max should't be less than min: max = $max, min = $min.\" }\n    io.ktor.utils.io.core.internal.require(min <= destination.writeRemaining) {\n        \"Not enough free space in the destination buffer \" +\n            \"to write the specified minimum number of bytes: min = $min, free = ${destination.writeRemaining}.\"\n    }\n}\n\n@PublishedApi\ninternal fun incompatibleVersionError(): Nothing = throw Error(\n    \"This API is no longer supported. \" +\n        \"Please downgrade kotlinx-io or recompile your project/dependencies with new kotlinx-io.\"\n)\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.internal\n\nimport io.ktor.utils.io.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\n\n/**\n * Exclusive slot for waiting.\n * Only one waiter allowed.\n *\n * TODO: replace [Job] -> [Continuation] when all coroutines problems are fixed.\n */\ninternal class AwaitingSlot {\n    private val suspension: AtomicRef<CompletableJob?> = atomic(null)\n\n    init {\n        makeShared()\n    }\n\n    /**\n     * Wait for other [sleep] or resume.\n     */\n    suspend fun sleep() {\n        if (trySuspend()) {\n            return\n        }\n\n        resume()\n    }\n\n    /**\n     * Resume waiter.\n     */\n    fun resume() {\n        suspension.getAndSet(null)?.complete()\n    }\n\n    /**\n     * Cancel waiter.\n     */\n    fun cancel(cause: Throwable?) {\n        val continuation = suspension.getAndSet(null) ?: return\n\n        if (cause != null) {\n            continuation.completeExceptionally(cause)\n        } else {\n            continuation.complete()\n        }\n    }\n\n    private suspend fun trySuspend(): Boolean {\n        var suspended = false\n\n        val job = Job()\n        if (suspension.compareAndSet(null, job)) {\n            suspended = true\n            job.join()\n        }\n\n        return suspended\n    }\n\n}\n","package io.ktor.utils.io.internal\n\nimport io.ktor.utils.io.ByteChannelSequentialBase\nimport io.ktor.utils.io.close\nimport io.ktor.utils.io.core.internal.ChunkBuffer\n\ninternal suspend fun ByteChannelSequentialBase.joinToImpl(dst: ByteChannelSequentialBase, closeOnEnd: Boolean) {\n    copyToSequentialImpl(dst, Long.MAX_VALUE)\n    if (closeOnEnd) dst.close()\n}\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\ninternal suspend fun ByteChannelSequentialBase.copyToSequentialImpl(dst: ByteChannelSequentialBase, limit: Long): Long {\n    require(this !== dst)\n\n    var remainingLimit = limit\n\n    while (remainingLimit > 0) {\n        if (!awaitInternalAtLeast1()) {\n            break\n        }\n        val transferred = transferTo(dst, remainingLimit)\n\n        val copied = if (transferred == 0L) {\n            val tail = copyToTail(dst, remainingLimit)\n            if (tail == 0L) {\n                break\n            }\n\n            tail\n        } else {\n            if (dst.availableForWrite == 0) {\n                dst.awaitAtLeastNBytesAvailableForWrite(1)\n            }\n\n            transferred\n        }\n\n        remainingLimit -= copied\n    }\n\n    return limit - remainingLimit\n}\n\nprivate suspend fun ByteChannelSequentialBase.copyToTail(dst: ByteChannelSequentialBase, limit: Long): Long {\n    val lastPiece = ChunkBuffer.Pool.borrow()\n    try {\n        lastPiece.resetForWrite(limit.coerceAtMost(lastPiece.capacity.toLong()).toInt())\n        val rc = readAvailable(lastPiece)\n        if (rc == -1) {\n            lastPiece.release(ChunkBuffer.Pool)\n            return 0\n        }\n\n        dst.writeFully(lastPiece)\n        return rc.toLong()\n    } finally {\n        lastPiece.release(ChunkBuffer.Pool)\n    }\n}\n","package io.ktor.utils.io.pool\n\nimport kotlinx.atomicfu.*\nimport io.ktor.utils.io.core.*\nimport kotlin.jvm.*\n\ninterface ObjectPool<T : Any> : Closeable {\n    /**\n     * Pool capacity\n     */\n    val capacity: Int\n\n    /**\n     * borrow an instance. Pool can recycle an old instance or create a new one\n     */\n    fun borrow(): T\n\n    /**\n     * Recycle an instance. Should be recycled what was borrowed before otherwise could fail\n     */\n    fun recycle(instance: T)\n\n    /**\n     * Dispose the whole pool. None of borrowed objects could be used after the pool gets disposed\n     * otherwise it can result in undefined behaviour\n     */\n    fun dispose()\n\n    /**\n     * Does pool dispose\n     */\n    override fun close() = dispose()\n}\n\n/**\n * A pool implementation of zero capacity that always creates new instances\n */\nabstract class NoPoolImpl<T : Any> : ObjectPool<T> {\n    override val capacity: Int\n        get() = 0\n\n    override fun recycle(instance: T) {\n    }\n\n    override fun dispose() {\n    }\n}\n\n/**\n * A pool that produces at most one instance\n */\nabstract class SingleInstancePool<T : Any> : ObjectPool<T> {\n    private val borrowed = atomic(0)\n    private val disposed = atomic(false)\n\n    @Volatile\n    private var instance: T? = null\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected abstract fun disposeInstance(instance: T)\n\n    final override val capacity: Int get() = 1\n\n    final override fun borrow(): T {\n        borrowed.update {\n            if (it != 0) throw IllegalStateException(\"Instance is already consumed\")\n            1\n        }\n\n        val instance = produceInstance()\n        this.instance = instance\n\n        return instance\n    }\n\n    final override fun recycle(instance: T) {\n        if (this.instance !== instance) {\n            if (this.instance == null && borrowed.value != 0) {\n                throw IllegalStateException(\"Already recycled or an irrelevant instance tried to be recycled\")\n            }\n\n            throw IllegalStateException(\"Unable to recycle irrelevant instance\")\n        }\n\n        this.instance = null\n\n        if (!disposed.compareAndSet(false, true)) {\n            throw IllegalStateException(\"An instance is already disposed\")\n        }\n\n        disposeInstance(instance)\n    }\n\n    final override fun dispose() {\n        if (disposed.compareAndSet(false, true)) {\n            val instance = this.instance ?: return\n            this.instance = null\n\n            disposeInstance(instance)\n        }\n    }\n}\n\n/**\n * Default object pool implementation.\n */\nexpect abstract class DefaultPool<T : Any>(capacity: Int) : ObjectPool<T> {\n    /**\n     * Pool capacity.\n     */\n    final override val capacity: Int\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected open fun disposeInstance(instance: T)\n\n    /**\n     * Clear [instance]'s state before reuse: reset pointers, counters and so on\n     */\n    protected open fun clearInstance(instance: T): T\n\n    /**\n     * Validate [instance] of [T]. Could verify that the object has been borrowed from this pool\n     */\n    protected open fun validateInstance(instance: T)\n\n    final override fun borrow(): T\n\n    final override fun recycle(instance: T)\n\n    final override fun dispose()\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\n@Deprecated(\"Use useInstance instead\", ReplaceWith(\"useInstance(block)\"))\ninline fun <T : Any, R> ObjectPool<T>.useBorrowed(block: (T) -> R): R {\n    return useInstance(block)\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\ninline fun <T : Any, R> ObjectPool<T>.useInstance(block: (T) -> R): R {\n    val instance = borrow()\n    try {\n        return block(instance)\n    } finally {\n        recycle(instance)\n    }\n}\n\n","package io.ktor.utils.io\n\nimport kotlinx.coroutines.*\nimport io.ktor.utils.io.internal.*\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\n/**\n * Creates buffered channel for asynchronous reading and writing of sequences of bytes.\n */\nactual fun ByteChannel(autoFlush: Boolean): ByteChannel {\n    return ByteChannelJS(IoBuffer.Empty, autoFlush)\n}\n\n/**\n * Creates channel for reading from the specified byte array.\n */\nactual fun ByteReadChannel(content: ByteArray, offset: Int, length: Int): ByteReadChannel {\n    if (content.isEmpty()) return ByteReadChannel.Empty\n    val head = IoBuffer.Pool.borrow()\n    var tail = head\n\n    var start = offset\n    val end = start + length\n    while (true) {\n        tail.reserveEndGap(8)\n        val size = minOf(end - start, tail.writeRemaining)\n        (tail as Buffer).writeFully(content, start, size)\n        start += size\n\n        if (start == end) break\n        val current = tail\n        tail = IoBuffer.Pool.borrow()\n        current.next = tail\n    }\n\n    return ByteChannelJS(head, false).apply { close() }\n}\n\n/**\n * Creates channel for reading from the specified [ArrayBufferView]\n */\nfun ByteReadChannel(content: ArrayBufferView): ByteReadChannel {\n    if (content.byteLength == 0) return ByteReadChannel.Empty\n    val head = IoBuffer.Pool.borrow()\n    var tail = head\n\n    var start = 0\n    var remaining = content.byteLength - content.byteOffset\n    while (true) {\n        tail.reserveEndGap(8)\n        val size = minOf(remaining, tail.writeRemaining)\n        tail.writeFully(content, start, size)\n        start += size\n        remaining -= size\n\n        if (remaining == 0) break\n        tail = IoBuffer.Pool.borrow()\n    }\n\n    return ByteChannelJS(head, false).apply { close() }\n}\n\nactual suspend fun ByteReadChannel.joinTo(dst: ByteWriteChannel, closeOnEnd: Boolean) {\n    (this as ByteChannelSequentialBase).joinToImpl((dst as ByteChannelSequentialBase), closeOnEnd)\n}\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\nactual suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel, limit: Long): Long {\n    return (this as ByteChannelSequentialBase).copyToSequentialImpl((dst as ByteChannelSequentialBase), limit)\n}\n\ninternal class ByteChannelJS(initial: IoBuffer, autoFlush: Boolean) : ByteChannelSequentialBase(initial, autoFlush) {\n    private var attachedJob: Job? = null\n\n    @OptIn(InternalCoroutinesApi::class)\n    override fun attachJob(job: Job) {\n        attachedJob?.cancel()\n        attachedJob = job\n        job.invokeOnCompletion(onCancelling = true) { cause ->\n            attachedJob = null\n            if (cause != null) {\n                cancel(cause)\n            }\n        }\n    }\n\n    override suspend fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return if (readable.isEmpty) {\n            readAvailableSuspend(dst, offset, length)\n        } else {\n            closedCause?.let { throw it }\n            readable.readAvailable(dst, offset, length)\n        }\n    }\n\n    private suspend fun readAvailableSuspend(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        if (!await(1)) return -1\n        return readAvailable(dst, offset, length)\n    }\n\n    override suspend fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        if (availableForRead >= length) {\n            closedCause?.let { throw it }\n            readable.readFully(dst, offset, length)\n            return\n        }\n\n        return readFullySuspend(dst, offset, length)\n    }\n\n    private suspend fun readFullySuspend(dst: ArrayBuffer, offset: Int, length: Int) {\n        var start = offset\n        val end = offset + length\n        var remaining = length\n\n        while (start < end) {\n            val rc = readAvailable(dst, start, remaining)\n            if (rc == -1) throw EOFException(\"Premature end of stream: required $remaining more bytes\")\n            start += rc\n            remaining -= rc\n        }\n    }\n\n    override fun toString(): String = \"ByteChannel[$attachedJob, ${hashCode()}]\"\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.max(): Byte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.max(): Short? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.max(): Int? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.max(): Long? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.min(): Byte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.min(): Short? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.min(): Int? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.min(): Long? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.scanReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.scanReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.scanReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.scanReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.scanReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.scanReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.scanReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.scanReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.scanReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.scanReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.scanReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.scanReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.scanReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.scanReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.scanReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.scanReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\n/**\n * Channel for asynchronous reading of sequences of bytes.\n * This is a **single-reader channel**.\n *\n * Operations on this channel cannot be invoked concurrently.\n */\nactual interface ByteReadChannel {\n    /**\n     * Returns number of bytes that can be read without suspension. Read operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for read.\n     */\n    actual val availableForRead: Int\n\n    /**\n     * Returns `true` if the channel is closed and no remaining bytes are available for read.\n     * It implies that [availableForRead] is zero.\n     */\n    actual val isClosedForRead: Boolean\n\n    actual val isClosedForWrite: Boolean\n\n    /**\n     * Byte order that is used for multi-byte read operations\n     * (such as [readShort], [readInt], [readLong], [readFloat], and [readDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    actual var readByteOrder: ByteOrder\n\n    /**\n     * Number of bytes read from the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of long running read operation.\n     */\n    @Deprecated(\"Don't use byte count\")\n    actual val totalBytesRead: Long\n\n    /**\n     * Reads all available bytes to [dst] buffer and returns immediately or suspends if no bytes available\n     * @return number of bytes were read or `-1` if the channel has been closed\n     */\n    actual suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n\n    actual suspend fun readAvailable(dst: IoBuffer): Int\n\n    suspend fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int\n\n    /**\n     * Reads all [length] bytes to [dst] buffer or fails if channel has been closed.\n     * Suspends if not enough bytes available.\n     */\n    actual suspend fun readFully(dst: ByteArray, offset: Int, length: Int)\n\n    actual suspend fun readFully(dst: IoBuffer, n: Int)\n\n    suspend fun readFully(dst: ArrayBuffer, offset: Int, length: Int)\n\n    /**\n     * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n     * and not enough bytes available. Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    actual suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n     * Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    actual suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads a long number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    actual suspend fun readLong(): Long\n\n    /**\n     * Reads an int number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    actual suspend fun readInt(): Int\n\n    /**\n     * Reads a short number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    actual suspend fun readShort(): Short\n\n    /**\n     * Reads a byte (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    actual suspend fun readByte(): Byte\n\n    /**\n     * Reads a boolean value (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    actual suspend fun readBoolean(): Boolean\n\n    /**\n     * Reads double number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    actual suspend fun readDouble(): Double\n\n    /**\n     * Reads float number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    actual suspend fun readFloat(): Float\n\n\n    /**\n     * Starts non-suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * event if there are no bytes available for read yet.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    actual fun readSession(consumer: ReadSession.() -> Unit)\n\n    /**\n     * Starts a suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * even if there are no bytes available for read yet. [consumer] lambda could suspend as much as needed.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    actual suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit)\n\n    /**\n     * Reads a line of UTF-8 characters to the specified [out] buffer up to [limit] characters.\n     * Supports both CR-LF and LF line endings.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return `true` if line has been read (possibly empty) or `false` if channel has been closed\n     * and no characters were read.\n     */\n    actual suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean\n\n    /**\n     * Reads a line of UTF-8 characters up to [limit] characters.\n     * Supports both CR-LF and LF line endings.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return a line string with no line endings or `null` of channel has been closed\n     * and no characters were read.\n     */\n    actual suspend fun readUTF8Line(limit: Int): String?\n\n    /**\n     * Close channel with optional [cause] cancellation. Unlike [ByteWriteChannel.close] that could close channel\n     * normally, cancel does always close with error so any operations on this channel will always fail\n     * and all suspensions will be resumed with exception.\n     *\n     * Please note that if the channel has been provided by [reader] or [writer] then the corresponding owning\n     * coroutine will be cancelled as well\n     *\n     * @see ByteWriteChannel.close\n     */\n    actual fun cancel(cause: Throwable?): Boolean\n\n    /**\n     * Discard up to [max] bytes\n     *\n     * @return number of bytes were discarded\n     */\n    actual suspend fun discard(max: Long): Long\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source suspending reading.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [endOfInput].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    actual suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long\n\n    actual companion object {\n        actual val Empty: ByteReadChannel by lazy {\n            ByteChannelJS(IoBuffer.Empty, false).apply {\n                close(null)\n            }\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","package io.ktor.utils.io\n\nimport kotlin.coroutines.*\n\ninternal actual class Condition actual constructor(val predicate: () -> Boolean) {\n    private var cont: Continuation<Unit>? = null\n\n    actual fun check(): Boolean {\n        return predicate()\n    }\n\n    actual fun signal() {\n        val cont = cont\n        if (cont != null && predicate()) {\n            this.cont = null\n            cont.resume(Unit)\n        }\n    }\n\n    actual suspend fun await(block: () -> Unit) {\n        if (predicate()) return\n\n        return suspendCoroutine { c ->\n            cont = c\n            block()\n        }\n    }\n    actual suspend fun await() {\n        if (predicate()) return\n\n        return suspendCoroutine { c ->\n            cont = c\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\npublic inline class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    val value = value // workaround for inline classes BE bug\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io\n\n/**\n * Print exception stacktrace.\n */\npublic actual fun Throwable.printStack() {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    println(asDynamic().stack)\n}\n","/*\n * Copyright 2014-2020 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.core.internal.*\n\n@DangerousInternalIoApi\npublic actual fun Any.preventFreeze() {\n}\n\n@DangerousInternalIoApi\npublic actual fun Any.makeShared() {\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Reverse number's byte order\n */\nactual fun Short.reverseByteOrder(): Short = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Int.reverseByteOrder(): Int = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Long.reverseByteOrder(): Long = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Float.reverseByteOrder(): Float = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Double.reverseByteOrder(): Double = swap(this)\n\n\nprivate inline fun swap(s: Short): Short = (((s.toInt() and 0xff) shl 8) or ((s.toInt() and 0xffff) ushr 8)).toShort()\n\nprivate inline fun swap(s: Int): Int =\n    (swap((s and 0xffff).toShort()).toInt() shl 16) or (swap((s ushr 16).toShort()).toInt() and 0xffff)\n\nprivate inline fun swap(s: Long): Long =\n    (swap((s and 0xffffffff).toInt()).toLong() shl 32) or (swap((s ushr 32).toInt()).toLong() and 0xffffffff)\n\nprivate inline fun swap(s: Float): Float = Float.fromBits(swap(s.toRawBits()))\n\nprivate inline fun swap(s: Double): Double = Double.fromBits(swap(s.toRawBits()))\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\n\nprivate val isLittleEndianPlatform = ByteOrder.nativeOrder() === ByteOrder.LITTLE_ENDIAN\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadShortArray(\n    offset: Int,\n    destination: ShortArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int16Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        // TODO investigate this implementation vs DataView.getInt16(...)\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadShortArray(\n    offset: Long,\n    destination: ShortArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadShortArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadIntArray(\n    offset: Int,\n    destination: IntArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadIntArray(\n    offset: Long,\n    destination: IntArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadIntArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadLongArray(\n    offset: Int,\n    destination: LongArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count * 2)\n\n    if (isLittleEndianPlatform) {\n        for (index in 0 until count * 2 step 2) {\n            destination[index / 2 + destinationOffset] =\n                (typed[index + 1].reverseByteOrder().toLong() and 0xffffffffL) or\n                    (typed[index].reverseByteOrder().toLong() shl 32)\n        }\n    } else {\n        for (index in 0 until count * 2 step 2) {\n            destination[index / 2 + destinationOffset] = (typed[index].toLong() and 0xffffffffL) or\n                (typed[index + 1].toLong() shl 32)\n        }\n    }\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadLongArray(\n    offset: Long,\n    destination: LongArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadLongArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadFloatArray(\n    offset: Int,\n    destination: FloatArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Float32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadFloatArray(\n    offset: Long,\n    destination: FloatArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadFloatArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadDoubleArray(\n    offset: Int,\n    destination: DoubleArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Float64Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\nactual fun Memory.loadDoubleArray(\n    offset: Long,\n    destination: DoubleArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadDoubleArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies shorts integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeShortArray(\n    offset: Int,\n    source: ShortArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int16Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        // TODO investigate this implementation vs DataView.getInt16(...)\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies shorts integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeShortArray(\n    offset: Long,\n    source: ShortArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeShortArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeIntArray(\n    offset: Int,\n    source: IntArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeIntArray(\n    offset: Long,\n    source: IntArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeIntArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeLongArray(\n    offset: Int,\n    source: LongArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count * 2)\n\n    if (isLittleEndianPlatform) {\n        for (index in 0 until count * 2 step 2) {\n            val sourceIndex = index / 2 + sourceOffset\n            val sourceValue = source[sourceIndex]\n            typed[index] = (sourceValue ushr 32).toInt().reverseByteOrder()\n            typed[index + 1] = (sourceValue and 0xffffffffL).toInt().reverseByteOrder()\n        }\n    } else {\n        for (index in 0 until count * 2 step 2) {\n            val sourceIndex = index / 2 + sourceOffset\n            val sourceValue = source[sourceIndex]\n            typed[index] = (sourceValue ushr 32).toInt()\n            typed[index + 1] = (sourceValue and 0xffffffffL).toInt()\n        }\n    }\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeLongArray(\n    offset: Long,\n    source: LongArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeLongArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeFloatArray(\n    offset: Int,\n    source: FloatArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Float32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeFloatArray(\n    offset: Long,\n    source: FloatArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeFloatArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeDoubleArray(\n    offset: Int,\n    source: DoubleArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Float64Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\nactual fun Memory.storeDoubleArray(\n    offset: Long,\n    source: DoubleArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeDoubleArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.khronos.webgl\n\nimport kotlin.js.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.encryptedmedia.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.mediasource.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\npublic external interface WebGLContextAttributes {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var depth: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var stencil: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var antialias: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultipliedAlpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preserveDrawingBuffer: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preferLowPowerToHighPerformance: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var failIfMajorPerformanceCaveat: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextAttributes(alpha: Boolean? = true, depth: Boolean? = true, stencil: Boolean? = false, antialias: Boolean? = true, premultipliedAlpha: Boolean? = true, preserveDrawingBuffer: Boolean? = false, preferLowPowerToHighPerformance: Boolean? = false, failIfMajorPerformanceCaveat: Boolean? = false): WebGLContextAttributes {\n    val o = js(\"({})\")\n    o[\"alpha\"] = alpha\n    o[\"depth\"] = depth\n    o[\"stencil\"] = stencil\n    o[\"antialias\"] = antialias\n    o[\"premultipliedAlpha\"] = premultipliedAlpha\n    o[\"preserveDrawingBuffer\"] = preserveDrawingBuffer\n    o[\"preferLowPowerToHighPerformance\"] = preferLowPowerToHighPerformance\n    o[\"failIfMajorPerformanceCaveat\"] = failIfMajorPerformanceCaveat\n    return o\n}\n\npublic external abstract class WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLBuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLBuffer) to Kotlin\n */\npublic external abstract class WebGLBuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLFramebuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLFramebuffer) to Kotlin\n */\npublic external abstract class WebGLFramebuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLProgram](https://developer.mozilla.org/en/docs/Web/API/WebGLProgram) to Kotlin\n */\npublic external abstract class WebGLProgram : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLRenderbuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderbuffer) to Kotlin\n */\npublic external abstract class WebGLRenderbuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLShader](https://developer.mozilla.org/en/docs/Web/API/WebGLShader) to Kotlin\n */\npublic external abstract class WebGLShader : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLTexture](https://developer.mozilla.org/en/docs/Web/API/WebGLTexture) to Kotlin\n */\npublic external abstract class WebGLTexture : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLUniformLocation](https://developer.mozilla.org/en/docs/Web/API/WebGLUniformLocation) to Kotlin\n */\npublic external abstract class WebGLUniformLocation\n\n/**\n * Exposes the JavaScript [WebGLActiveInfo](https://developer.mozilla.org/en/docs/Web/API/WebGLActiveInfo) to Kotlin\n */\npublic external abstract class WebGLActiveInfo {\n    open val size: Int\n    open val type: Int\n    open val name: String\n}\n\n/**\n * Exposes the JavaScript [WebGLShaderPrecisionFormat](https://developer.mozilla.org/en/docs/Web/API/WebGLShaderPrecisionFormat) to Kotlin\n */\npublic external abstract class WebGLShaderPrecisionFormat {\n    open val rangeMin: Int\n    open val rangeMax: Int\n    open val precision: Int\n}\n\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface WebGLRenderingContextBase {\n    val canvas: HTMLCanvasElement\n    val drawingBufferWidth: Int\n    val drawingBufferHeight: Int\n    fun getContextAttributes(): WebGLContextAttributes?\n    fun isContextLost(): Boolean\n    fun getSupportedExtensions(): Array<String>?\n    fun getExtension(name: String): dynamic\n    fun activeTexture(texture: Int)\n    fun attachShader(program: WebGLProgram?, shader: WebGLShader?)\n    fun bindAttribLocation(program: WebGLProgram?, index: Int, name: String)\n    fun bindBuffer(target: Int, buffer: WebGLBuffer?)\n    fun bindFramebuffer(target: Int, framebuffer: WebGLFramebuffer?)\n    fun bindRenderbuffer(target: Int, renderbuffer: WebGLRenderbuffer?)\n    fun bindTexture(target: Int, texture: WebGLTexture?)\n    fun blendColor(red: Float, green: Float, blue: Float, alpha: Float)\n    fun blendEquation(mode: Int)\n    fun blendEquationSeparate(modeRGB: Int, modeAlpha: Int)\n    fun blendFunc(sfactor: Int, dfactor: Int)\n    fun blendFuncSeparate(srcRGB: Int, dstRGB: Int, srcAlpha: Int, dstAlpha: Int)\n    fun bufferData(target: Int, size: Int, usage: Int)\n    fun bufferData(target: Int, data: BufferDataSource?, usage: Int)\n    fun bufferSubData(target: Int, offset: Int, data: BufferDataSource?)\n    fun checkFramebufferStatus(target: Int): Int\n    fun clear(mask: Int)\n    fun clearColor(red: Float, green: Float, blue: Float, alpha: Float)\n    fun clearDepth(depth: Float)\n    fun clearStencil(s: Int)\n    fun colorMask(red: Boolean, green: Boolean, blue: Boolean, alpha: Boolean)\n    fun compileShader(shader: WebGLShader?)\n    fun compressedTexImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, data: ArrayBufferView)\n    fun compressedTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, data: ArrayBufferView)\n    fun copyTexImage2D(target: Int, level: Int, internalformat: Int, x: Int, y: Int, width: Int, height: Int, border: Int)\n    fun copyTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, x: Int, y: Int, width: Int, height: Int)\n    fun createBuffer(): WebGLBuffer?\n    fun createFramebuffer(): WebGLFramebuffer?\n    fun createProgram(): WebGLProgram?\n    fun createRenderbuffer(): WebGLRenderbuffer?\n    fun createShader(type: Int): WebGLShader?\n    fun createTexture(): WebGLTexture?\n    fun cullFace(mode: Int)\n    fun deleteBuffer(buffer: WebGLBuffer?)\n    fun deleteFramebuffer(framebuffer: WebGLFramebuffer?)\n    fun deleteProgram(program: WebGLProgram?)\n    fun deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?)\n    fun deleteShader(shader: WebGLShader?)\n    fun deleteTexture(texture: WebGLTexture?)\n    fun depthFunc(func: Int)\n    fun depthMask(flag: Boolean)\n    fun depthRange(zNear: Float, zFar: Float)\n    fun detachShader(program: WebGLProgram?, shader: WebGLShader?)\n    fun disable(cap: Int)\n    fun disableVertexAttribArray(index: Int)\n    fun drawArrays(mode: Int, first: Int, count: Int)\n    fun drawElements(mode: Int, count: Int, type: Int, offset: Int)\n    fun enable(cap: Int)\n    fun enableVertexAttribArray(index: Int)\n    fun finish()\n    fun flush()\n    fun framebufferRenderbuffer(target: Int, attachment: Int, renderbuffertarget: Int, renderbuffer: WebGLRenderbuffer?)\n    fun framebufferTexture2D(target: Int, attachment: Int, textarget: Int, texture: WebGLTexture?, level: Int)\n    fun frontFace(mode: Int)\n    fun generateMipmap(target: Int)\n    fun getActiveAttrib(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getActiveUniform(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getAttachedShaders(program: WebGLProgram?): Array<WebGLShader>?\n    fun getAttribLocation(program: WebGLProgram?, name: String): Int\n    fun getBufferParameter(target: Int, pname: Int): Any?\n    fun getParameter(pname: Int): Any?\n    fun getError(): Int\n    fun getFramebufferAttachmentParameter(target: Int, attachment: Int, pname: Int): Any?\n    fun getProgramParameter(program: WebGLProgram?, pname: Int): Any?\n    fun getProgramInfoLog(program: WebGLProgram?): String?\n    fun getRenderbufferParameter(target: Int, pname: Int): Any?\n    fun getShaderParameter(shader: WebGLShader?, pname: Int): Any?\n    fun getShaderPrecisionFormat(shadertype: Int, precisiontype: Int): WebGLShaderPrecisionFormat?\n    fun getShaderInfoLog(shader: WebGLShader?): String?\n    fun getShaderSource(shader: WebGLShader?): String?\n    fun getTexParameter(target: Int, pname: Int): Any?\n    fun getUniform(program: WebGLProgram?, location: WebGLUniformLocation?): Any?\n    fun getUniformLocation(program: WebGLProgram?, name: String): WebGLUniformLocation?\n    fun getVertexAttrib(index: Int, pname: Int): Any?\n    fun getVertexAttribOffset(index: Int, pname: Int): Int\n    fun hint(target: Int, mode: Int)\n    fun isBuffer(buffer: WebGLBuffer?): Boolean\n    fun isEnabled(cap: Int): Boolean\n    fun isFramebuffer(framebuffer: WebGLFramebuffer?): Boolean\n    fun isProgram(program: WebGLProgram?): Boolean\n    fun isRenderbuffer(renderbuffer: WebGLRenderbuffer?): Boolean\n    fun isShader(shader: WebGLShader?): Boolean\n    fun isTexture(texture: WebGLTexture?): Boolean\n    fun lineWidth(width: Float)\n    fun linkProgram(program: WebGLProgram?)\n    fun pixelStorei(pname: Int, param: Int)\n    fun polygonOffset(factor: Float, units: Float)\n    fun readPixels(x: Int, y: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun renderbufferStorage(target: Int, internalformat: Int, width: Int, height: Int)\n    fun sampleCoverage(value: Float, invert: Boolean)\n    fun scissor(x: Int, y: Int, width: Int, height: Int)\n    fun shaderSource(shader: WebGLShader?, source: String)\n    fun stencilFunc(func: Int, ref: Int, mask: Int)\n    fun stencilFuncSeparate(face: Int, func: Int, ref: Int, mask: Int)\n    fun stencilMask(mask: Int)\n    fun stencilMaskSeparate(face: Int, mask: Int)\n    fun stencilOp(fail: Int, zfail: Int, zpass: Int)\n    fun stencilOpSeparate(face: Int, fail: Int, zfail: Int, zpass: Int)\n    fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun texImage2D(target: Int, level: Int, internalformat: Int, format: Int, type: Int, source: TexImageSource?)\n    fun texParameterf(target: Int, pname: Int, param: Float)\n    fun texParameteri(target: Int, pname: Int, param: Int)\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, format: Int, type: Int, source: TexImageSource?)\n    fun uniform1f(location: WebGLUniformLocation?, x: Float)\n    fun uniform1fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform1fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform1i(location: WebGLUniformLocation?, x: Int)\n    fun uniform1iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform1iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform2f(location: WebGLUniformLocation?, x: Float, y: Float)\n    fun uniform2fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform2fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform2i(location: WebGLUniformLocation?, x: Int, y: Int)\n    fun uniform2iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform2iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform3f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float)\n    fun uniform3fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform3fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform3i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int)\n    fun uniform3iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform3iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform4f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float, w: Float)\n    fun uniform4fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform4fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform4i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int, w: Int)\n    fun uniform4iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform4iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun useProgram(program: WebGLProgram?)\n    fun validateProgram(program: WebGLProgram?)\n    fun vertexAttrib1f(index: Int, x: Float)\n    fun vertexAttrib1fv(index: Int, values: dynamic)\n    fun vertexAttrib2f(index: Int, x: Float, y: Float)\n    fun vertexAttrib2fv(index: Int, values: dynamic)\n    fun vertexAttrib3f(index: Int, x: Float, y: Float, z: Float)\n    fun vertexAttrib3fv(index: Int, values: dynamic)\n    fun vertexAttrib4f(index: Int, x: Float, y: Float, z: Float, w: Float)\n    fun vertexAttrib4fv(index: Int, values: dynamic)\n    fun vertexAttribPointer(index: Int, size: Int, type: Int, normalized: Boolean, stride: Int, offset: Int)\n    fun viewport(x: Int, y: Int, width: Int, height: Int)\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderingContext](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext) to Kotlin\n */\npublic external abstract class WebGLRenderingContext : WebGLRenderingContextBase, RenderingContext {\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLContextEvent](https://developer.mozilla.org/en/docs/Web/API/WebGLContextEvent) to Kotlin\n */\npublic external open class WebGLContextEvent(type: String, eventInit: WebGLContextEventInit = definedExternally) : Event {\n    open val statusMessage: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface WebGLContextEventInit : EventInit {\n    var statusMessage: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextEventInit(statusMessage: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): WebGLContextEventInit {\n    val o = js(\"({})\")\n    o[\"statusMessage\"] = statusMessage\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [ArrayBuffer](https://developer.mozilla.org/en/docs/Web/API/ArrayBuffer) to Kotlin\n */\npublic external open class ArrayBuffer(length: Int) : BufferDataSource {\n    open val byteLength: Int\n    fun slice(begin: Int, end: Int = definedExternally): ArrayBuffer\n\n    companion object {\n        fun isView(value: Any?): Boolean\n    }\n}\n\n/**\n * Exposes the JavaScript [ArrayBufferView](https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView) to Kotlin\n */\npublic external interface ArrayBufferView : BufferDataSource {\n    val buffer: ArrayBuffer\n    val byteOffset: Int\n    val byteLength: Int\n}\n\n/**\n * Exposes the JavaScript [Int8Array](https://developer.mozilla.org/en/docs/Web/API/Int8Array) to Kotlin\n */\npublic external open class Int8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int8Array, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int8Array.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int8Array.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint8Array](https://developer.mozilla.org/en/docs/Web/API/Uint8Array) to Kotlin\n */\npublic external open class Uint8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8Array, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8Array.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8Array.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint8ClampedArray](https://developer.mozilla.org/en/docs/Web/API/Uint8ClampedArray) to Kotlin\n */\npublic external open class Uint8ClampedArray : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8ClampedArray)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8ClampedArray, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint8ClampedArray\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8ClampedArray.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8ClampedArray.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Int16Array](https://developer.mozilla.org/en/docs/Web/API/Int16Array) to Kotlin\n */\npublic external open class Int16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int16Array, offset: Int = definedExternally)\n    fun set(array: Array<Short>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int16Array.get(index: Int): Short = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int16Array.set(index: Int, value: Short) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint16Array](https://developer.mozilla.org/en/docs/Web/API/Uint16Array) to Kotlin\n */\npublic external open class Uint16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint16Array, offset: Int = definedExternally)\n    fun set(array: Array<Short>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint16Array.get(index: Int): Short = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint16Array.set(index: Int, value: Short) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Int32Array](https://developer.mozilla.org/en/docs/Web/API/Int32Array) to Kotlin\n */\npublic external open class Int32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int32Array, offset: Int = definedExternally)\n    fun set(array: Array<Int>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int32Array.get(index: Int): Int = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int32Array.set(index: Int, value: Int) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint32Array](https://developer.mozilla.org/en/docs/Web/API/Uint32Array) to Kotlin\n */\npublic external open class Uint32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint32Array, offset: Int = definedExternally)\n    fun set(array: Array<Int>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint32Array.get(index: Int): Int = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint32Array.set(index: Int, value: Int) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Float32Array](https://developer.mozilla.org/en/docs/Web/API/Float32Array) to Kotlin\n */\npublic external open class Float32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float32Array)\n    constructor(array: Array<Float>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float32Array, offset: Int = definedExternally)\n    fun set(array: Array<Float>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Float32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float32Array.get(index: Int): Float = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float32Array.set(index: Int, value: Float) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Float64Array](https://developer.mozilla.org/en/docs/Web/API/Float64Array) to Kotlin\n */\npublic external open class Float64Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float64Array)\n    constructor(array: Array<Double>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float64Array, offset: Int = definedExternally)\n    fun set(array: Array<Double>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Float64Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float64Array.get(index: Int): Double = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float64Array.set(index: Int, value: Double) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [DataView](https://developer.mozilla.org/en/docs/Web/API/DataView) to Kotlin\n */\npublic external open class DataView(buffer: ArrayBuffer, byteOffset: Int = definedExternally, byteLength: Int = definedExternally) : ArrayBufferView {\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun getInt8(byteOffset: Int): Byte\n    fun getUint8(byteOffset: Int): Byte\n    fun getInt16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getUint16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getInt32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getUint32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getFloat32(byteOffset: Int, littleEndian: Boolean = definedExternally): Float\n    fun getFloat64(byteOffset: Int, littleEndian: Boolean = definedExternally): Double\n    fun setInt8(byteOffset: Int, value: Byte)\n    fun setUint8(byteOffset: Int, value: Byte)\n    fun setInt16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally)\n    fun setUint16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally)\n    fun setInt32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally)\n    fun setUint32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally)\n    fun setFloat32(byteOffset: Int, value: Float, littleEndian: Boolean = definedExternally)\n    fun setFloat64(byteOffset: Int, value: Double, littleEndian: Boolean = definedExternally)\n}\n\npublic external interface BufferDataSource\n\npublic external interface TexImageSource","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.js.*\nimport org.khronos.webgl.*\n\nactual abstract class Charset(internal val _name: String) {\n    actual abstract fun newEncoder(): CharsetEncoder\n    actual abstract fun newDecoder(): CharsetDecoder\n\n    actual companion object {\n        actual fun forName(name: String): Charset {\n            if (name == \"UTF-8\" || name == \"utf-8\" || name == \"UTF8\" || name == \"utf8\") return Charsets.UTF_8\n            if (name == \"ISO-8859-1\" || name == \"iso-8859-1\"\n                || name.replace('_', '-').let { it == \"iso-8859-1\" || it.toLowerCase() == \"iso-8859-1\" }\n                || name == \"latin1\"\n            ) {\n                return Charsets.ISO_8859_1\n            }\n            throw IllegalArgumentException(\"Charset $name is not supported\")\n        }\n\n    }\n}\n\nactual val Charset.name: String get() = _name\n\n// -----------------------\n\nactual abstract class CharsetEncoder(internal val _charset: Charset)\nprivate data class CharsetEncoderImpl(private val charset: Charset) : CharsetEncoder(charset)\nactual val CharsetEncoder.charset: Charset get() = _charset\n\nactual fun CharsetEncoder.encodeToByteArray(input: CharSequence, fromIndex: Int, toIndex: Int): ByteArray =\n    encodeToByteArrayImpl1(input, fromIndex, toIndex)\n\ninternal actual fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    require(fromIndex <= toIndex)\n    if (charset == Charsets.ISO_8859_1) {\n        return encodeISO88591(input, fromIndex, toIndex, dst)\n    }\n\n    require(charset === Charsets.UTF_8) { \"Only UTF-8 encoding is supported in JS\" }\n\n    val encoder = TextEncoderCtor()  // Only UTF-8 is supported so we know that at most 6 bytes per character is used\n    var start = fromIndex\n    var dstRemaining = dst.writeRemaining\n\n    while (start < toIndex && dstRemaining > 0) {\n        val numChars = minOf(toIndex - start, dstRemaining / 6).coerceAtLeast(1)\n        val dropLastChar = input[start + numChars - 1].isHighSurrogate()\n        val endIndexExclusive = when {\n            dropLastChar && numChars == 1 -> start + 2\n            dropLastChar -> start + numChars - 1\n            else -> start + numChars\n        }\n\n        val array1 = encoder.encode(input.substring(start, endIndexExclusive))\n        if (array1.length > dstRemaining) break\n        dst.writeFully(array1)\n        start = endIndexExclusive\n        dstRemaining -= array1.length\n    }\n\n    return start - fromIndex\n}\n\nactual fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output) {\n    require(charset === Charsets.UTF_8)\n    // we only support UTF-8 so as far as input is UTF-8 encoded string then we simply copy bytes\n    dst.writePacket(input)\n}\n\ninternal actual fun CharsetEncoder.encodeComplete(dst: Buffer): Boolean = true\n\n\n// ----------------------------------------------------------------------\n\n\nactual abstract class CharsetDecoder(internal val _charset: Charset)\n\nprivate data class CharsetDecoderImpl(private val charset: Charset) : CharsetDecoder(charset)\n\nactual val CharsetDecoder.charset: Charset get() = _charset\n\ninternal actual fun CharsetDecoder.decodeBuffer(\n    input: Buffer,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int\n): Int {\n    if (max == 0) return 0\n\n    val decoder = TextDecoderFatal(charset.name)\n    val copied: Int\n\n    input.readDirectInt8Array { view ->\n        val result = view.decodeBufferImpl(decoder, max)\n        out.append(result.charactersDecoded)\n        copied = result.bytesConsumed\n\n        result.bytesConsumed\n    }\n\n    return copied\n}\n\nactual fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int {\n    val decoder = TextDecoderFatal(charset.name, true)\n    var charactersCopied = 0\n\n    // use decode stream while we have remaining characters count > buffer size in bytes\n    // it is much faster than using decodeBufferImpl\n    input.takeWhileSize { buffer ->\n        val rem = max - charactersCopied\n        val bufferSize = buffer.readRemaining\n        if (rem < bufferSize) return@takeWhileSize 0\n\n        buffer.readDirectInt8Array { view ->\n            val decodedText = decodeWrap {\n                decoder.decodeStream(view, stream = true)\n            }\n            dst.append(decodedText)\n            charactersCopied += decodedText.length\n            view.byteLength\n        }\n\n        when {\n            charactersCopied == max -> {\n                val tail = try {\n                    decoder.decode()\n                } catch (_: dynamic) {\n                    \"\"\n                }\n\n                if (tail.isNotEmpty()) {\n                    // if we have a trailing byte then we can't handle this chunk via fast-path\n                    // because we don't know how many bytes in the end we need to preserve\n                    buffer.rewind(bufferSize)\n                }\n                0\n            }\n            charactersCopied < max -> MAX_CHARACTERS_SIZE_IN_BYTES\n            else -> 0\n        }\n    }\n\n    if (charactersCopied < max) {\n        var size = 1\n        input.takeWhileSize(1) { buffer ->\n            val rc = buffer.readDirectInt8Array { view ->\n                val result = view.decodeBufferImpl(decoder, max - charactersCopied)\n                dst.append(result.charactersDecoded)\n                charactersCopied += result.charactersDecoded.length\n                result.bytesConsumed\n            }\n            when {\n                rc > 0 -> size = 1\n                size == MAX_CHARACTERS_SIZE_IN_BYTES -> size = 0\n                else -> size++\n            }\n\n            size\n        }\n    }\n\n    return charactersCopied\n}\n\nactual fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String {\n    if (inputLength == 0) return \"\"\n    if (input is AbstractInput && input.headRemaining >= inputLength) {\n        val decoder = TextDecoderFatal(charset._name, true)\n\n        val head = input.head\n        val view = input.headMemory.view\n\n        val text = decodeWrap {\n            val subView: ArrayBufferView = when {\n                head.readPosition == 0 && inputLength == view.byteLength -> view\n                else -> DataView(view.buffer, view.byteOffset + head.readPosition, inputLength)\n            }\n\n            decoder.decode(subView)\n        }\n\n        input.discardExact(inputLength)\n        return text\n    }\n\n    return decodeExactBytesSlow(input, inputLength)\n}\n\n// -----------------------------------------------------------\n\nactual object Charsets {\n    actual val UTF_8: Charset = CharsetImpl(\"UTF-8\")\n    actual val ISO_8859_1: Charset = CharsetImpl(\"ISO-8859-1\")\n}\n\nprivate data class CharsetImpl(val name: String) : Charset(name) {\n    override fun newEncoder(): CharsetEncoder = CharsetEncoderImpl(this)\n    override fun newDecoder(): CharsetDecoder = CharsetDecoderImpl(this)\n}\n\n\nactual open class MalformedInputException actual constructor(message: String) : Throwable(message)\n\nprivate fun CharsetDecoder.decodeExactBytesSlow(input: Input, inputLength: Int): String {\n    val decoder = TextDecoderFatal(charset.name, true)\n    var inputRemaining = inputLength\n    val sb = StringBuilder(inputLength)\n\n    decodeWrap {\n        input.takeWhileSize(6) { buffer ->\n            val chunkSize = buffer.readRemaining\n            val size = minOf(chunkSize, inputRemaining)\n            val text = when {\n                buffer.readPosition == 0 && buffer.memory.view.byteLength == size -> decoder.decodeStream(\n                    buffer.memory.view,\n                    true\n                )\n                else -> decoder.decodeStream(\n                    Int8Array(\n                        buffer.memory.view.buffer,\n                        buffer.memory.view.byteOffset + buffer.readPosition,\n                        size\n                    ), true\n                )\n            }\n            sb.append(text)\n\n            buffer.discardExact(size)\n            inputRemaining -= size\n\n            if (inputRemaining > 0) 6 else 0\n        }\n\n        if (inputRemaining > 0) {\n            input.takeWhile { buffer ->\n                val chunkSize = buffer.readRemaining\n                val size = minOf(chunkSize, inputRemaining)\n                val text = when {\n                    buffer.readPosition == 0 && buffer.memory.view.byteLength == size -> {\n                        decoder.decode(buffer.memory.view)\n                    }\n                    else -> decoder.decodeStream(\n                        Int8Array(\n                            buffer.memory.view.buffer,\n                            buffer.memory.view.byteOffset + buffer.readPosition,\n                            size\n                        ), true\n                    )\n                }\n                sb.append(text)\n                buffer.discardExact(size)\n                inputRemaining -= size\n                true\n            }\n        }\n\n        sb.append(decoder.decode())\n    }\n\n    return sb.toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","@file:Suppress(\"ReplaceRangeToWithUntil\", \"RedundantModalityModifier\", \"DEPRECATION\", \"DEPRECATION_ERROR\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport org.khronos.webgl.*\nimport kotlin.contracts.*\n\n@Suppress(\"DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES\")\n@Deprecated(\"Use Buffer instead.\", replaceWith = ReplaceWith(\"Buffer\", \"io.ktor.utils.io.core.Buffer\"))\nactual class IoBuffer actual constructor(\n    memory: Memory,\n    origin: ChunkBuffer?\n) : Input, Output, ChunkBuffer(memory, origin) {\n    private val content: ArrayBuffer get() = memory.view.buffer\n\n    override val endOfInput: Boolean get() = writePosition == readPosition\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n            \"do readXXX/writeXXX with X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    actual final override var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            if (newOrder != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only big endian is supported\")\n            }\n        }\n\n    final override fun peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n        return (this as Buffer).peekTo(destination, destinationOffset, offset, min, max)\n    }\n\n    final override fun tryPeek(): Int {\n        return tryPeekByte()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        if (length > dst.byteLength) throw IllegalArgumentException(\"Destination buffer overflow: length = $length, buffer capacity ${dst.byteLength}\")\n        require(offset >= 0) { \"offset should be positive\" }\n        require(offset + length <= dst.byteLength) { throw IndexOutOfBoundsException(\"\") }\n\n        (this as Buffer).readFully(dst.buffer, dst.byteOffset + offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(length, readRemaining)\n        (this as Buffer).readFully(dst, offset, size)\n        return size\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: IoBuffer, length: Int) {\n        (this as Buffer).readFully(dst, length)\n    }\n\n    final override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq ?: \"null\", start, end)\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    final override fun append(csq: CharSequence?): Appendable {\n        return if (csq == null) append(\"null\") else append(csq, 0, csq.length)\n    }\n\n    final override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq, start, end)\n\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    override fun append(c: Char): Appendable {\n        (this as Buffer).append(c)\n        return this\n    }\n\n    @Deprecated(\n        \"Use writeFully instead\",\n        ReplaceWith(\"writeFully(array, offset, length)\"),\n        level = DeprecationLevel.ERROR\n    )\n    fun write(array: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(array, offset, length)\n    }\n\n    @Deprecated(\n        \"Use writeFully instead\",\n        ReplaceWith(\"writeFully(array, offset, length)\"),\n        level = DeprecationLevel.ERROR\n    )\n    fun write(src: Int8Array, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readShort(): Short {\n        return (this as Buffer).readShort()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readInt(): Int {\n        return (this as Buffer).readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFloat(): Float {\n        return (this as Buffer).readFloat()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readDouble(): Double {\n        return (this as Buffer).readDouble()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: IntArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: LongArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun peekTo(buffer: IoBuffer): Int {\n        return (this as Input).peekTo(buffer)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readLong(): Long {\n        return (this as Buffer).readLong()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeShort(v: Short) {\n        (this as Buffer).writeShort(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeInt(v: Int) {\n        (this as Buffer).writeInt(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFloat(v: Float) {\n        (this as Buffer).writeFloat(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeDouble(v: Double) {\n        (this as Buffer).writeDouble(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: IoBuffer, length: Int) {\n        (this as Buffer).writeFully(src, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun fill(n: Long, v: Byte) {\n        (this as Buffer).fill(n, v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun writeLong(v: Long) {\n        (this as Buffer).writeLong(v)\n    }\n\n    @Deprecated(\"Use writeFully instead\", ReplaceWith(\"writeFully(src, length)\"), level = DeprecationLevel.ERROR)\n    fun writeBuffer(src: IoBuffer, length: Int): Int {\n        (this as Buffer).writeFully(src, length)\n        return length\n    }\n\n    actual final override fun flush() {\n    }\n\n    @PublishedApi\n    internal fun readableView(): DataView {\n        val readPosition = readPosition\n        val writePosition = writePosition\n\n        return when {\n            readPosition == writePosition -> EmptyDataView\n            readPosition == 0 && writePosition == content.byteLength -> memory.view\n            else -> DataView(content, readPosition, writePosition - readPosition)\n        }\n    }\n\n    @PublishedApi\n    internal fun writableView(): DataView {\n        val writePosition = writePosition\n        val limit = limit\n\n        return when {\n            writePosition == limit -> EmptyDataView\n            writePosition == 0 && limit == content.byteLength -> memory.view\n            else -> DataView(content, writePosition, limit - writePosition)\n        }\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of readable bytes.\n     * The [block] function should return number of consumed bytes.\n     * @return number of bytes consumed\n     */\n    @ExperimentalIoApi\n    inline fun readDirect(block: (DataView) -> Int): Int {\n        val view = readableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        discard(rc)\n        return rc\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of the free space.\n     * The [block] function should return number of written bytes.\n     * @return number of bytes written\n     */\n    @ExperimentalIoApi\n    inline fun writeDirect(block: (DataView) -> Int): Int {\n        val view = writableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        check(rc <= writeRemaining) { \"The returned value from block function is too big: $rc > $writeRemaining\" }\n        commitWritten(rc)\n        return rc\n    }\n\n    actual fun release(pool: ObjectPool<IoBuffer>) {\n        releaseImpl(pool)\n    }\n\n    actual override fun close() {\n        throw UnsupportedOperationException(\"close for buffer view is not supported\")\n    }\n\n    override fun toString(): String =\n        \"Buffer[readable = $readRemaining, writable = $writeRemaining, startGap = $startGap, endGap = $endGap]\"\n\n    actual companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [IoBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        actual val ReservedSize: Int\n            get() = Buffer.ReservedSize\n\n        private val EmptyBuffer = ArrayBuffer(0)\n        private val EmptyDataView = DataView(EmptyBuffer)\n\n        actual val Empty = IoBuffer(Memory.Empty, null)\n\n        /**\n         * The default buffer pool\n         */\n        actual val Pool: ObjectPool<IoBuffer> = object : DefaultPool<IoBuffer>(BUFFER_VIEW_POOL_SIZE) {\n            override fun produceInstance(): IoBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null)\n            }\n\n            override fun clearInstance(instance: IoBuffer): IoBuffer {\n                return super.clearInstance(instance).apply {\n                    unpark()\n                    reset()\n                }\n            }\n\n            override fun validateInstance(instance: IoBuffer) {\n                super.validateInstance(instance)\n\n                require(instance.referenceCount == 0) { \"unable to recycle buffer: buffer view is in use (refCount = ${instance.referenceCount})\" }\n                require(instance.origin == null) { \"Unable to recycle buffer view: view copy shouldn't be recycled\" }\n            }\n\n            override fun disposeInstance(instance: IoBuffer) {\n                DefaultAllocator.free(instance.memory)\n                instance.unlink()\n            }\n        }\n\n        actual val NoPool: ObjectPool<IoBuffer> = object : NoPoolImpl<IoBuffer>() {\n            override fun borrow(): IoBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null)\n            }\n\n            override fun recycle(instance: IoBuffer) {\n                DefaultAllocator.free(instance.memory)\n            }\n        }\n\n        actual val EmptyPool: ObjectPool<IoBuffer> = EmptyBufferPoolImpl\n    }\n}\n\nfun Buffer.readFully(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        memory.copyTo(dst, start, length, offset)\n        length\n    }\n}\n\nfun Buffer.readFully(dst: ArrayBufferView, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        memory.copyTo(dst, start, length, offset)\n        length\n    }\n}\n\nfun Buffer.readAvailable(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (!canRead()) return -1\n    val readSize = minOf(length, readRemaining)\n    readFully(dst, offset, readSize)\n    return readSize\n}\n\nfun Buffer.readAvailable(dst: ArrayBufferView, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (!canRead()) return -1\n    val readSize = minOf(length, readRemaining)\n    readFully(dst, offset, readSize)\n    return readSize\n}\n\nfun Buffer.writeFully(src: ArrayBuffer, offset: Int = 0, length: Int = src.byteLength) {\n    write { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw InsufficientSpaceException(\"Not enough free space to write $length bytes\")\n        }\n\n        src.copyTo(memory, offset, length, start)\n        length\n    }\n}\n\nfun Buffer.writeFully(src: ArrayBufferView, offset: Int = 0, length: Int = src.byteLength - offset) {\n    write { memory, dstOffset, endExclusive ->\n        if (endExclusive - dstOffset < length) {\n            throw InsufficientSpaceException(\"Not enough free space to write $length bytes\")\n        }\n\n        src.copyTo(memory, offset, length, dstOffset)\n        length\n    }\n}\n\ninline fun Buffer.writeDirect(block: (DataView) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return write { memory, start, endExclusive ->\n        block(memory.slice(start, endExclusive - start).view)\n    }\n}\n\ninline fun Buffer.readDirect(block: (DataView) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return read { memory, start, endExclusive ->\n        block(memory.slice(start, endExclusive - start).view)\n    }\n}\n\n\ninline fun Buffer.writeDirectInt8Array(block: (Int8Array) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return write { memory, start, endExclusive ->\n        block(Int8Array(memory.view.buffer, memory.view.byteOffset + start, endExclusive - start))\n    }\n}\n\ninline fun Buffer.readDirectInt8Array(block: (Int8Array) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return read { memory, start, endExclusive ->\n        block(Int8Array(memory.view.buffer, memory.view.byteOffset + start, endExclusive - start))\n    }\n}\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\nprivate val IS_NODE: Boolean = js(\n    \"typeof process !== 'undefined' && process.versions != null && process.versions.node != null\"\n) as Boolean\n\n@Deprecated(\"Use readText with charset instead\", ReplaceWith(\"readText(Charset.forName(encoding), max)\", \"io.ktor.utils.io.core.readText\", \"io.ktor.utils.io.charsets.Charset\"))\nfun ByteReadPacket.readText(encoding: String, max: Int = Int.MAX_VALUE): String = readText(Charset.forName(encoding), max)\n\n@Deprecated(\"Use readText with charset instead\", ReplaceWith(\"readText(out, Charset.forName(encoding), max)\", \"io.ktor.utils.io.core.readText\", \"io.ktor.utils.io.charsets.Charset\"))\nfun ByteReadPacket.readText(encoding: String = \"UTF-8\", out: Appendable, max: Int = Int.MAX_VALUE): Int {\n    return readText(out, Charset.forName(encoding), max)\n}\n\ninternal external class TextDecoder(encoding: String, options: dynamic = definedExternally) {\n    val encoding: String\n\n    fun decode(): String\n    fun decode(buffer: ArrayBuffer): String\n    fun decode(buffer: ArrayBuffer, options: dynamic): String\n    fun decode(buffer: ArrayBufferView): String\n    fun decode(buffer: ArrayBufferView, options: dynamic): String\n}\n\nprivate val STREAM_TRUE = Any().apply {\n    with(this.asDynamic()) {\n        stream = true\n    }\n}\n\nprivate val FATAL_TRUE = Any().apply {\n    with(this.asDynamic()) {\n        fatal = true\n    }\n}\n\ninternal fun TextDecoderFatal(encoding: String, fatal: Boolean = true): TextDecoder {\n    // PhantomJS does not support TextDecoder yet so we use node module text-encoding for tests\n    // Node.js [TextDecoder] doesn't support ISO-8859-1\n    if (IS_NODE || js(\"typeof TextDecoder\") == \"undefined\") {\n        val module = js(\"require('text-encoding')\")\n        if (module.TextDecoder === undefined) throw IllegalStateException(\"TextDecoder is not supported by your browser and no text-encoding module found\")\n        val ctor = module.TextDecoder\n        val objPrototype = js(\"Object\").create(ctor.prototype)\n\n        @Suppress(\"UnsafeCastFromDynamic\")\n        return if (fatal) ctor.call(objPrototype, encoding, FATAL_TRUE)\n        else ctor.call(objPrototype, encoding)\n    }\n\n    return if (fatal) TextDecoder(encoding, FATAL_TRUE) else TextDecoder(encoding)\n}\n\ninternal inline fun TextDecoder.decodeStream(buffer: ArrayBufferView, stream: Boolean): String {\n    decodeWrap {\n        return if (stream) {\n            decode(buffer, STREAM_TRUE)\n        } else {\n            decode(buffer)\n        }\n    }\n}\n\ninternal inline fun TextDecoder.decodeStream(buffer: ArrayBuffer, stream: Boolean): String {\n    decodeWrap {\n        return if (stream) {\n            decode(buffer, STREAM_TRUE)\n        } else {\n            decode(buffer)\n        }\n    }\n}\n\ninternal inline fun <R> decodeWrap(block: () -> R): R {\n    try {\n        return block()\n    } catch (t: Throwable) {\n        throw MalformedInputException(\"Failed to decode bytes: ${t.message ?: \"no cause provided\"}\")\n    }\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.js.*\nimport org.khronos.webgl.*\n\n// I don't know any characters that have longer characters\ninternal const val MAX_CHARACTERS_SIZE_IN_BYTES: Int = 8\nprivate const val MAX_CHARACTERS_COUNT = Int.MAX_VALUE / MAX_CHARACTERS_SIZE_IN_BYTES\n\ninternal data class DecodeBufferResult(val charactersDecoded: String, val bytesConsumed: Int)\n\ninternal fun Int8Array.decodeBufferImpl(nativeDecoder: TextDecoder, maxCharacters: Int): DecodeBufferResult {\n    if (maxCharacters == 0) {\n        return DecodeBufferResult(\"\", 0)\n    }\n\n    // fast-path: try to assume that we have 1 byte per character content\n    try {\n        val sizeInBytes = maxCharacters.coerceAtMost(byteLength)\n        val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n        if (text.length <= maxCharacters) {\n            return DecodeBufferResult(text, sizeInBytes)\n        }\n    } catch (_: dynamic) {\n    }\n\n    return decodeBufferImplSlow(nativeDecoder, maxCharacters)\n}\n\nprivate fun Int8Array.decodeBufferImplSlow(nativeDecoder: TextDecoder, maxCharacters: Int): DecodeBufferResult {\n    val maxBytes = when {\n        maxCharacters >= MAX_CHARACTERS_COUNT -> Int.MAX_VALUE\n        else -> maxCharacters * MAX_CHARACTERS_SIZE_IN_BYTES\n    }.coerceAtMost(byteLength)\n\n    var sizeInBytes = maxBytes\n    while (sizeInBytes > MAX_CHARACTERS_SIZE_IN_BYTES) {\n        try {\n            val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n            if (text.length <= maxCharacters) {\n                return DecodeBufferResult(text, sizeInBytes)\n            }\n        } catch (_: dynamic) {\n        }\n\n        sizeInBytes /= 2\n    }\n\n    sizeInBytes = MAX_CHARACTERS_SIZE_IN_BYTES\n    while (sizeInBytes > 0) {\n        try {\n            val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n            if (text.length <= maxCharacters) {\n                return DecodeBufferResult(text, sizeInBytes)\n            }\n        } catch (_: dynamic) {\n        }\n\n        sizeInBytes--\n    }\n\n    // all attempts were failed so most likely we have a broken character but we can't find it for some reason\n    // so the following decode most likely will fail\n    decodeWrap {\n        nativeDecoder.decode(this)\n    }\n\n    // if it didn't for some reason we have no idea what to do\n    throw MalformedInputException(\"Unable to decode buffer\")\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\ninternal fun encodeISO88591(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    if (fromIndex >= toIndex) return 0\n\n    dst.writeDirect { view ->\n        val i8 = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n        var writeIndex = 0\n        for (index in fromIndex until toIndex) {\n            val character = input[index].toInt()\n            if (character > 0xff) {\n                failedToMapError(character)\n            }\n            i8[writeIndex++] = character.toByte()\n        }\n        writeIndex\n    }\n    return toIndex - fromIndex\n}\n\nprivate fun failedToMapError(ch: Int): Nothing {\n    throw MalformedInputException(\"The character with unicode point $ch couldn't be mapped to ISO-8859-1 character\")\n}\n","package io.ktor.utils.io.core\n\nimport org.khronos.webgl.*\n\nactual enum class ByteOrder {\n    BIG_ENDIAN, LITTLE_ENDIAN;\n\n    actual companion object {\n        private val native: ByteOrder\n\n        init {\n            val buffer = ArrayBuffer(4)\n            val arr = Int32Array(buffer)\n            val view = DataView(buffer)\n\n            arr[0] = 0x11223344\n\n            native = if (view.getInt32(0, true) == 0x11223344) LITTLE_ENDIAN else BIG_ENDIAN\n        }\n\n        actual fun nativeOrder(): ByteOrder = native\n    }\n}\n","@file:Suppress(\"FunctionName\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport org.khronos.webgl.*\n\nactual fun ByteReadPacket(array: ByteArray, offset: Int, length: Int, block: (ByteArray) -> Unit): ByteReadPacket {\n    val content = array.asDynamic() as Int8Array\n    val sub = when {\n        offset == 0 && length == array.size -> content.buffer\n        else -> content.buffer.slice(offset, offset + length)\n    }\n\n    val pool = object : SingleInstancePool<ChunkBuffer>() {\n        override fun produceInstance(): ChunkBuffer {\n            @Suppress(\"DEPRECATION\")\n            return IoBuffer(Memory.of(sub), null)\n        }\n\n        override fun disposeInstance(instance: ChunkBuffer) {@Suppress(\"DEPRECATION\")\n            check(instance is IoBuffer) { \"Only IoBuffer could be recycled\" }\n            block(array)\n        }\n    }\n\n    return ByteReadPacket(pool.borrow().apply { resetForRead() }, pool)\n}\n","package io.ktor.utils.io.core\n\nactual interface Closeable {\n    actual fun close()\n}\n\n@PublishedApi\ninternal actual fun Throwable.addSuppressedInternal(other: Throwable) {\n}\n","@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\n\nfun Input.readFully(dst: Int8Array, offset: Int = 0, length: Int = dst.length - offset) {\n    if (this is AbstractInput) {\n        return readFully(dst, offset, length)\n    }\n\n    val rc = readAvailable(dst, offset, length)\n    if (rc != length) {\n        prematureEndOfStream(length)\n    }\n}\n\nfun Input.readFully(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    if (this is AbstractInput) {\n        return readFully(dst, offset, length)\n    }\n\n    val rc = readAvailable(dst, offset, length)\n    if (rc != length) {\n        prematureEndOfStream(length)\n    }\n}\n\nfun Input.readFully(dst: ArrayBufferView, byteOffset: Int = 0, byteLength: Int = dst.byteLength - byteOffset) {\n    if (this is AbstractInput) {\n        return readFully(dst, byteOffset, byteLength)\n    }\n\n    val rc = readAvailable(dst, byteOffset, byteLength)\n    if (rc != byteLength) {\n        prematureEndOfStream(byteLength)\n    }\n}\n\nfun Input.readAvailable(dst: Int8Array, offset: Int = 0, length: Int = dst.length - offset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    return readAvailable(dst as ArrayBufferView, offset, length)\n}\n\n@Suppress(\"Duplicates\")\nfun Input.readAvailable(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, offset, length)\n    }\n\n    var bytesCopied = 0\n    takeWhile { buffer ->\n        val partSize = minOf(buffer.readRemaining, length - bytesCopied)\n        buffer.memory.copyTo(dst, buffer.readPosition, partSize, bytesCopied)\n        bytesCopied += partSize\n        bytesCopied < length\n    }\n\n    return bytesCopied\n}\n\n@Suppress(\"Duplicates\")\nfun Input.readAvailable(dst: ArrayBufferView, byteOffset: Int = 0, byteLength: Int = dst.byteLength - byteOffset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, byteOffset, byteLength)\n    }\n\n    var bytesCopied = 0\n    takeWhile { buffer ->\n        val partSize = minOf(buffer.readRemaining, byteLength - bytesCopied)\n        buffer.memory.copyTo(dst, buffer.readPosition, partSize, bytesCopied)\n        bytesCopied += partSize\n        bytesCopied < byteLength\n    }\n\n    return bytesCopied\n}\n\ninternal fun AbstractInput.readFully(dst: Int8Array, offset: Int, length: Int) {\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    return readFully(dst as ArrayBufferView, offset, length)\n}\n\ninternal fun AbstractInput.readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n    if (remaining < length) throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n    var copied = 0\n\n    takeWhile { buffer: Buffer ->\n        val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n        if (rc > 0) copied += rc\n        copied < length\n    }\n}\n\ninternal fun AbstractInput.readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n    require(length <= dst.byteLength) {\n        throw IndexOutOfBoundsException(\"length $length is greater than view size ${dst.byteLength}\")\n    }\n\n    return readFully(dst.buffer, dst.byteOffset + offset, length)\n}\n\ninternal fun AbstractInput.readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n\ninternal fun AbstractInput.readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n\ninternal fun AbstractInput.readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport org.khronos.webgl.*\n\n/**\n * Shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\n@Suppress(\"NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS\")\nactual interface Input : Closeable {\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read and readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newValue) {\n            if (newValue != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only BIG_ENDIAN is supported\")\n            }\n        }\n\n    /**\n     * It is `true` when it is known that no more bytes will be available. When it is `false` then this means that\n     * it is not known yet or there are available bytes.\n     * Please note that `false` value doesn't guarantee that there are available bytes so `readByte()` may fail.\n     */\n    actual val endOfInput: Boolean\n\n    /**\n     * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n     * it fails with an exception.\n     * It is safe to specify `max > destination.writeRemaining` but\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source reading that may lead to blocking I/O.\n     * It is safe to specify too big [offset] but only if `min = 0`, fails otherwise.\n     * This function usually copy more bytes than [min] (unless `max = min`).\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     * @throws Throwable when not enough bytes available to provide\n     */\n    actual fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long\n\n    /**\n     * Read the next upcoming byte\n     * @throws EOFException if no more bytes available.\n     */\n    actual fun readByte(): Byte\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readShort(): Short {\n        return readShort()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readInt(): Int {\n        return readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readLong(): Long {\n        return readLong()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readFloat(): Float {\n        return readFloat()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readDouble(): Double {\n        return readDouble()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readFully(dst: IntArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readFully(dst: LongArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"DEPRECATION\")\n    actual fun readFully(dst: IoBuffer, length: Int) {\n        return readFully(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"DEPRECATION\")\n    actual fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return readAvailable(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    actual fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * If the underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"DEPRECATION\", \"ACTUAL_WITHOUT_EXPECT\")\n    actual fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    actual fun discard(n: Long): Long\n\n    actual override fun close()\n}\n","package io.ktor.utils.io.core\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\n@Suppress(\"NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS\")\nactual interface Output : Appendable, Closeable {\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    actual var byteOrder: ByteOrder\n\n    actual fun writeByte(v: Byte)\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeShort(v: Short) {\n        writeShort(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeInt(v: Int) {\n        writeInt(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeLong(v: Long) {\n        writeLong(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeFloat(v: Float) {\n        writeFloat(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeDouble(v: Double) {\n        writeDouble(v)\n    }\n\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeFully(src: IntArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeFully(src: LongArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    actual fun writeFully(src: IoBuffer, length: Int) {\n        writeFully(src, length)\n    }\n\n    actual fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    actual fun fill(n: Long, v: Byte) {\n        fill(n, v)\n    }\n\n    actual fun flush()\n    actual override fun close()\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\n\nactual val PACKET_MAX_COPY_SIZE: Int = 200\ninternal const val BUFFER_VIEW_POOL_SIZE = 100\ninternal const val BUFFER_VIEW_SIZE = 4096\n\nactual fun BytePacketBuilder(headerSizeHint: Int) = BytePacketBuilder(headerSizeHint, ChunkBuffer.Pool)\n\nactual typealias EOFException = io.ktor.utils.io.errors.EOFException\n\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport org.khronos.webgl.*\n\nprivate fun Memory.asInt8Array(): Int8Array {\n    return Int8Array(view.buffer, view.byteOffset, view.byteLength)\n}\n\ninternal actual fun Buffer.discardUntilDelimiterImpl(delimiter: Byte): Int {\n    val content = memory.asInt8Array()\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        if (content[idx] == delimiter) break\n        idx++\n    }\n\n    val start = readPosition\n    discardUntilIndex(idx)\n    return idx - start\n}\n\ninternal actual fun Buffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int {\n    val content = memory.asInt8Array()\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        val v = content[idx]\n        if (v == delimiter1 || v == delimiter2) break\n        idx++\n    }\n\n    val start = readPosition\n    discardUntilIndex(idx)\n    return idx - start\n}\n\n\ninternal actual fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: ByteArray, offset: Int, length: Int): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n\n    return readUntilImpl({ it == delimiter }, dst, offset, length)\n}\n\ninternal actual fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte, delimiter2: Byte,\n    dst: ByteArray, offset: Int, length: Int): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst, offset, length)\n}\n\ninternal actual fun Buffer.readUntilDelimiterImpl(delimiter: Byte, dst: Output): Int {\n    return readUntilImpl({ it == delimiter }, dst)\n}\n\ninternal actual fun Buffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte, dst: Output): Int {\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst)\n}\n\nprivate inline fun Buffer.readUntilImpl(\n    predicate: (Byte) -> Boolean,\n    dst: ByteArray, offset: Int, length: Int): Int {\n\n    val array = memory.asInt8Array()\n    val start = readPosition\n    var i = start\n    val end = i + minOf(length, readRemaining)\n\n    while (i < end) {\n        if (predicate(array[i])) break\n        i++\n    }\n\n    val copied = i - start\n    val dstArray = dst.asDynamic() as Int8Array\n    dstArray.set(array.subarray(start, end), offset)\n    discardUntilIndex(i)\n\n    return copied\n}\n\nprivate inline fun Buffer.readUntilImpl(\n    predicate: (Byte) -> Boolean,\n    dst: Output): Int {\n    val array = memory.asInt8Array()\n    var i = readPosition\n    var copiedTotal = 0\n\n    dst.writeWhile { chunk ->\n        chunk.writeFully(chunk, 0)\n        val start = i\n        val end = minOf(i + chunk.writeRemaining, writePosition)\n\n        while (i < end) {\n            if (predicate(array[i])) break\n            i++\n        }\n\n        val size = i - start\n\n        chunk.memory.asInt8Array().set(array.subarray(start, i), chunk.writePosition)\n        chunk.commitWritten(size)\n        copiedTotal += size\n\n        chunk.writeRemaining == 0 && i < end\n    }\n\n    discardUntilIndex(i)\n    return copiedTotal\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.require\n\n/**\n * Create an instance of [String] from the specified [bytes] range starting at [offset] and bytes [length]\n * interpreting characters in the specified [charset].\n */\n@Suppress(\"FunctionName\")\nactual fun String(bytes: ByteArray, offset: Int, length: Int, charset: Charset): String {\n    if (offset < 0 || length < 0 || offset + length > bytes.size) {\n        checkIndices(offset, length, bytes)\n    }\n\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val i8: Int8Array = bytes.asDynamic() // we know that K/JS generates Int8Array for ByteBuffer\n    val bufferOffset = i8.byteOffset + offset\n    val buffer = i8.buffer.slice(bufferOffset, bufferOffset + length)\n\n    @Suppress(\"DEPRECATION\")\n    val view = IoBuffer(Memory.of(buffer), null)\n    view.resetForRead()\n    val packet = ByteReadPacket(view, ChunkBuffer.NoPoolManuallyManaged)\n\n    return charset.newDecoder().decode(packet, Int.MAX_VALUE)\n}\n\nfun checkIndices(offset: Int, length: Int, bytes: ByteArray): Nothing {\n    require(offset >= 0) { throw IndexOutOfBoundsException(\"offset ($offset) shouldn't be negative\") }\n    require(length >= 0) { throw IndexOutOfBoundsException(\"length ($length) shouldn't be negative\") }\n    require(offset + length <= bytes.size) {\n        throw IndexOutOfBoundsException(\"offset ($offset) + length ($length) > bytes.size (${bytes.size})\")\n    }\n\n    throw IndexOutOfBoundsException()\n}\n\ninternal actual fun String.getCharsInternal(dst: CharArray, dstOffset: Int) {\n    val length = length\n    require(dstOffset + length <= dst.size)\n\n    var dstIndex = dstOffset\n    for (srcIndex in 0 until length) {\n        dst[dstIndex++] = this[srcIndex]\n    }\n}\n","package io.ktor.utils.io.errors\n\nactual open class IOException actual constructor(message: String, cause: Throwable?) : Exception(message, cause) {\n    actual constructor(message: String) : this(message, null)\n}\n\nactual open class EOFException actual constructor(message: String) : IOException(message)\n","package io.ktor.utils.io.js\n\nimport org.khronos.webgl.*\n\ninternal external class TextEncoder() {\n    val encoding: String\n\n    fun encode(input: String): Uint8Array\n}\n\ninternal fun TextEncoderCtor(): TextEncoder {\n    // PhantomJS does not support TextEncoder yet so we use node module text-encoding for tests\n    if (js(\"typeof TextEncoder\") == \"undefined\") {\n        val module = js(\"require('text-encoding')\")\n        if (module.TextEncoder === undefined) throw IllegalStateException(\"TextEncoder is not supported by your browser and no text-encoding module found\")\n        val ctor = module.TextEncoder\n        val objPrototype = js(\"Object\").create(ctor.prototype)\n\n        @Suppress(\"UnsafeCastFromDynamic\")\n        return ctor.call(objPrototype)\n    }\n\n    return TextEncoder()\n}\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\n/**\n * Read exactly [n] bytes to a new array buffer instance\n */\nfun ByteReadPacket.readArrayBuffer(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to make a new ArrayBuffer: packet is too big\")\n): ArrayBuffer {\n    val buffer = ArrayBuffer(n)\n    readFully(buffer, 0, n)\n    return buffer\n}\n\n/**\n * Write exactly [length] bytes from the specified [src] array buffer\n */\nfun BytePacketBuilder.writeFully(src: ArrayBuffer, offset: Int = 0, length: Int = src.byteLength - offset) {\n    writeFully(Int8Array(src), offset, length)\n}\n\n/**\n * Write exactly [length] bytes from the specified [src] typed array\n */\nfun BytePacketBuilder.writeFully(src: Int8Array, offset: Int = 0, length: Int = src.length - offset) {\n    var written = 0\n    var rem = length\n\n    while (rem > 0) {\n        write(1) { bb: Buffer ->\n            val size = minOf(bb.writeRemaining, rem)\n            bb.writeFully(src, written + offset, size)\n            written += size\n            rem -= size\n            size\n        }\n    }\n}\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport org.w3c.dom.*\n\nfun WebSocket.sendPacket(packet: ByteReadPacket) {\n    send(packet.readArrayBuffer())\n}\n\ninline fun WebSocket.sendPacket(block: BytePacketBuilder.() -> Unit) {\n    sendPacket(buildPacket(block = block))\n}\n\ninline fun MessageEvent.packet(): ByteReadPacket {\n    @Suppress(\"NON_PUBLIC_CALL_FROM_PUBLIC_INLINE\", \"UnsafeCastFromDynamic\", \"DEPRECATION\")\n    return ByteReadPacket(IoBuffer(Memory.of(data.asDynamic() as DataView), null), ChunkBuffer.NoPool)\n}\n\n\n\n\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport org.w3c.xhr.*\n\ninline fun XMLHttpRequest.sendPacket(block: BytePacketBuilder.() -> Unit) {\n    sendPacket(buildPacket(block = block))\n}\n\nfun XMLHttpRequest.sendPacket(packet: ByteReadPacket) {\n    send(packet.readArrayBuffer())\n}\n\n@Suppress(\"UnsafeCastFromDynamic\", \"DEPRECATION\")\nfun XMLHttpRequest.responsePacket(): ByteReadPacket = when (responseType) {\n    XMLHttpRequestResponseType.ARRAYBUFFER -> ByteReadPacket(\n        IoBuffer(\n            Memory.of(response.asDynamic() as DataView),\n            null\n        ), ChunkBuffer.NoPoolManuallyManaged\n    )\n    XMLHttpRequestResponseType.EMPTY -> ByteReadPacket.Empty\n    else -> throw IllegalStateException(\"Incompatible type $responseType: only ARRAYBUFFER and EMPTY are supported\")\n}\n\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.w3c.xhr\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.encryptedmedia.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.mediasource.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\n\n/**\n * Exposes the JavaScript [XMLHttpRequestEventTarget](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequestEventTarget) to Kotlin\n */\npublic external abstract class XMLHttpRequestEventTarget : EventTarget {\n    open var onloadstart: ((ProgressEvent) -> dynamic)?\n    open var onprogress: ((ProgressEvent) -> dynamic)?\n    open var onabort: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onload: ((Event) -> dynamic)?\n    open var ontimeout: ((Event) -> dynamic)?\n    open var onloadend: ((Event) -> dynamic)?\n}\n\npublic external abstract class XMLHttpRequestUpload : XMLHttpRequestEventTarget\n\n/**\n * Exposes the JavaScript [XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest) to Kotlin\n */\npublic external open class XMLHttpRequest : XMLHttpRequestEventTarget {\n    var onreadystatechange: ((Event) -> dynamic)?\n    open val readyState: Short\n    var timeout: Int\n    var withCredentials: Boolean\n    open val upload: XMLHttpRequestUpload\n    open val responseURL: String\n    open val status: Short\n    open val statusText: String\n    var responseType: XMLHttpRequestResponseType\n    open val response: Any?\n    open val responseText: String\n    open val responseXML: Document?\n    fun open(method: String, url: String)\n    fun open(method: String, url: String, async: Boolean, username: String? = definedExternally, password: String? = definedExternally)\n    fun setRequestHeader(name: String, value: String)\n    fun send(body: dynamic = definedExternally)\n    fun abort()\n    fun getResponseHeader(name: String): String?\n    fun getAllResponseHeaders(): String\n    fun overrideMimeType(mime: String)\n\n    companion object {\n        val UNSENT: Short\n        val OPENED: Short\n        val HEADERS_RECEIVED: Short\n        val LOADING: Short\n        val DONE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [FormData](https://developer.mozilla.org/en/docs/Web/API/FormData) to Kotlin\n */\npublic external open class FormData(form: HTMLFormElement = definedExternally) {\n    fun append(name: String, value: String)\n    fun append(name: String, value: Blob, filename: String = definedExternally)\n    fun delete(name: String)\n    fun get(name: String): dynamic\n    fun getAll(name: String): Array<dynamic>\n    fun has(name: String): Boolean\n    fun set(name: String, value: String)\n    fun set(name: String, value: Blob, filename: String = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [ProgressEvent](https://developer.mozilla.org/en/docs/Web/API/ProgressEvent) to Kotlin\n */\npublic external open class ProgressEvent(type: String, eventInitDict: ProgressEventInit = definedExternally) : Event {\n    open val lengthComputable: Boolean\n    open val loaded: Number\n    open val total: Number\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface ProgressEventInit : EventInit {\n    var lengthComputable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var loaded: Number? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var total: Number? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ProgressEventInit(lengthComputable: Boolean? = false, loaded: Number? = 0, total: Number? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ProgressEventInit {\n    val o = js(\"({})\")\n    o[\"lengthComputable\"] = lengthComputable\n    o[\"loaded\"] = loaded\n    o[\"total\"] = total\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface XMLHttpRequestResponseType {\n    companion object\n}\n\npublic inline val XMLHttpRequestResponseType.Companion.EMPTY: XMLHttpRequestResponseType get() = \"\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.ARRAYBUFFER: XMLHttpRequestResponseType get() = \"arraybuffer\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.BLOB: XMLHttpRequestResponseType get() = \"blob\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.DOCUMENT: XMLHttpRequestResponseType get() = \"document\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.JSON: XMLHttpRequestResponseType get() = \"json\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.TEXT: XMLHttpRequestResponseType get() = \"text\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()","package io.ktor.utils.io.pool\n\nactual abstract class DefaultPool<T : Any> actual constructor(actual final override val capacity: Int) : ObjectPool<T> {\n    private val instances = arrayOfNulls<Any?>(capacity)\n    private var size = 0\n\n    protected actual abstract fun produceInstance(): T\n    protected actual open fun disposeInstance(instance: T) {}\n\n    protected actual open fun clearInstance(instance: T): T = instance\n    protected actual open fun validateInstance(instance: T) {}\n\n    actual final override fun borrow(): T {\n        if (size == 0) return produceInstance()\n        val idx = --size\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val instance = instances[idx] as T\n        instances[idx] = null\n\n        return clearInstance(instance)\n    }\n\n    actual final override fun recycle(instance: T) {\n        validateInstance(instance)\n        if (size == capacity) {\n            disposeInstance(instance)\n        } else {\n            instances[size++] = instance\n        }\n    }\n\n    actual final override fun dispose() {\n        for (i in 0 until size) {\n            @Suppress(\"UNCHECKED_CAST\")\n            val instance = instances[i] as T\n            instances[i] = null\n            disposeInstance(instance)\n        }\n        size = 0\n    }\n}\n"],"names":[],"mappings":"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EZ,qC;IAIwC,OzBoPK,gByBpPK,mBzBmJT,cyBnJS,CzBoPL,C;G;EyBlP7C,uC;IAIoC,OxBmQG,cwBnQK,mBxB8JP,cwB9JO,CxBmQL,C;G;EwBjQvC,uC;IAIsC,OvB4QI,euB5QK,mBvBmKR,cuBnKQ,CvB4QL,C;G;8GuBzQV,yB;IAAA,0B;IAAA,4B;MAAQ,OAAiB,OAAhB,cAAa,CAAG,C;K;GAAzB,C;4GAGD,yB;IAAA,0B;IAAA,4B;MAAQ,OAAmB,OAAlB,YAAY,GAAM,C;K;GAA3B,C;gHAGC,yB;IAAA,4B;IAAA,4B;MAAQ,OAAe,QAAd,cAAU,EAAI,C;K;GAAvB,C;8GAGD,yB;IAAA,4B;IAAA,4B;MAAQ,OAAkB,QAAjB,YAAS,KAAQ,C;K;GAA1B,C;4GAGF,qB;IAAQ,OAAC,6BAAU,EAAV,CAAc,Q;G;0GAGxB,yB;IAAA,kBAAkB,sB;IAAlB,4B;MAAQ,OAAC,0BAAsB,Q;K;GAA/B,C;8FCiB5B,4B;IAGmD,OCxDpC,cAAK,SDwDsC,KCxDtC,C;G;8FD0DpB,yB;IEnFA,8F;IFmFA,mC;MCnDe,yB;MC7BX,IFmFuD,KEnFnD,eAAQ,UAAZ,C;QAA2B,wBFmF4B,KEnF5B,ED6Be,OC7Bf,C;MFmFqB,OCtDhC,aDsDuC,KElFhD,QD4BS,C;K;GDmDpB,C;4FAKA,yB;IExFA,8F;IFwFA,0C;MC1CQ,yB;MC3CJ,IFwF+D,KExF3D,eAAQ,UAAZ,C;QAA2B,wBFwFoC,KExFpC,ED2CQ,OC3CR,C;MD2ClB,aD6CsD,KEvFxD,QD0CE,ED6C6D,KC7C7D,C;K;GD0Cb,C;8FAKA,mC;ICtDQ,cAAK,SDyDqD,KCzDrD,EDyD4D,KCzD5D,C;G;oGD2Db,yB;IElGA,8F;IFkGA,0C;MAGuD,cAAe,KrBkE/B,K;MsBzH/B,yB;MC3CJ,IFkG2D,KElGvD,eAAQ,UAAZ,C;QAA2B,wBFkGgC,KElGhC,ED2CQ,OC3CR,C;MD2ClB,aDuDkD,KEjGpD,QD0CE,EAAoC,OAApC,C;K;GDoDb,C;sGAKA,mC;IChEQ,cAAK,SDmEiD,KCnEjD,EDmEwD,KrB6D9B,KsBhI1B,C;G;0GExBb,yB;IAcA,kC;IAdA,8B;MAWW,aAAgB,oBAAL,IAAK,C;MAgBhB,Q;MAFP,gBAAgB,qB;MAChB,aAAa,SAAU,eAAM,MAAN,C;;QAEnB,OAjB6B,KAiB7B,CAAM,MAAN,C;;QAEA,SAAU,cAAK,MAAL,C;;MAnBd,W;IACJ,C;GAZA,C;4GAcA,yB;IAAA,kC;IAAA,8B;MAaW,Q;MAFP,gBAAgB,qB;MAChB,aAAa,SAAU,eAAM,IAAN,C;;QAEnB,aAAM,MAAN,C;;QAEA,SAAU,cAAK,MAAL,C;;MAHd,W;IAKJ,C;GAlBA,C;;;;;;;;8GCPA,yB;I9BmPA,sC;I8BnPA,oC;MAGsD,O9B0PT,gBM9Qc,cAAK,UwBoBE,MxBpBF,EAAiB,KAAjB,CN8QnB,C;K;G8B7P7C,C;gHAKA,yB;IF3BA,8F;I5ByQA,sC;I8B9OA,oC;MFxBI,IE2B+D,MF3B3D,eAAQ,UAAZ,C;QAA2B,wBE2BoC,MF3BpC,EtBI4D,QsBJ5D,C;ME2BwB,O9BqPV,gBM9Qc,cAAK,UwByBG,MF1BxD,QtBCqD,EAAiB,KAAjB,CN8QnB,C;K;G8BxP7C,C;gHAKA,oC;IxBaI,cAAK,UwBVwE,MxBUxE,EwBVgF,K9B+IhD,KMrIhC,EAAuC,KAAvC,C;G;kHwBRT,yB;IFrCA,8F;IEqCA,2C;MAGqE,cAAqB,K9B0IjD,K;MM9HrC,yB;MsBjDA,IEqC8E,MFrC1E,eAAQ,UAAZ,C;QAA2B,wBEqCmD,MFrCnD,EtBiDM,QsBjDN,C;MtBiDtB,cwBZyE,MFpCvE,QtBgDF,EAAuC,OAAvC,EAA6D,KAA7D,C;K;GwBfT,C;0GAyBA,yB;I7BgOA,kC;I6BhOA,oC;MAGkD,O7BuOX,cK/RgB,cAAK,UwBwDA,MxBxDA,EAAiB,KAAjB,CL+RrB,C;K;G6B1OvC,C;4GAKA,yB;IFnEA,8F;I3B8RA,kC;I6B3NA,oC;MFhEI,IEmEyD,MFnErD,eAAQ,UAAZ,C;QAA2B,wBEmE8B,MFnE9B,EtBQsD,QsBRtD,C;MEmEoB,O7BkOZ,cK/RgB,cAAK,UwB6DC,MFlElD,QtBKiD,EAAiB,KAAjB,CL+RrB,C;K;G6BrOvC,C;4GAKA,oC;IxBzCI,cAAK,UwB4CkE,MxB5ClE,EwB4C0E,K7BwH9C,KKpK5B,EAAuC,KAAvC,C;G;8GwB8CT,yB;IF7EA,8F;IE6EA,2C;MAGiE,cAAmB,K7BmH/C,K;MK7JjC,yB;MsBnCA,IE6EwE,MF7EpE,eAAQ,UAAZ,C;QAA2B,wBE6E6C,MF7E7C,EtBmCM,QsBnCN,C;MtBmCtB,cwB0CmE,MF5EjE,QtBkCF,EAAuC,OAAvC,EAA6D,KAA7D,C;K;GwBuCT,C;4GAyBA,yB;I5BuMA,oC;I4BvMA,oC;MAGoD,O5B8MV,eIzSP,oBAA9B,cAAK,WwB2FqD,MxB3FrD,EAAkB,KAAlB,CAAyB,CAA9B,WAA2C,EAA3C,CAAD,IACsC,oBAAlC,cAAK,WwB0FkD,MxB1FxC,GAAS,CAAT,IAAV,EAAsB,KAAtB,CAA6B,CADtC,CJySsC,C;K;G4BjN1C,C;8GAKA,yB;IF3GA,8F;I1B6SA,oC;I4BlMA,oC;MFxGI,IE2G4D,MF3GxD,eAAQ,UAAZ,C;QAA2B,wBE2GiC,MF3GjC,EtBcyD,QsBdzD,C;MtBc2B,ewB6FM,MF1GrD,Q;ME0G0C,O5ByMX,eIzSP,oBAA9B,cAAK,WAAU,QAAV,EAAkB,KAAlB,CAAyB,CAA9B,WAA2C,EAA3C,CAAD,IACsC,oBAAlC,cAAK,WAAU,WAAS,CAAT,IAAV,EAAsB,KAAtB,CAA6B,CADtC,CJySsC,C;K;G4B5M1C,C;8GAKA,yB;IxBzDA,kBAKyC,sB;IwBoDzC,2C;MAGkE,cAAoB,K5B2F/C,K;MInJnC,cAAK,UwBwDqE,MxBxDrE,EAAkB,mBAAU,EAAV,CAAc,QAAhC,EAAwD,KAAxD,C;MACL,cAAK,UwBuDqE,MxBvD5D,GAAS,CAAT,IAAT,EAAsB,wBAAuB,QAA7C,EAAqE,KAArE,C;K;GwBoDT,C;gHAKA,yB;IFrHA,8F;ItBuDA,kBAKyC,sB;IwByDzC,2C;MAGmE,cAAoB,K5BsFhD,K;M0B3MnC,IEqH2E,MFrHvE,eAAQ,UAAZ,C;QAA2B,wBEqHgD,MFrHhD,EtBgEI,QsBhEJ,C;MtBgE3B,ewBqD2E,MFpHpE,Q;MtBuDP,cAAK,UAAS,QAAT,EAQqC,OARnB,YAAU,EAAV,CAAc,QAAhC,EAAwD,KAAxD,C;MACL,cAAK,UAAS,WAAS,CAAT,IAA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,C;EACrB,C;EAEA,gC;IAIgC,WAAa,e;IA8nBzC,qB;IvBpSS,aAAM,gB;IAAN,YAAc,sB;IF/XvB,IAAI,EyBsqBuC,CvBvSN,uBuBuSM,GAAe,KAAf,SAjoBL,CzBrClC,CAAJ,C;MACI,oCyBqqBqE,8BAjoBnC,CAioBmC,CzBrqBrE,C;MAKA,CAAE,S;KyBmqBF,UAAc,MlC5qBqC,KAAK,UkC4qBlC,KlC5qBkC,EAAiB,KAAjB,C;IWkY5D,SuB1VsC,C;IvB2VtC,+BAAa,EAAb,C;IuB3V4B,OAwoBrB,O;G;0GApoBX,yB;IAAA,2C;IAAA,8B;IAAA,yD;IAAA,4B;MAE0C,Q;MAAD,OAAiB,UAAhB,2DAAgB,C;K;GAF1D,C;EAIA,+B;IAIkC,WAAa,wB;IAknB3C,qB;IvBpSS,aAAM,gB;IAAN,YAAc,sB;IF/XvB,IAAI,EyBsqBuC,CvBvSN,uBuBuSM,GAAe,KAAf,SArnBH,CzBjDpC,CAAJ,C;MACI,oCyBqqBqE,8BArnBjC,CAqnBiC,CzBrqBrE,C;MAKA,CAAE,S;KyBmqBF,UxC9ZqC,gBwC8ZvB,MlC5qBqC,KAAK,UkC4qBlC,KlC5qBkC,EAAiB,KAAjB,CN8QnB,C;IiBoHzC,SuB9UwC,C;IvB+UxC,+BAAa,EAAb,C;IuB/U8B,OA4nBvB,O;G;4GAxnBX,yB;IAAA,2C;IAAA,8B;IAAA,2D;IAAA,4B;MAE4C,Q;MAAD,OAAiB,WAAhB,2DAAgB,C;K;GAF5D,C;EAKA,8B;IAI4B,WAAa,iB;IAqmBrC,qB;IvBpSS,aAAM,gB;IAAN,YAAc,sB;IF/XvB,IAAI,EyBsqBuC,CvBvSN,uBuBuSM,GAAe,KAAf,SAxmBT,CzB9D9B,CAAJ,C;MACI,oCyBqqBqE,8BAxmBvC,CAwmBuC,CzBrqBrE,C;MAKA,CAAE,S;KyBmqBF,UAAc,MlCxqBiC,KAAK,UkCwqB9B,KlCxqB8B,EAAiB,KAAjB,C;IW8XxD,SuBjUkC,C;IvBkUlC,+BAAa,EAAb,C;IuBlUwB,OA+mBjB,O;G;sGA3mBX,yB;IAAA,2C;IAAA,8B;IAAA,qD;IAAA,4B;MAEsC,Q;MAAD,OAAiB,QAAhB,2DAAgB,C;K;GAFtD,C;EAKA,6B;IAI8B,WAAa,0B;IAwlBvC,qB;IvBpSS,aAAM,gB;IAAN,YAAc,sB;IF/XvB,IAAI,EyBsqBuC,CvBvSN,uBuBuSM,GAAe,KAAf,SA3lBP,CzB3EhC,CAAJ,C;MACI,oCyBqqBqE,8BA3lBrC,CA2lBqC,CzBrqBrE,C;MAKA,CAAE,S;KyBmqBF,UvCzY+B,cuCyYjB,MlCxqBiC,KAAK,UkCwqB9B,KlCxqB8B,EAAiB,KAAjB,CL+RrB,C;IgB+FnC,SuBpToC,C;IvBqTpC,+BAAa,EAAb,C;IuBrT0B,OAkmBnB,O;G;wGA9lBX,yB;IAAA,2C;IAAA,8B;IAAA,uD;IAAA,4B;MAEwC,Q;MAAD,OAAiB,SAAhB,2DAAgB,C;K;GAFxD,C;EAKA,+B;IAI8B,WAAa,c;IA2kBvC,qB;IvBpSS,aAAM,gB;IAAN,YAAc,sB;IF/XvB,IAAI,EyBsqBuC,CvBvSN,uBuBuSM,GAAe,KAAf,SA9kBP,CzBxFhC,CAAJ,C;MACI,oCyBqqBqE,8BA9kBrC,CA8kBqC,CzBrqBrE,C;MAKA,CAAE,S;KyBmqBM,eAAM,M;IAAN,aAAc,K;IAAtB,UlCnqB2B,oBkCmF/B,QlCnFC,KAAK,WkCmFY,MlCnFZ,EAAkB,KAAlB,CAAyB,CAA9B,WAA2C,EAA3C,CAAD,IACsC,oBkCkFtC,QlClFI,KAAK,WkCkFS,MlClFC,GAAS,CAAT,IAAV,EAAsB,KAAtB,CAA6B,CADtC,C;IWyXA,SuBvSoC,C;IvBwSpC,+BAAa,EAAb,C;IuBxS0B,OAqlBnB,O;G;wGAjlBX,yB;IAAA,2C;IAAA,8B;IAAA,uD;IAAA,4B;MAEwC,Q;MAAD,OAAiB,SAAhB,2DAAgB,C;K;GAFxD,C;EAIA,8B;IAIgC,WAAa,uB;IA+jBzC,qB;IvBpSS,aAAM,gB;IAAN,YAAc,sB;IF/XvB,IAAI,EyBsqBuC,CvBvSN,uBuBuSM,GAAe,KAAf,SAlkBL,CzBpGlC,CAAJ,C;MACI,oCyBqqBqE,8BAlkBnC,CAkkBmC,CzBrqBrE,C;MAKA,CAAE,S;KyBmqBM,eAAM,M;IAAN,aAAc,K;IAAtB,UtC1XkC,eIzSP,oBkC+F/B,QlC/FC,KAAK,WkC+Fa,MlC/Fb,EAAkB,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,C;MACI,sCuB0MgC,4DvB1MhC,C;MAKA,GAAE,S;KuBuMF,OAAO,sBAAkB,YAAlB,EAAyB,gBAAS,UAAT,IAAzB,EAA8C,WAAW,UAAX,IAA9C,C;EACX,C;mDAEA,iB;IACI,MAAM,8BAA0B,iCAA8B,KAA9B,WAAuC,WAAjE,C;EACV,C;;;;;;EAI8B,6B;IAAC,kB;G;;;kHAGD,yB;Mb7KF,4B;MzBqNhC,sC;MsCxCkC,mB;QAAQ,OtCkDG,gByB/NU,Qa6Kb,Ub7KD,KAAU,EAAI,CzB+NV,C;O;KsClDX,C;;;;6GACL,yB;Mb3KE,4B;MzBkN/B,sC;MsCvC6B,mB;QAAQ,OtCiDQ,gByB5NY,Qa2KpB,Ub3KG,GAAS,KAAQ,CzB4NZ,C;O;KsCjDhB,C;;2IAEzB,yB;IbhL4B,4B;IzBqNhC,sC;IsCrCI,mB;MAA2C,OtC+CF,gByB/NU,Qa6Kb,Ub7KD,KAAU,EAAI,CzB+NV,C;K;GsC/CzC,C;2IACA,yB;Ib9K2B,4B;IzBkN/B,sC;IsCpCI,mB;MAA2C,OtC8CF,gByB5NY,Qa2KpB,Ub3KG,GAAS,KAAQ,CzB4NZ,C;K;GsC9CzC,C;;;;;;EANA,qD;IAAA,sD;IAAiD,yBAAK,CAAA,UtCnChB,KAAL,GAAiB,KsCmCI,KAAuB,EAAvB,GAA6B,KtCnC7C,KAAL,GAAiB,KsCmCD,C;IAAjD,Y;G;;;;oCAFJ,Y;IAAA,OACmC,mDADnC,M;G;oCAAA,Y;IAAA,c;IACmC,sD;IADnC,a;G;kCAAA,iB;IAAA,2IACmC,sCADnC,G;G;EAWA,sE;IAY6B,UAET,M;IAZI,QAAU,QAAO,qBAAO,UtC9CN,KAAL,GAAiB,KsC8CpB,K;IAA9B,oBxCqCO,MAAK,KwCrCc,ExCqCd,EAAO,CAAP,C;IwCpCZ,kBAA2B,eAAT,QAAS,EAAa,qBAAO,UtC/CT,KAAL,GAAiB,KsC+CvB,C;IAC3B,qBAAqB,S;IACrB,YAAY,I;;MAGR,IAAI,kBAAkB,WAAlB,IAAiC,SAAS,aAA9C,C;QACI,OAAO,kBtC8CwB,gBAAY,QsC9CtB,QAAQ,IAAR,ItC8CsB,CAAZ,CsC9CxB,EtC8CwB,gBAAY,QsC9CK,iBAAiB,SAAjB,ItC8CL,CA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,cAAK,OAAlB,EAA0B,cAAK,WAAL,GAAkB,MAAlB,IAA1B,EAAoD,KAApD,C;IAEZ,IAAI,sBAAJ,C;MlE9BA,iBAAc,CAAd,UkE+BW,KlE/BX,U;QkEgCQ,YlE/BG,KkE+BS,wBAAZ,IAAsD,mBCo+BA,MnEngCnD,KmEmgCmD,CDp+BA,C;;;MlEhC9D,mBAAc,CAAd,YkEmCW,KlEnCX,Y;QkEoCQ,YlEnCG,OkEmCS,wBAAZ,ICg+BsD,MnEngCnD,OmEmgCmD,C;;;ED79BlE,C;EAEA,qF;IAQI,iC;MAAA,oB5C6DyB,C;I4C5DzB,qB;MAAA,Q5C6Da,WAAY,OAAZ,GAAmB,iBAAnB,I;IH/Pb,I+CoMgB,M/CpMZ,eAAQ,UAAZ,C;MAA2B,wB+CoMX,M/CpMW,E+CoMQ,Q/CpMR,C;I+CoM3B,2BAAgB,M/CnMT,Q+CmMP,EAA8C,WAA9C,EAA2D,iBAA3D,EAA8E,KAA9E,C;EACJ,C;EAEA,yE;IAQI,4B;MAAA,e5CmHoB,C;I4ClHpB,qB;MAAA,Q5CmHa,MAAO,OAAP,GAAc,YAAd,I;I4CjHb,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,KAAlD,C;IAEZ,IAAI,sBAAJ,C;MlEpEA,iBAAc,CAAd,UkEsEW,KlEtEX,U;QmEg4BkE,MnE/3BvD,KmE+3BuD,IDzzBd,mBAA7B,OlEtEZ,KkEsEmB,mBAAP,CAA6B,C;;;MlEvEpD,mBAAc,CAAd,YkE0EW,KlE1EX,Y;QmEg4BkE,MnE/3BvD,OmE+3BuD,IDrzB3C,OlE1EZ,OkE0EmB,mBAAP,C;;;EAG3B,C;EAEA,2E;IAQI,4B;MAAA,e5CsGoB,C;I4CrGpB,qB;MAAA,Q5CsGa,MAAO,OAAP,GAAc,YAAd,I;IH/Ub,I+C2OgB,M/C3OZ,eAAQ,UAAZ,C;MAA2B,wB+C2OX,M/C3OW,E+C2OQ,Q/C3OR,C;I+C2O3B,2BAAgB,M/C1OT,Q+C0OP,EAA8C,MAA9C,EAAsD,YAAtD,EAAoE,KAApE,C;EACJ,C;EAEA,uE;IAQI,4B;MAAA,e5CgIoB,C;I4C/HpB,qB;MAAA,Q5CgIa,MAAO,OAAP,GAAc,YAAd,I;I4C9Hb,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,KAAlD,C;IAEZ,IAAI,sBAAJ,C;MlE3GA,iBAAc,CAAd,UkE4GW,KlE5GX,U;QmEs7BgE,MnEr7BrD,KmEq7BqD,IDz0BZ,mBAA7B,OlE5GZ,KkE4GmB,mBAAP,CAA6B,C;;;MlE7GpD,mBAAc,CAAd,YkEgHW,KlEhHX,Y;QmEs7BgE,MnEr7BrD,OmEq7BqD,IDr0BzC,OlEhHZ,OkEgHmB,mBAAP,C;;;EAG3B,C;EAEA,yE;IAQI,4B;MAAA,e5CoHoB,C;I4CnHpB,qB;MAAA,Q5CoHa,MAAO,OAAP,GAAc,YAAd,I;IHnYb,I+CiRc,M/CjRV,eAAQ,UAAZ,C;MAA2B,wB+CiRb,M/CjRa,E+CiRM,Q/CjRN,C;I+CiR3B,yBAAc,M/ChRP,Q+CgRP,EAA4C,MAA5C,EAAoD,YAApD,EAAkE,KAAlE,C;EACJ,C;EAEA,wE;IAQI,4B;MAAA,e5C8IoB,C;I4C7IpB,qB;MAAA,Q5C8Ia,MAAO,OAAP,GAAc,YAAd,I;I4CzIa,UAOA,M;IAV1B,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,QAAQ,CAAR,IAAlD,C;IAEZ,IAAI,sBAAJ,C;MAC0B,eAAQ,CAAR,I;MAAtB,iBAAc,CAAd,yBAAqC,CAArC,C;QACI,kBAAkB,SAAQ,CAAR,QAAY,YAAZ,I;QAClB,kBAAkB,OAAO,WAAP,C;QAClB,KCiyBwD,CDjyBlD,KCiyBkD,IDjyBX,mBAA7B,+BAAiB,EAAjB,CAAqB,QAAQ,C;QAC7C,KCgyBwD,CDhyBlD,QAAQ,CAAR,ICgyBkD,IDhyBC,mBAArC,4BAA6B,QAAQ,C;;;MAGvC,iBAAQ,CAAR,I;MAAtB,mBAAc,CAAd,+BAAqC,CAArC,C;QACI,oBAAkB,WAAQ,CAAR,QAAY,YAAZ,I;QAClB,oBAAkB,OAAO,aAAP,C;QAClB,KC0xBwD,CD1xBlD,OC0xBkD,ID1xBxC,iCAAiB,EAAjB,CAAqB,Q;QACrC,KCyxBwD,CDzxBlD,UAAQ,CAAR,ICyxBkD,IDzxBpC,8BAA6B,Q;;;EAG7D,C;EAEA,0E;IAQI,4B;MAAA,e5C4HoB,C;I4C3HpB,qB;MAAA,Q5C4Ha,MAAO,OAAP,GAAc,YAAd,I;IHvbb,I+C6Te,M/C7TX,eAAQ,UAAZ,C;MAA2B,wB+C6TZ,M/C7TY,E+C6TO,Q/C7TP,C;I+C6T3B,0BAAe,M/C5TR,Q+C4TP,EAA6C,MAA7C,EAAqD,YAArD,EAAmE,KAAnE,C;EACJ,C;EAEA,yE;IAQI,4B;MAAA,e5CsJoB,C;I4CrJpB,qB;MAAA,Q5CsJa,MAAO,OAAP,GAAc,YAAd,I;I4CpJb,YAAY,iBAAa,cAAK,OAAlB,EAA0B,cAAK,WAAL,GAAkB,MAAlB,IAA1B,EAAoD,KAApD,C;IAEZ,IAAI,sBAAJ,C;MlE7LA,iBAAc,CAAd,UkE8LW,KlE9LX,U;QmE4+BoE,MnE3+BzD,KmE2+ByD,ID7yBhB,mBAA7B,OlE9LZ,KkE8LmB,mBAAP,CAA6B,C;;;MlE/LpD,mBAAc,CAAd,YkEkMW,KlElMX,Y;QmE4+BoE,MnE3+BzD,OmE2+ByD,IDzyB7C,OlElMZ,OkEkMmB,mBAAP,C;;;EAG3B,C;EAEA,2E;IAQI,4B;MAAA,e5C0IoB,C;I4CzIpB,qB;MAAA,Q5C0Ia,MAAO,OAAP,GAAc,YAAd,I;IH3eb,I+CmWgB,M/CnWZ,eAAQ,UAAZ,C;MAA2B,wB+CmWX,M/CnWW,E+CmWQ,Q/CnWR,C;I+CmW3B,2BAAgB,M/ClWT,Q+CkWP,EAA8C,MAA9C,EAAsD,YAAtD,EAAoE,KAApE,C;EACJ,C;EAEA,0E;IAQI,4B;MAAA,e5CwIoB,C;I4CvIpB,qB;MAAA,Q5CwIa,MAAO,OAAP,GAAc,YAAd,I;I4CtIb,YAAY,iBAAa,cAAK,OAAlB,EAA0B,cAAK,WAAL,GAAkB,MAAlB,IAA1B,EAAoD,KAApD,C;IAEZ,IAAI,sBAAJ,C;MlEnOA,iBAAc,CAAd,UkEoOW,KlEpOX,U;QmEugCqE,MnEtgC1D,KmEsgC0D,IDlyBjB,mBAA7B,OlEpOZ,KkEoOmB,mBAAP,CAA6B,C;;;MlErOpD,mBAAc,CAAd,YkEwOW,KlExOX,Y;QmEugCqE,MnEtgC1D,OmEsgC0D,ID9xB9C,OlExOZ,OkEwOmB,mBAAP,C;;;EAG3B,C;EAEA,4E;IAQI,4B;MAAA,e5C4HoB,C;I4C3HpB,qB;MAAA,Q5C4Ha,MAAO,OAAP,GAAc,YAAd,I;IHngBb,I+CyYiB,M/CzYb,eAAQ,UAAZ,C;MAA2B,wB+CyYV,M/CzYU,E+CyYS,Q/CzYT,C;I+CyY3B,4BAAiB,M/CxYV,Q+CwYP,EAA+C,MAA/C,EAAuD,YAAvD,EAAqE,KAArE,C;EACJ,C;EEzY6B,wB;IAIzB,+B;IAJ0B,0B;G;EAI1B,6B;IAAA,iC;G;gDACI,gB;IACI,IAAI,aAAQ,OAAR,KAAmB,aAAQ,OAAR,CAAnB,IAAsC,aAAQ,MAAR,CAAtC,IAAwD,aAAQ,MAAR,CAA5D,C;MAA4E,OAAO,sBAAS,M;IACxF,wBAAQ,YAAR,KAAwB,aAAQ,YAAR,C;IAAxB,U;MpEkGL,SoEjGa,QAAL,IAAK,EAAQ,EAAR,EAAa,EAAb,C;MAAwB,wBAAM,YAAN,C;MAAA,Y;QAAsB,gBAAA,ECwKF,cDxKE,EAAoB,YAApB,C;OAA5B,a;KAD9B,IAAI,QAEG,aAAQ,QAAR,CAFP,C;MAII,OAAO,sBAAS,W;KAEpB,MAAM,8BAAyB,aAAU,IAAV,sBAAzB,C;EACV,C;;;;;;;EAVJ,yC;IAAA,wC;MAAA,uB;KAAA,iC;G;;;;;;EAe4B,6B;IAAQ,8B;G;EAIJ,kC;IAAC,gC;G;;;;;;EACA,qC;IAAiC,0BAAe,OAAf,C;IAAhC,wB;G;;;;;;8CAAtC,Y;IAAsC,qB;G;8CAAtC,mB;IAAA,8BAAsC,6CAAtC,C;G;0CAAA,Y;IAAA,OAAsC,+DAAtC,M;G;0CAAA,Y;IAAA,c;IAAsC,0D;IAAtC,a;G;wCAAA,iB;IAAA,2IAAsC,8CAAtC,G;G;EAC2C,gC;IAAQ,iC;G;EAEnD,iE;IAAiE,yB;MAAA,Y1EG5C,C;I0EH4D,uB;MAAA,U1EI9D,KAAM,O;I0EHrB,yCAAuB,KAAvB,EAA8B,SAA9B,EAAyC,OAAzC,C;G;EAEJ,+D;IAegC,Q;I9EhB5B,IAAI,E8EEI,aAAa,O9EFjB,CAAJ,C;MACI,cAda,qB;MAeb,MAAM,8BAAyB,OAAQ,WAAjC,C;K8ECV,IAAI,+BAAW,sBAAS,WAApB,CAAJ,C;MACI,OAAO,eAAe,KAAf,EAAsB,SAAtB,EAAiC,OAAjC,EAA0C,GAA1C,C;K9EJX,IAAI,E8EOI,2BAAY,sBAAS,M9EPzB,CAAJ,C;MACI,gB8EMkC,wC;M9ELlC,MAAM,8BAAyB,SAAQ,WAAjC,C;K8EOV,cAAc,iB;IACd,YAAY,S;IACZ,mBAAmB,G5DyBoB,S4DzBpB,G5DyB4B,cAAR,I;I4DvBvC,OAAO,QAAQ,OAAR,IAAmB,eAAe,CAAzC,C;MACmB,QAAM,UAAU,KAAV,I;MAAN,QAAuB,eAAe,CAAf,I;MAAtC,eAAwD,c/EgOrD,MAAK,KAAI,CAAJ,EAAO,CAAP,C+EhOgD,EAAc,CAAd,C;MACxD,mBAA+C,gBAA5B,iBAAM,QAAQ,QAAR,GAAmB,CAAnB,IAAN,CAA4B,C;MAE3C,oBAAgB,aAAY,CAA5B,C;QAAiC,eAAQ,CAAR,I;WACjC,iB;QAAgB,eAAQ,QAAR,GAAmB,CAAnB,I;;QACR,eAAQ,QAAR,I;MAHZ,4B;MAMkC,iBAAU,K;MAA5C,aAAa,OAAQ,QE0S+D,mBF1SxD,KE0SwD,EAAY,UAAZ,EF1SjC,iBE0SiC,CAAkC,WF1SjG,C;MACrB,IAAI,MAAO,OAAP,GAAgB,YAApB,C;QAAkC,K;MAC9B,cAAJ,GAAI,EAAW,MAAX,C;MACJ,QAAQ,iB;MACR,8BAAgB,MAAO,OAAvB,I;;IAGJ,OAAO,QAAQ,SAAR,I;EACX,C;EAEA,6C;I9EhCI,IAAI,E8EiCI,2BAAY,sBAAS,M9EjCzB,CAAJ,C;MACI,cAda,qB;MAeb,MAAM,8BAAyB,OAAQ,WAAjC,C;K8EiCN,cAAJ,GAAI,EAAY,KAAZ,C;EACR,C;EAEA,wC;IAA0E,W;G;EAMtC,kC;IAAC,gC;G;;;;;;EAEA,qC;IAAiC,0BAAe,OAAf,C;IAAhC,wB;G;;;;;;8CAAtC,Y;IAAsC,qB;G;8CAAtC,mB;IAAA,8BAAsC,6CAAtC,C;G;0CAAA,Y;IAAA,OAAsC,+DAAtC,M;G;0CAAA,Y;IAAA,c;IAAsC,0D;IAAtC,a;G;wCAAA,iB;IAAA,2IAAsC,8CAAtC,G;G;EAE2C,kC;IAAQ,iC;G;EAEnD,8D;IAII,mB;MAAA,M1E8CW,U;I0E5CX,IAAI,QAAO,CAAX,C;MAAc,OAAO,C;IAErB,cAAc,iBAAyB,SAAR,wBAAQ,CAAzB,C;IACd,sB;I5D2SS,a4DzST,K5DySe,O;IAAN,Y4DzST,K5DySuB,a;IAAd,mB4DzST,K5DySqC,c;I4DxSjC,aAAkB,iBG8ZZ,mBAAU,MAAO,KAAK,OAAtB,EAA8B,MAAO,KAAK,WAAZ,GAAyB,KAAzB,IAA9B,EAA8D,eAAe,KAAf,IAA9D,CH9ZY,e;IACd,mBAAO,MAAO,kBAAd,C;IACJ,WAAS,MAAO,c;I5DsSpB,S4DpSI,MAAO,c;IALX,K5D0SA,sBAAa,EAAb,C;I4DlSA,OAAO,Q;EACX,C;EAEA,8C;IACI,cAAc,iBAAyB,SAAR,wBAAQ,CAAzB,EAA+B,IAA/B,C;IACd,2BAAuB,CAAvB,C;;MxCiKc,gB;MADd,cAAc,I;MACA,4BwC7Jd,KxC6Jc,EAFgC,CAEhC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAH8C,C;;;sBAOzB,O;UAAb,apBjN8B,sBAAgB,kBAAhB,I;UoBkN9B,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;;gBwCvJA,U;gBAfnB,UAAU,MAAM,kBAAN,I;gBACV,iBAAiB,M5DjDiB,iB4DiDjB,M5DjDiC,aAAhB,I;gB4DkDlC,IAAI,MAAM,UAAV,C;kBAAsB,eAAqB,C;kBAArB,iB;iB5DqRjB,a4DnRL,M5DmRW,O;gBAAN,Y4DnRL,M5DmRmB,a;gBAAd,mB4DnRL,M5DmRiC,c;gB+DsHjC,WAAM,mBAAU,MAAO,KAAK,OAAtB,EAA8B,MAAO,KAAK,WAAZ,GAAyB,KAAzB,IAA9B,EAA8D,eAAe,KAAf,IAA9D,C;gBC9aqD,U;;kBJuC3C,uB;kBIvC2C,U;;oBAtBpD,U;oBAAA,IJ6DqC,II7DrC,C;sBACH,8BAAe,WAAf,C;;sBAEA,6B;;oBAHJ,4B;;oBAqBF,gC;sBACE,MAAM,4BAAwB,8BAA2B,CAAE,SAAF,CAAE,QAAF,qBAAa,mBAAxC,CAAxB,C;;sBAHV,O;;;kBAEE,kC;oBACE,MAAM,4BAAwB,8BAA2B,CAAE,SAAF,GAAE,QAAF,qBAAa,mBAAxC,CAAxB,C;;oBAHV,S;;gBJyCQ,qC;gBAGI,mBAAO,WAAP,C;gBACJ,0CAAoB,WAAY,OAAhC,I;gB5D8QR,S4D7QQ,IAAK,W;gBANT,M5DoRJ,sBAAa,EAAb,C;gB4D1QQ,+B;;oBAEgB,yB;;oBAER,W;;kBAHJ,iB;kBAMA,IAAI,IE0GmC,UAAS,CF1GhD,C;oBAGI,MAAO,gBAAO,UAAP,C;mBAxBnB,eA0BQ,C;uBAEJ,6B;kBA5BJ,eA4B8B,C;;kBA5B9B,eA6BY,C;;;;cxCyIA,mB;;4BAEQ,O;cAAR,QpBxNsB,wBAAgB,oBAAhB,I;;;YoB2N1B,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,6BwClL1B,KxCkL0B,EAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB5OG,mBAAW,aAAX,IoB4OH,IAAiB,C;aAAjC,W;cACI,mBwCpLhB,KxCoLgB,EAAiB,OAAjB,C;cACA,8BwCrLhB,KxCqLgB,EAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;;WAIA,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,mBwCnMR,KxCmMQ,EAAiB,OAAjB,C;;;;IwCjKR,IAAI,qBAAmB,GAAvB,C;MACI,iBAAW,CAAX,C;;QxC0HU,kB;QADd,gBAAc,I;QACA,8BwCzHV,KxCyHU,EwCzHU,CxCyHV,C;QAAA,mB;UAAqC,yB;SAAnD,gBAAc,M;QACd,awC1HwB,C;;;0BxC8HH,S;YAAb,epBjN8B,wBAAgB,oBAAhB,I;YoBkN9B,W;YAEA,IAAI,YAAU,MAAd,C;;gBAEe,eAAM,S;gBpBiHpB,e4DnPQ,Q5DmPF,O;gBAAN,c4DnPQ,Q5DmPM,a;gBAAd,qB4DnPQ,Q5DmPoB,c;gB4DlPzB,aAAkB,iBGwWpB,mBAAU,QAAO,KAAK,OAAtB,EAA8B,QAAO,KAAK,WAAZ,GAAyB,OAAzB,IAA9B,EAA8D,iBAAe,OAAf,IAA9D,CHxWoB,WAA0B,MAAM,kBAAN,IAA1B,C;gBACd,mBAAO,MAAO,kBAAd,C;gBACJ,0CAAoB,MAAO,kBAAkB,OAA7C,I;gB5DgPZ,W4D/OY,MAAO,c;gBAJF,Q5DoPjB,sBAAa,IAAb,C;gB4DpPQ,W5DqPD,I;gB4D9OK,WAAK,CAAL,C;kBAAU,WAAO,C;qBACjB,iBAAQ,CAAR,C;kBAAwC,WAAO,C;;kBACvC,2B;;gBxCyHJ,SwCtHR,Q;;8BxCwHgB,S;gBAAR,UpBxNsB,wBAAgB,oBAAhB,I;;;coB2N1B,UAAQ,Q;;YAGZ,YAAU,K;YAGN,gBAAS,CAAT,C;cAAc,6BwC9ItB,KxC8IsB,EAAoB,SAApB,C;;cACd,uBAAQ,M;cAAR,Y;8BAAgB,S;gBAAA,UpB5OG,mBAAW,aAAX,IoB4OH,IAAiB,C;eAAjC,W;gBACI,mBwChJZ,KxCgJY,EAAiB,SAAjB,C;gBACA,8BwCjJZ,KxCiJY,EAAqB,MAArB,C;;gBAEI,kB;;YANZ,mB;YASA,IAAI,cAAJ,C;cACI,K;aAGJ,YAAU,M;YACV,YAAU,I;;UACL,iBAAO,CAAP,C;;UAET,IAAI,SAAJ,C;YACI,mBwC/JJ,KxC+JI,EAAiB,SAAjB,C;;;;KwC9IR,OAAO,kB;EACX,C;EAEA,yD;IACI,IAAI,gBAAe,CAAnB,C;MAAsB,OAAO,E;IACzB,8C;IAAA,S;MAA0B,QAAA,K1C9FX,oB0C8FW,K1C9FQ,aAAnB,I0C8FW,KAAuB,W;KAArD,S;MACI,cAAc,iBAAiB,wBAAQ,cAAzB,EAAgC,IAAhC,C;MAEd,WAAW,KAAM,K;MACjB,WAAW,KAAM,WAAW,K;MAEjB,qB;MIhGgD,U;;QJiGxB,U;QAC3B,IAAK,iBAAL,KAAqB,CAArB,IAA0B,gBAAoB,eAA9C,C;UAA4D,a;;UACpD,sBAAc,WAAd,EAA2B,eAAL,GAAuB,iBAAvB,IAAtB,c;QAFZ,oB;QInGJ,oBJwGY,eAAO,OAAP,C;;QIvGd,gC;UACE,MAAM,4BAAwB,8BAA2B,CAAE,SAAF,CAAE,QAAF,qBAAa,mBAAxC,CAAxB,C;;UAHV,O;;MJmGI,4B;MASA,KAAM,sBAAa,WAAb,C;MACN,OAAO,I;KAGX,OAAO,gCAAqB,KAArB,EAA4B,WAA5B,C;EACX,C;EAIA,oB;IAAA,wB;IACI,aAA4B,gBAAY,OAAZ,C;IAC5B,kBAAiC,gBAAY,YAAZ,C;G;;;;;;;EAFrC,gC;IAAA,+B;MAAA,c;KAAA,wB;G;EAK8B,2B;IAAqB,mBAAQ,IAAR,C;IAApB,gB;G;qCAC3B,Y;IAA4C,8BAAmB,IAAnB,C;G;qCAC5C,Y;IAA4C,8BAAmB,IAAnB,C;G;;;;;;qCAFhD,Y;IAA+B,gB;G;uCAA/B,gB;IAAA,uBAA+B,kCAA/B,C;G;mCAAA,Y;IAAA,OAA+B,gDAA/B,M;G;mCAAA,Y;IAAA,c;IAA+B,qD;IAA/B,a;G;iCAAA,iB;IAAA,2IAA+B,oCAA/B,G;G;EAM0C,0C;;6BAAgD,O;;;;G;;;;;;;;;;;;;;;;EAE1F,6D;IACI,cAAc,iBAAyB,SAAR,wBAAQ,CAAzB,EAA+B,IAA/B,C;IACd,yBAAqB,WAArB,C;IACA,SAAS,qBAAc,WAAd,C;IIlIsD,Q;;;Q5C6LjD,kB;QADd,cAAc,I;QACA,qCwCxDU,CxCwDV,C;QAAA,mB;UAAqC,yB;SAAnD,cAAc,M;QACd,WwCzDwB,C;;;wBxC6DH,O;YAAb,apBjN8B,sBAAgB,kBAAhB,I;YoBkN9B,S;YAEA,IAAI,UAAU,IAAd,C;;gBAEe,aAAM,O;gBwC/DV,U;gBAFX,gBAAgB,M5DrJc,iB4DqJd,M5DrJ8B,aAAhB,I;gB4DsJnB,QAAiB,gB;gBAA5B,a/EyDD,MAAK,K+EzDa,S/EyDb,EAAO,CAAP,C;gB+EvDA,IAAA,MAAO,aAAP,KAAuB,CAAvB,IAA4B,MAAO,OAAO,KAAK,WAAnB,KAAiC,MAA7D,C;kBAA6E,eACzE,MAAO,OAAO,K;kBAD2D,uB;kBIzI1B,U;;oBAtBpD,U;oBAAA,IJiKK,IIjKL,C;sBACH,kCAAe,WAAf,C;;sBAEA,iC;;oBAHJ,4B;;oBAqBF,gC;sBACE,MAAM,4BAAwB,8BAA2B,CAAE,SAAF,CAAE,QAAF,qBAAa,mBAAxC,CAAxB,C;;sBAHV,O;;kBJ4IyF,4B;;kBAI7D,eACZ,cACI,MAAO,OAAO,KAAK,OADvB,EAEI,MAAO,OAAO,KAAK,WAAnB,GAAgC,MAAO,aAAvC,IAFJ,EAGI,MAHJ,C;kBADY,yB;kBI7ImC,U;;oBAtBpD,U;oBAAA,IJwKQ,IIxKR,C;sBACH,kCAAe,WAAf,C;;sBAEA,iC;;oBAHJ,8B;;oBAqBF,kC;sBACE,MAAM,4BAAwB,8BAA2B,CAAE,SAAF,GAAE,QAAF,qBAAa,mBAAxC,CAAxB,C;;sBAHV,S;;kBJgJ4B,8B;;gBALpB,iB;gBAaG,kBAAO,IAAP,C;gBAEH,MAAO,sBAAa,MAAb,C;gBACP,sCAAkB,MAAlB,I;gBxC+CQ,OwC7CJ,mBAAiB,CAArB,GAAwB,CAAxB,GAA+B,C;;8BxC+Cf,O;gBAAR,QpBxNsB,wBAAgB,oBAAhB,I;;;coB2N1B,QAAQ,M;;YAGZ,UAAU,K;YAGN,cAAS,CAAT,C;cAAc,oCAAoB,OAApB,C;;cACd,qBAAQ,I;cAAR,Y;8BAAgB,O;gBAAA,UpB5OG,mBAAW,aAAX,IoB4OH,IAAiB,C;eAAjC,W;gBACI,0BAAiB,OAAjB,C;gBACA,qCAAqB,IAArB,C;;gBAEI,gB;;YANZ,iB;YASA,IAAI,YAAJ,C;cACI,K;aAGJ,UAAU,I;YACV,UAAU,I;;UACL,eAAO,CAAP,C;;UAET,IAAI,OAAJ,C;YACI,0BAAiB,OAAjB,C;;;;MwCtEJ,IAAI,mBAAiB,CAArB,C;;UxCEU,kB;UADd,gBAAc,I;UACA,qCAAqB,CAArB,C;UAAA,mB;YAA2B,qB;WAAzC,gBAAc,M;;;cAID,eAAM,S;cwCFI,W;cAFX,kBAAgB,Q5D9KU,iB4D8KV,Q5D9K0B,aAAhB,I;c4D+Kf,UAAiB,gB;cAA5B,a/EgCL,MAAK,K+EhCiB,W/EgCjB,EAAO,GAAP,C;c+E9BI,IAAA,QAAO,aAAP,KAAuB,CAAvB,IAA4B,QAAO,OAAO,KAAK,WAAnB,KAAiC,MAA7D,C;gBACY,yBAAO,QAAO,OAAO,KAArB,C;;gBAEI,eACZ,cACI,QAAO,OAAO,KAAK,OADvB,EAEI,QAAO,OAAO,KAAK,WAAnB,GAAgC,QAAO,aAAvC,IAFJ,EAGI,MAHJ,C;gBADY,yB;gBIrK+B,W;;kBAtBpD,W;kBAAA,IJgMY,IIhMZ,C;oBACH,mCAAe,WAAf,C;;oBAEA,kC;;kBAHJ,+B;;kBAqBF,kC;oBACE,MAAM,4BAAwB,8BAA2B,CAAE,UAAF,GAAE,QAAF,sBAAa,mBAAxC,CAAxB,C;;oBAHV,S;;gBJwKgC,+B;;cAJpB,oB;cAYG,kBAAO,MAAP,C;cACH,QAAO,sBAAa,MAAb,C;cACP,sCAAkB,MAAlB,I;cxCZJ,IAAI,CwCaA,IxCbJ,C;gBACI,K;eAEJ,YAAU,K;cACC,oCAAoB,SAApB,C;cAAA,mB;gBAAgC,K;eAA3C,aAAW,M;cACX,YAAU,M;cACV,YAAU,I;;YACL,a;;YAET,IAAI,SAAJ,C;cACI,0BAAiB,SAAjB,C;;;;OwCOD,kBAAe,gBAAf,C;;MIrLL,kC;QACE,MAAM,4BAAwB,8BAA2B,CAAE,OAAF,GAAE,QAAF,mBAAa,mBAAxC,CAAxB,C;;QAHV,S;;IJ0LA,OAAO,EAAG,W;EACd,C;;;EKhQsC,8D;IAAC,0C;IAA+B,kC;G;;;;;;4CAAtE,Y;IAAuC,6B;G;4CAAvC,Y;IAAsE,yB;G;8CAAtE,4C;IAAA,8BAAuC,yEAAvC,EAAsE,6DAAtE,C;G;0CAAA,Y;IAAA,OAAuC,iFAAvC,IAAsE,wDAAtE,O;G;0CAAA,Y;IAAA,c;IAAuC,kE;IAA+B,8D;IAAtE,a;G;wCAAA,iB;IAAA,4IAAuC,8DAAvC,IAAsE,sDAAtE,I;G;EAEA,mE;IACI,IAAI,kBAAiB,CAArB,C;MACI,OAAO,uBAAmB,EAAnB,EAAuB,CAAvB,C;;MAKP,kBAAgC,eAAd,aAAc,EAAa,oBAAb,C;MAChC,WAAW,aAAc,QAAO,mBAAS,CAAT,EAAY,WAAZ,CAAP,C;MACzB,IAAI,IAAK,OAAL,IAAe,aAAnB,C;QACI,OAAO,uBAAmB,IAAnB,EAAyB,WAAzB,C;;;IAKf,OAAO,gCAAqB,aAArB,EAAoC,aAApC,C;EACX,C;EAEA,uE;IACmB,Q;IACX,qBAAiB,SAAjB,C;MAAyC,iB;;MACjC,uBAAgB,CAAhB,I;IAFZ,eAGE,qBAAa,oBAAb,C;IAEF,kBAAkB,Q;IAClB,OAAO,cAAc,CAArB,C;;QAEQ,WAAW,aAAc,QAAO,mBAAS,CAAT,EAAY,WAAZ,CAAP,C;QACzB,IAAI,IAAK,OAAL,IAAe,aAAnB,C;UACI,OAAO,uBAAmB,IAAnB,EAAyB,WAAzB,C;;;MAKf,4BAAe,CAAf,I;;IAGJ,cAAc,C;IACd,OAAO,cAAc,CAArB,C;;QAEQ,aAAW,aAAc,QAAO,mBAAS,CAAT,EAAY,WAAZ,CAAP,C;QACzB,IAAI,MAAK,OAAL,IAAe,aAAnB,C;UACI,OAAO,uBAAmB,MAAnB,EAAyB,WAAzB,C;;;MAKf,iC;;IDuB2D,U;;MCjB7C,+B;;MDgBhB,gC;QACE,MAAM,4BAAwB,8BAA2B,CAAE,SAAF,CAAE,QAAF,qBAAa,mBAAxC,CAAxB,C;;QAHV,O;;ICVA,MAAM,4BAAwB,yBAAxB,C;EACV,C;EChEA,wD;IACI,IAAI,aAAa,OAAjB,C;MAA0B,OAAO,C;IlEoZxB,akElZT,GlEkZe,O;IAAN,YkElZT,GlEkZuB,c;I+DsEnB,WAAM,MAAO,eAAM,KAAN,EGxdjB,GlEkZsC,M+DsER,GAAe,KAAf,IAAb,CAAmC,K;IGrdlB,Q;IAF9B,SAAS,cAAU,IAAK,OAAf,EAAuB,IAAK,WAA5B,EAAwC,IAAK,WAA7C,C;IACT,iBAAiB,C;IACjB,qD;MACI,gBAAgB,iBAAM,KAAN,CAAa,I;MAC7B,IAAI,YAAY,GAAhB,C;QACI,iBAAiB,SAAjB,C;OAEJ,EPo7BwD,COp7BrD,iBPo7BqD,EOp7BrD,yBPo7BqD,UOp7B3B,OAAV,SAAU,C;;IlE0YrC,SkExYI,U;IAVJ,GlEmZA,uBAAc,EAAd,C;IkEvYA,OAAO,UAAU,SAAV,I;EACX,C;EAEA,8B;IACI,MAAM,4BAAwB,sCAAmC,EAAnC,gDAAxB,C;EACV,C;wGrEfA,yB;IAAA,kC;IAAA,kE;IAAA,6C;MAYI,eAAuB,a;K;IAZ3B,kDAcI,6B;MACI,OAAO,IAAK,Q;IAChB,C;IAhBJ,kDAkBI,oC;MACI,eAAa,K;IACjB,C;IApBJ;;;K;IAAA,wB;MAW2E,sC;K;GAX3E,C;EA6B+E,kD;IAAA,kC;G;yDAC3E,6B;IAAkE,yB;G;;;;;EAPtE,4B;IAM+E,2C;G;EsEnC/E,kC;IAAA,e;IAAA,iB;IAAA,uB;G;EAAA,gC;IAAA,mC;K;IACI,8D;IAAY,oE;IAEZ,iC;G;;EAFA,4C;IAAA,sB;IAAA,oC;G;;EAAY,+C;IAAA,sB;IAAA,uC;G;EAEZ,+B;IAAA,mC;IACI,oB;IAGI,aAAa,gBAAY,CAAZ,C;IACb,UAAU,eAAW,MAAX,C;IACV,WAAW,aAAS,MAAT,C;IAEX,GR4jCwD,CQ5jCpD,CR4jCoD,IQ5jC/C,S;IAET,gBAAa,IAAK,UAAS,CAAT,EAAY,IAAZ,CAAL,KAA0B,SAA9B,GAA0C,qCAA1C,GAA6D,kC;G;8CAG1E,Y;IAAsC,oB;G;;;;;;;EAb1C,2C;IAAA,sB;IAAA,0C;MAAA,yB;KAAA,mC;G;;;;;;EAHJ,4B;IAAA,kF;G;;EAAA,iC;IAAA,a;MAAA,kB;QAAA,yC;MAAA,qB;QAAA,4C;MAAA,QAAA,oE;;G;;ECYe,iF;IAAA,8B;IAAA,kC;IAAA,kC;IAAS,6B;G;2DAChB,Y;IAEI,OAAO,aAAgB,KAAP,8BAAO,EAAG,gBAAH,CAAhB,EAAyB,IAAzB,C;EACX,C;mEAEA,oB;ItFyEJ,IAAI,CsFxEU,iCtFwEd,C;MACI,csFzEkC,iC;MtF0ElC,MAAM,2BAAsB,OAAQ,WAA9B,C;KsFzEF,mBAAM,kBAAN,C;EACJ,C;;;;;EAhBR,wD;IAA4C,sB;MAAA,SvC+DR,C;IuC/DqB,sB;MAAA,SvC+DJ,KAAM,O;IuC9DzC,IAAM,IAAN,EACJ,M;IADV,cAAc,cAAM,YAAN,gC;IAEV,eAAU,CAAV,IAAe,WAAU,KAAM,OAA/B,C;MAA+C,SAAR,OAAQ,O;;MACxB,SAAf,OAAQ,OAAO,OAAM,MAAN,EAAc,SAAS,MAAT,IAAd,C;IAF3B,gB;IAKA,8D;IAYoC,gBAAd,IAAK,S;I5EsD3B,S4EtD4C,e;IAA5C,OAAO,oB5EuDA,S4EvDA,EAAuD,IAAvD,C;EACX,C;;;;;;;;ECvBA,iD;EAEA,C;EvEJA,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;EwEIA,sD;IAAoC,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAa,MAAb,I;IAC/D,IAAI,uCAAJ,C;MACI,OAAO,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;KAGX,SAAS,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACT,IAAI,OAAM,MAAV,C;MACI,qBAAqB,MAArB,C;KAER,C;EAEA,sD;IAAsC,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,WAAJ,GAAiB,MAAjB,I;IACjE,IAAI,uCAAJ,C;MACI,OAAO,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;KAGX,SAAS,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACT,IAAI,OAAM,MAAV,C;MACI,qBAAqB,MAArB,C;KAER,C;EAEA,8D;IAA0C,0B;MAAA,aAAkB,C;IAAG,0B;MAAA,aAAkB,GAAI,WAAJ,GAAiB,UAAjB,I;IAC7E,IAAI,uCAAJ,C;MACI,OAAO,wBAAU,GAAV,EAAe,UAAf,EAA2B,UAA3B,C;KAGX,SAAS,4BAAc,GAAd,EAAmB,UAAnB,EAA+B,UAA/B,C;IACT,IAAI,OAAM,UAAV,C;MACI,qBAAqB,UAArB,C;KAER,C;EAEA,0D;IAAwC,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAa,MAAb,I;IAM9C,Q;IALrB,IAAI,uCAAJ,C;MACI,OAAO,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;KAIX,OAAO,4BAAc,qDAAd,EAAsC,MAAtC,EAA8C,MAA9C,C;EACX,C;EAEA,0D;IAC0C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,WAAJ,GAAiB,MAAjB,I;IACrE,IAAI,uCAAJ,C;MACI,OAAO,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;KAGX,sBAAkB,CAAlB,C;;MlDwLc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;UkD1LA,QAAM,MtEQa,iBsERb,MtEQ6B,aAAhB,I;UsERnB,QAA4B,SAAS,aAAT,I;UAA3C,ezFuNG,MAAK,KAAI,CAAJ,EAAO,CAAP,C;UyFtNM,SAAd,MAAO,OAAO,OAAY,MAAO,aAAnB,EAAiC,QAAjC,EAA2C,aAA3C,C;UACd,gCAAe,QAAf,I;UlDwLI,IAAI,EkDvLR,sBlDuLQ,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IkD9LR,OAAO,a;EACX,C;EAEA,kE;IAC8C,0B;MAAA,aAAkB,C;IAAG,0B;MAAA,aAAkB,GAAI,WAAJ,GAAiB,UAAjB,I;IACjF,IAAI,uCAAJ,C;MACI,OAAO,4BAAc,GAAd,EAAmB,UAAnB,EAA+B,UAA/B,C;KAGX,sBAAkB,CAAlB,C;;MlDuKc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;UkDzKA,QAAM,MtETa,iBsESb,MtET6B,aAAhB,I;UsESnB,QAA4B,aAAa,aAAb,I;UAA3C,ezFsMG,MAAK,KAAI,CAAJ,EAAO,CAAP,C;UyFrMM,SAAd,MAAO,OAAO,OAAY,MAAO,aAAnB,EAAiC,QAAjC,EAA2C,aAA3C,C;UACd,gCAAe,QAAf,I;UlDuKI,IAAI,EkDtKR,0BlDsKQ,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IkD7KR,OAAO,a;EACX,C;EAEA,sD;IAEqB,Q;IAAjB,OAAO,wBAAU,qDAAV,EAAkC,MAAlC,EAA0C,MAA1C,C;EACX,C;EAEA,sD;IACI,IAAI,iCAAY,MAAhB,C;MAAwB,MAAM,8BAAyB,iCAA8B,mBAA9B,6BAAkD,MAAlD,WAAzB,C;IAC9B,iBAAa,CAAb,C;;MlDqJc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UkDlJV,SAAgB,iBlDsJD,OkDtJC,OAAmB,SAAS,QAAT,IAAnB,EAAoC,SAAS,QAAT,IAApC,C;UAChB,IAAI,KAAK,CAAT,C;YAAY,sBAAU,EAAV,I;UlDqJR,IAAI,EkDpJR,iBlDoJQ,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;EkD5JZ,C;EAGsC,uD;IAAA,mB;MAC9B,MAAM,8BAA0B,YAAS,cAAT,mCAA4C,WAAI,WAA1E,C;IACV,C;G;EAHJ,sD;IxE1FI,IAAI,EwE2FI,UAAU,GAAI,WxE3FlB,CAAJ,C;MACI,oCwE0F8B,6BxE1F9B,C;MAKA,CAAE,S;KwEyFN,OAAO,wBAAU,GAAI,OAAd,EAAsB,GAAI,WAAJ,GAAiB,MAAjB,IAAtB,EAA+C,MAA/C,C;EACX,C;EAEA,0D;IACI,gBAAgB,mB;IAChB,IAAI,qBAAJ,C;MAAqB,OAAO,E;IACjB,QAAwB,oBAAP,MAAO,C;IAAnC,WAA6C,CAA5B,SzF2KN,iBAAK,CAAL,MAAJ,GyF3KU,SzF2KV,GAAmB,CyF3KmB,S;IAC7C,wBAAU,GAAV,EAAe,MAAf,EAAuB,IAAvB,C;IACA,OAAO,I;EACX,C;EAEA,0D;IACI,gBAAgB,mB;IAChB,IAAI,qBAAJ,C;MAAqB,OAAO,E;IACjB,QAAwB,oBAAP,MAAO,C;IAAnC,WAA6C,CAA5B,SzFmKN,iBAAK,CAAL,MAAJ,GyFnKU,SzFmKV,GAAmB,CyFnKmB,S;IAC7C,wBAAU,GAAV,EAAe,MAAf,EAAuB,IAAvB,C;IACA,OAAO,I;EACX,C;EAEA,0D;IACI,gBAAgB,mB;IAChB,IAAI,qBAAJ,C;MAAqB,OAAO,E;IACjB,QAAwB,oBAAP,MAAO,C;IAAnC,WAA6C,CAA5B,SzF2JN,iBAAK,CAAL,MAAJ,GyF3JU,SzF2JV,GAAmB,CyF3JmB,S;IAC7C,wBAAU,GAAV,EAAe,MAAf,EAAuB,IAAvB,C;IACA,OAAO,I;EACX,C;;;;;SCjHQ,Y;MAAQ,yC;K;SACR,oB;MACI,IAAI,+CAAJ,C;QACI,MAAM,8BAAyB,8BAAzB,C;OAEd,C;;mCASJ,8E;IAoBI,sB;MAAA,W;IACA,mB;MAAA,Q;IACA,mB;MAAA,8B;WAtBJ,qK;G;8BA+BA,Y;IAGI,OAAO,iB;EACX,C;4BAEA,Y;IAGI,OAAO,e;EACX,C;6BAEA,Y;IAGI,OAAO,gB;EACX,C;8BAEA,Y;IAGI,OAAO,iB;EACX,C;+BAEA,Y;IAGI,OAAO,kB;EACX,C;sCAEA,+B;IAGI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;sCAEA,+B;IAGI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;sCAEA,+B;IAGI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;sCAEA,+B;IAGI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;sCAEA,+B;IAGI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;sCAEA,+B;IAGI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;sCAEA,uB;IAGI,OAAO,mBAAU,GAAV,EAAe,MAAf,C;EACX,C;0CAEA,+B;IAGI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;0CAEA,+B;IAGI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;0CAEA,+B;IAGI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;0CAEA,+B;IAGI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;0CAEA,+B;IAGI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;0CAEA,+B;IAGI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;0CAEA,uB;IAGI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,C;EACX,C;sCAEA,+B;IAEI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;sCAEA,+B;IAEI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;sCAEA,+B;IAEI,OAAO,mBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACX,C;0CAEA,+B;IAEI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;0CAEA,+B;IAEI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;0CAEA,+B;IAEI,OAAO,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;mCAOA,kB;IAYI,OAAO,eAAO,MAAP,C;EACX,C;;;;;;EzE5NJ,mF;EAAA,yE;EAAA,mD;IAOgB,sC;IAAS,gC;G;EAPzB,4CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;EiEQsB,kC;IA2VlB,gC;IAxVe,uBAAY,MAAZ,EAAoB,MAApB,C;G;;;SACkB,Y;MAAQ,OAAA,WAAO,KAAK,O;K;;;;SAEpB,Y;MAAQ,8BAAiB,iB;K;;;;SAStD,Y;MAAQ,yC;K;SACR,oB;MACI,IAAI,+CAAJ,C;QACI,MAAM,8BAAyB,8BAAzB,C;OAEd,C;;8CAEJ,4D;IACY,Q;IAAR,OAAwB,OAAhB,sDAAgB,EAAO,WAAP,EAAoB,iBAApB,EAAuC,MAAvC,EAA+C,GAA/C,EAAoD,GAApD,C;EAC5B,C;+BAEA,Y;IACI,OAAO,kB;EACX,C;yCAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACrB,C;6CAEA,+B;IAEY,Q;IAAR,OAAwB,iBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EAC5B,C;6CAEA,uB;IAEY,Q;IAAR,OAAwB,iBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,C;EAC5B,C;EAMyB,qC;IAAE,kC;EAA4B,C;EACR,uC;IAAE,MAAM,8BAA0B,EAA1B,C;EAA8B,C;yCALrF,+B;IAOK,Q;IALD,IAAI,C/DO8B,qBAAgB,iBAAhB,I+DP9B,IAAgB,MAApB,C;MAA4B,MAAM,2BAAsB,kC/DOtB,qBAAgB,iBAAhB,I+DPsB,mBAAsD,MAAtD,WAAtB,C;KAClC,IAAI,SAAS,GAAI,WAAjB,C;MAA6B,MAAM,8BAAyB,2CAAwC,MAAxC,0BAAkE,GAAI,WAA/F,C;IjElDvC,IAAI,EiEmDQ,UAAU,CjEnDlB,CAAJ,C;MACI,qCiEkDqB,yBjElDrB,C;MAKA,CAAE,S;KANN,IAAI,EiEoDQ,UAAS,MAAT,SAAmB,GAAI,WjEpD/B,CAAJ,C;MACI,uCiEmD2C,2BjEnD3C,C;MAKA,GAAE,S;KiEgDe,aAAhB,sDAAgB,EAAU,GAAI,OAAd,EAAsB,GAAI,WAAJ,GAAiB,MAAjB,IAAtB,EAA+C,MAA/C,C;EACrB,C;6CAEA,+B;IAKK,Q;IAHD,oB/DHkC,qBAAgB,iBAAhB,I;I+DIlC,IAAI,kBAAiB,CAArB,C;MAAwB,OAAO,E;IAC/B,WlF0MG,MAAK,KkF1MS,MlF0MT,EkF1MiB,alF0MjB,C;IkFzMS,aAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,IAAvB,C;IACjB,OAAO,I;EACX,C;yCAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACrB,C;6CAEA,+B;IAEY,Q;IAAR,OAAwB,iBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EAC5B,C;yCAEA,uB;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,C;EACrB,C;sCAEA,2B;IACI,UAAU,oBAAY,oBAAO,MAAnB,EAA2B,KAA3B,EAAkC,GAAlC,C;IACV,IAAI,QAAO,GAAX,C;MAAgB,MAAM,2BAAsB,+CAAtB,C;IACtB,OAAO,I;EACX,C;sCAEA,e;IACI,OAAW,WAAJ,GAAiB,oBAAO,MAAP,CAAjB,GAAqC,oBAAO,GAAP,EAAY,CAAZ,EAAe,GAAI,OAAnB,C;EAChD,C;sCAEA,2B;IACI,UAAU,kBAAY,GAAZ,EAAiB,KAAjB,EAAwB,GAAxB,C;IAEV,IAAI,QAAO,GAAX,C;MAAgB,MAAM,2BAAsB,+CAAtB,C;IACtB,OAAO,I;EACX,C;sCAEA,a;IACK,Q;IAAgB,OAAhB,sDAAgB,EAAO,CAAP,C;IACjB,OAAO,I;EACX,C;qCAEA,iC;IAMK,Q;IAAgB,aAAhB,sDAAgB,EAAW,KAAX,EAAkB,MAAlB,EAA0B,MAA1B,C;EACrB,C;qCAEA,+B;IAMK,Q;IAAgB,cAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACrB,C;iCAEA,Y;IAEY,Q;IAAR,OAAwB,YAAhB,sDAAgB,C;EAC5B,C;+BAEA,Y;IAEY,Q;IAAR,OAAwB,UAAhB,sDAAgB,C;EAC5B,C;iCAEA,Y;IAEY,Q;IAAR,OAAwB,YAAhB,sDAAgB,C;EAC5B,C;kCAEA,Y;IAEY,Q;IAAR,OAAwB,aAAhB,sDAAgB,C;EAC5B,C;yCAEA,+B;IAEK,Q;IAAgB,YAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACrB,C;yCAEA,+B;IAEK,Q;IAAgB,YAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACrB,C;yCAEA,+B;IAEK,Q;IAAgB,YAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACrB,C;yCAEA,+B;IAEK,Q;IAAgB,YAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACrB,C;yCAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACrB,C;yCAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;EACrB,C;6CAEA,+B;IAEY,Q;IAAR,OAAwB,gBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EAC5B,C;6CAEA,+B;IAEY,Q;IAAR,OAAwB,gBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EAC5B,C;6CAEA,+B;IAEY,Q;IAAR,OAAwB,gBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EAC5B,C;6CAEA,+B;IAEY,Q;IAAR,OAAwB,gBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EAC5B,C;6CAEA,+B;IAEY,Q;IAAR,OAAwB,gBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EAC5B,C;6CAEA,+B;IAEY,Q;IAAR,OAAwB,iBAAhB,sDAAgB,EAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EAC5B,C;sCAEA,kB;IAEY,Q;IAAR,OAAuB,SAAf,qDAAe,EAAO,MAAP,C;EAC3B,C;gCAEA,Y;IAEY,Q;IAAR,OAAwB,WAAhB,sDAAgB,C;EAC5B,C;0CAEA,a;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAW,CAAX,C;EACrB,C;wCAEA,a;IAEK,Q;IAAgB,WAAhB,sDAAgB,EAAS,CAAT,C;EACrB,C;0CAEA,a;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAW,CAAX,C;EACrB,C;2CAEA,a;IAEK,Q;IAAgB,cAAhB,sDAAgB,EAAY,CAAZ,C;EACrB,C;0CAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACrB,C;0CAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACrB,C;0CAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACrB,C;0CAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACrB,C;0CAEA,+B;IAEK,Q;IAAgB,aAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACrB,C;0CAEA,+B;IAEK,Q;IAAgB,cAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACrB,C;0CAEA,uB;IAEK,Q;IAAgB,cAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,C;EACrB,C;oCAEA,gB;IAEK,Q;IAAgB,OAAhB,sDAAgB,EAAK,CAAL,EAAQ,CAAR,C;EACrB,C;yCAEA,a;IAEK,Q;IAAgB,YAAhB,sDAAgB,EAAU,CAAV,C;EACrB,C;2CAEA,uB;IAEK,Q;IAAgB,cAAhB,sDAAgB,EAAW,GAAX,EAAgB,MAAhB,C;IACjB,OAAO,M;EACX,C;6BAEA,Y;EACA,C;oCAEA,Y;IAKW,Q;IAHP,mBAAmB,iB;IACnB,oBAAoB,kB;IAGhB,qBAAgB,aAAhB,C;MAAiC,uD;SACjC,qBAAgB,CAAhB,IAAqB,kBAAiB,cAAQ,WAA9C,C;MAAmE,OAAP,WAAO,K;;MAC3D,oBAAS,cAAT,EAAkB,YAAlB,EAAgC,gBAAgB,YAAhB,IAAhC,C;IAHZ,W;EAKJ,C;oCAEA,Y;IAKW,Q;IAHP,oBAAoB,kB;IACpB,YAAY,U;IAGR,sBAAiB,KAAjB,C;MAA0B,uD;SAC1B,sBAAiB,CAAjB,IAAsB,UAAS,cAAQ,WAAvC,C;MAA4D,OAAP,WAAO,K;;MACpD,oBAAS,cAAT,EAAkB,aAAlB,EAAiC,QAAQ,aAAR,IAAjC,C;IAHZ,W;EAKJ,C;0IAEA,yB;IjF1OJ,iF;IiF0OI,wB;MAOI,WAAW,mB;MACX,SAAS,MAAM,IAAN,C;MjFxOb,IAAI,EiFyOM,MAAM,CjFzOZ,CAAJ,C;QACI,ciFwOiB,qE;QjFvOjB,MAAM,2BAAsB,OAAQ,WAA9B,C;OiFwON,qBAAQ,EAAR,C;MACA,OAAO,E;IACX,C;GAZA,C;4IAcA,yB;IjFxPJ,iF;IiFwPI,wB;MAOI,WAAW,mB;MACX,SAAS,MAAM,IAAN,C;MjFtPb,IAAI,EiFuPM,MAAM,CjFvPZ,CAAJ,C;QACI,ciFsPiB,qE;QjFrPjB,MAAM,2BAAsB,OAAQ,WAA9B,C;OAFV,IAAI,EiFwPM,O/DhR6B,aAAQ,kBAAR,I+DgR7B,CjFxPN,CAAJ,C;QACI,gBiFuP8B,sE/DhRK,aAAQ,kBAAR,I+DgRL,C;QjFtP9B,MAAM,2BAAsB,SAAQ,WAA9B,C;OiFuPN,2BAAc,EAAd,C;MACA,OAAO,E;IACX,C;GAbA,C;uCAeA,gB;IACI,kBAAY,IAAZ,C;EACJ,C;6BAEA,Y;IACI,MAAM,mCAA8B,wCAA9B,C;EACV,C;gCAEA,Y;IACI,+B/DnSkC,qBAAgB,iBAAhB,I+DmSlC,uB/D9RmC,aAAQ,kBAAR,I+D8RnC,sBAA2E,aAA3E,oB/D7S2B,gBAAW,UAAX,I+D6S3B,O;G;EAEJ,8B;IAAA,kC;IAUI,qBAA0B,gBAAY,CAAZ,C;IAC1B,uBAA4B,aAAS,kBAAT,C;IAE5B,aAAmB,aAAS,8BAAO,MAAhB,EAAuB,IAAvB,C;IAEnB,sDAGuE,GAHvE,C;IA4BA,2D;IAUA,iBAA6C,iC;G;;;SA7CzC,Y;MAAQ,Q;K;;EAU4B,yD;IAAS,gC;G;oEAC7C,Y;IACI,OAAO,aAAS,8BAAiB,eAAM,IAAN,CAA1B,EAAsD,IAAtD,C;EACX,C;0EAEA,oB;IACyC,gBAAxB,uDAAc,QAAd,C;IvE7SzB,SuE8SgB,iB;IvE9ShB,SuE+SgB,Q;IAFJ,OvE5SL,S;EuEgTC,C;EAK0C,yF;IAAA,mB;MAAE,wEAA+D,gBAAS,eAAxE,M;IAA0F,C;G;EACjG,2E;IAAE,uE;EAAiE,C;6EAJxG,oB;IACU,0DAAiB,QAAjB,C;IjE5XlB,IAAI,EiE8XgB,QAAS,eAAT,KAA2B,CjE9X3C,CAAJ,C;MACI,qCiE6X8C,uEjE7X9C,C;MAKA,CAAE,S;KANN,IAAI,EiE+XgB,QAAS,OAAT,QjE/XhB,CAAJ,C;MACI,uCiE8XyC,+DjE9XzC,C;MAKA,GAAE,S;KiE0XE,C;4EAEA,oB;IACI,8BAAiB,cAAK,QAAS,OAAd,C;IACjB,QAAS,iB;EACb,C;;;;;EAGsC,mD;IAAS,qB;G;6DAC/C,Y;IACI,OAAO,aAAS,8BAAiB,eAAM,IAAN,CAA1B,EAAsD,IAAtD,C;EACX,C;sEAEA,oB;IACI,8BAAiB,cAAK,QAAS,OAAd,C;EACrB,C;;;;;;;;;;;EAlDR,0C;IAAA,yC;MAAA,wB;KAAA,kC;G;;;;;;EAyDJ,sD;IAAuC,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,WAAJ,GAAiB,MAAjB,I;I/DvBzD,aAAM,gB;IAAN,YAAc,sB;I+DyBnB,IAAI,C/DzB6B,uB+DyB7B,GAAe,KAAf,cAAJ,C;MACI,MAAM,iBAAa,yDAAb,C;KAGH,SAAP,MAAO,OAAY,KAAZ,iB;I/D7BX,e;IACA,+BAAa,EAAb,C;E+D+BJ,C;EAEA,sD;IAA2C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,WAAJ,GAAiB,MAAjB,I;I/DlC7D,aAAM,gB;IAAN,YAAc,sB;I+DoCnB,IAAI,C/DpC6B,uB+DoC7B,GAAe,KAAf,cAAJ,C;MACI,MAAM,iBAAa,yDAAb,C;KAGH,SAAP,MAAO,OAAY,KAAZ,iB;I/DxCX,e;IACA,+BAAa,EAAb,C;E+D0CJ,C;EAEA,0D;IAA2C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,WAAJ,GAAiB,MAAjB,I;IACtE,IAAI,E/DjEsB,0BAAgB,sB+DiEtC,CAAJ,C;MAAgB,OAAO,E;IACR,Q/DtXuB,0BAAgB,sBAAhB,I;I+DsXtC,elFvKO,MAAK,KkFuKS,MlFvKT,EAAO,CAAP,C;IkFwKZ,wBAAU,GAAV,EAAe,MAAf,EAAuB,QAAvB,C;IACA,OAAO,Q;EACX,C;EAEA,0D;IAA+C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,WAAJ,GAAiB,MAAjB,I;IAC1E,IAAI,E/DxEsB,0BAAgB,sB+DwEtC,CAAJ,C;MAAgB,OAAO,E;IACR,Q/D7XuB,0BAAgB,sBAAhB,I;I+D6XtC,elF9KO,MAAK,KkF8KS,MlF9KT,EAAO,CAAP,C;IkF+KZ,wBAAU,GAAV,EAAe,MAAf,EAAuB,QAAvB,C;IACA,OAAO,Q;EACX,C;EAEA,uD;IAAwC,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,W;I/D1C9D,aAAM,gB;IAAN,YAAc,uB;I+D4CnB,IAAI,C/D5C8B,e+D4C9B,GAAe,KAAf,cAAJ,C;MACI,MAAM,+BAA2B,qDAA3B,C;KAGN,cAAO,MAAP,kBAA+B,KAA/B,C;I/DhDR,e;IACA,gCAAc,EAAd,C;E+DkDJ,C;EAEA,uD;IAA4C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,WAAJ,GAAiB,MAAjB,I;I/DrD9D,aAAM,gB;IAAN,gBAAc,uB;I+DuDnB,IAAI,C/DvD8B,e+DuD9B,GAAe,SAAf,cAAJ,C;MACI,MAAM,+BAA2B,qDAA3B,C;KAGN,cAAO,MAAP,kBAA+B,SAA/B,C;I/D3DR,e;IACA,gCAAc,EAAd,C;E+D6DJ,C;4GAEA,4B;I/DhEa,aAAM,gB;IAAN,YAAc,uB;IAAvB,S+DsEI,MAAM,MAAO,eAAM,KAAN,E/DtEqB,e+DsER,GAAe,KAAf,IAAb,CAAmC,KAAhD,C;I/DrEJ,gCAAc,EAAd,C;I+DoEA,O/DnEO,E;E+DsEX,C;0GAEA,4B;I/D3Fa,aAAM,gB;IAAN,YAAc,sB;IAAvB,S+DiGI,MAAM,MAAO,eAAM,KAAN,E/DjGoB,uB+DiGP,GAAe,KAAf,IAAb,CAAmC,KAAhD,C;I/DhGJ,+BAAa,EAAb,C;I+D+FA,O/D9FO,E;E+DiGX,C;8HAGA,yB;IAAA,8B;IAAA,mC;M/DrFa,aAAM,gB;MAAN,YAAc,uB;MAAd,mBAA6B,e;MAAtC,S+D2FI,MAAM,mBAAU,MAAO,KAAK,OAAtB,EAA8B,MAAO,KAAK,WAAZ,GAAyB,KAAzB,IAA9B,EAA8D,eAAe,KAAf,IAA9D,CAAN,C;M/D1FJ,gCAAc,EAAd,C;M+DyFA,O/DxFO,E;I+D2FX,C;GARA,C;4HAUA,yB;IAAA,8B;IAAA,mC;M/DhHa,aAAM,gB;MAAN,YAAc,sB;MAAd,mBAA4B,uB;MAArC,S+DsHI,MAAM,mBAAU,MAAO,KAAK,OAAtB,EAA8B,MAAO,KAAK,WAAZ,GAAyB,KAAzB,IAA9B,EAA8D,eAAe,KAAf,IAA9D,CAAN,C;M/DrHJ,+BAAa,EAAb,C;M+DoHA,O/DnHO,E;I+DsHX,C;GARA,C;;;wCS7eI,a;IAGI,mBAAW,CAAX,C;EACJ,C;sCAEA,a;IAGI,iBAAS,CAAT,C;EACJ,C;uCAEA,a;IAGI,kBAAU,CAAV,C;EACJ,C;wCAEA,a;IAGI,mBAAW,CAAX,C;EACJ,C;yCAEA,a;IAGI,oBAAY,CAAZ,C;EACJ,C;wCAGA,+B;IAGI,oBAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACJ,C;wCAEA,+B;IAGI,oBAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACJ,C;wCAEA,+B;IAGI,oBAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACJ,C;wCAEA,+B;IAGI,oBAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACJ,C;wCAEA,+B;IAGI,oBAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACJ,C;wCAEA,+B;IAGI,oBAAW,GAAX,EAAgB,MAAhB,EAAwB,MAAxB,C;EACJ,C;wCAEA,uB;IAGI,oBAAW,GAAX,EAAgB,MAAhB,C;EACJ,C;kCAIA,gB;IAGI,aAAK,CAAL,EAAQ,CAAR,C;EACJ,C;;;;;;;;;ECnFJ,6C;IAA6B,8B;MAAA,iBtEkBsB,C;IsElBC,6BAAkB,cAAlB,EAAkC,mCAAY,KAA9C,C;G;ECHpD,gC;IACI,OAAO,cAAU,cAAK,OAAf,EAAuB,cAAK,WAA5B,EAAwC,cAAK,WAA7C,C;EACX,C;EAEA,yD;IACI,cAAqB,YAAP,gBAAO,C;IACrB,UAAU,sB;IACV,UAAU,uB;IAEV,OAAO,MAAM,GAAb,IACQ,Ofk7BiD,Cel7BzC,Gfk7ByC,Cen7BzD,KACwB,SADxB,C;MAEI,iB;;IAGJ,YAAY,sB;IACZ,oCAAkB,GAAlB,C;IACA,OAAO,MAAM,KAAN,I;EACX,C;EAEA,uE;IACI,cAAqB,YAAP,gBAAO,C;IACrB,UAAU,sB;IACV,UAAU,uB;IAEV,OAAO,MAAM,GAAb,C;MACI,QAAQ,Ofm6B6C,Cen6BrC,Gfm6BqC,C;Mel6BrD,IAAI,MAAK,UAAL,IAAmB,MAAK,UAA5B,C;QAAwC,K;MACxC,iB;;IAGJ,YAAY,sB;IACZ,oCAAkB,GAAlB,C;IACA,OAAO,MAAM,KAAN,I;EACX,C;EAGA,2E;I5FsDI,IAAI,E4FnDE,UAAU,C5FmDZ,CAAJ,C;MACI,cAdW,e;MAeX,MAAM,2BAAsB,OAAQ,WAA9B,C;KAFV,IAAI,E4FlDE,UAAU,C5FkDZ,CAAJ,C;MACI,gBAdW,e;MAeX,MAAM,2BAAsB,SAAQ,WAA9B,C;KAFV,IAAI,E4FjDE,UAAS,MAAT,SAAmB,GAAI,O5FiDzB,CAAJ,C;MACI,gBAdW,e;MAeX,MAAM,2BAAsB,SAAQ,WAA9B,C;K4FdN,Q;IAPJ,YAAmB,YAAP,gBAAO,C;IACnB,YAAY,sB;IACZ,QAAQ,K;IACE,c;IAAI,Q1EbwB,0BAAgB,sBAAhB,I;I0EatC,UAAU,S7FkMH,MAAK,K6FjO2C,M7FiO3C,EAAO,CAAP,C6FlMF,I;IAEV,Y;MAAO,iBAAI,G;;mBACO,Kf+2BuC,Ce/2BjC,Cf+2BiC,Cej5BlC,c;;;MAmCnB,a;;IAGJ,aAAa,IAAI,KAAJ,I;IACb,eAAe,cAAI,OAvCuB,GAuC3B,gC;IACf,QAAS,KAAI,KAAM,UAAS,KAAT,EAAgB,GAAhB,CAAV,EAxCsC,MAwCtC,C;IACT,oCAAkB,CAAlB,C;IAzCA,OA2CO,M;EA1CX,C;EAEA,yF;I5F4CI,IAAI,E4FzCE,UAAU,C5FyCZ,CAAJ,C;MACI,cAdW,e;MAeX,MAAM,2BAAsB,OAAQ,WAA9B,C;KAFV,IAAI,E4FxCE,UAAU,C5FwCZ,CAAJ,C;MACI,gBAdW,e;MAeX,MAAM,2BAAsB,SAAQ,WAA9B,C;KAFV,IAAI,E4FvCE,UAAS,MAAT,SAAmB,GAAI,O5FuCzB,CAAJ,C;MACI,gBAdW,e;MAeX,MAAM,2BAAsB,SAAQ,WAA9B,C;KAFV,IAAI,E4FtCE,eAAc,U5FsChB,CAAJ,C;MACI,gBAdW,e;MAeX,MAAM,2BAAsB,SAAQ,WAA9B,C;K4FdN,Q;IAPJ,YAAmB,YAAP,gBAAO,C;IACnB,YAAY,sB;IACZ,QAAQ,K;IACE,c;IAAI,Q1EbwB,0BAAgB,sBAAhB,I;I0EatC,UAAU,S7FkMH,MAAK,K6FtNgE,M7FsNhE,EAAO,CAAP,C6FlMF,I;IAEV,Y;MAAO,iBAAI,G;;QACH,SAAU,Kf+2BuC,Ce/2BjC,Cf+2BiC,C;mBet4BlC,qBAAoB,iB;;;MAwBvC,a;;IAGJ,aAAa,IAAI,KAAJ,I;IACb,eAAe,cAAI,OA5B4C,GA4BhD,gC;IACf,QAAS,KAAI,KAAM,UAAS,KAAT,EAAgB,GAAhB,CAAV,EA7B2D,MA6B3D,C;IACT,oCAAkB,CAAlB,C;IA9BA,OAgCO,M;EA/BX,C;EAEA,6D;IAmCI,YAAmB,YAAP,gBAAO,C;IACnB,YAAQ,sBAAR,C;IACA,sBAAkB,CAAlB,C;IzD2GA,WAAwB,mByD/IkB,GzD+IlB,EAAiB,CAAjB,EAAoB,IAApB,C;;MAEpB,Y;QACS,YAAM,I;QyD3GT,cAAN,KAAM,EAAW,KAAX,EAAkB,CAAlB,C;QACN,YAAY,G;QACF,QAAM,OAAI,K1EjCe,S0EiCf,K1EjCuB,cAAR,I0EiCnB,K;QAAN,QAAgC,uB;QAA1C,U7FyKG,MAAK,KAAI,CAAJ,EAAO,CAAP,C;Q6FvKR,Y;UAAO,iBAAI,G;;qBfu1B0C,Met1B7B,Gfs1B6B,Cel4BlC,c;;;UA6Cf,iB;;QAGJ,WAAW,MAAI,KAAJ,I;QAEE,YAAb,KAAM,OAAO,CAAc,KAAU,eAAS,KAAT,EAAgB,GAAhB,CAAV,EAA8B,KAAM,cAApC,C;QAC3B,KAAM,uBAAc,IAAd,C;QACN,gCAAe,IAAf,I;cAEA,CAAA,K1E9CmC,S0E8CnC,K1E9C2C,cAAR,I0E8CnC,MAAwB,CAAxB,IAA6B,MAAI,G;;QzD6F7B,OAAO,mByDnJ2B,GzDmJ3B,EAAiB,CAAjB,EAAoB,IAApB,C;;;MAGX,iByDtJsC,GzDsJtC,EAAe,IAAf,C;;IyD7FJ,oCAAkB,GAAlB,C;IAzDA,OA0DO,a;EAzDX,C;EAEA,2E;I5F6BI,IAAI,E4F5BE,eAAc,U5F4BhB,CAAJ,C;MACI,cAdW,e;MAeX,MAAM,2BAAsB,OAAQ,WAA9B,C;K4FAV,YAAmB,YAAP,gBAAO,C;IACnB,YAAQ,sBAAR,C;IACA,sBAAkB,CAAlB,C;IzD2GA,WAAwB,mByDzIuC,GzDyIvC,EAAiB,CAAjB,EAAoB,IAApB,C;;MAEpB,Y;QACS,YAAM,I;QyD3GT,cAAN,KAAM,EAAW,KAAX,EAAkB,CAAlB,C;QACN,YAAY,G;QACF,QAAM,OAAI,K1EjCe,S0EiCf,K1EjCuB,cAAR,I0EiCnB,K;QAAN,QAAgC,uB;QAA1C,U7FyKG,MAAK,KAAI,CAAJ,EAAO,CAAP,C;Q6FvKR,Y;UAAO,iBAAI,G;;YACH,Sfs1B6C,Met1B7B,Gfs1B6B,C;qBe53BlC,qBAAoB,iB;;;UAuCnC,iB;;QAGJ,WAAW,MAAI,KAAJ,I;QAEE,YAAb,KAAM,OAAO,CAAc,KAAU,eAAS,KAAT,EAAgB,GAAhB,CAAV,EAA8B,KAAM,cAApC,C;QAC3B,KAAM,uBAAc,IAAd,C;QACN,gCAAe,IAAf,I;cAEA,CAAA,K1E9CmC,S0E8CnC,K1E9C2C,cAAR,I0E8CnC,MAAwB,CAAxB,IAA6B,MAAI,G;;QzD6F7B,OAAO,mByD7IgD,GzD6IhD,EAAiB,CAAjB,EAAoB,IAApB,C;;;MAGX,iByDhJ2D,GzDgJ3D,EAAe,IAAf,C;;IyD7FJ,oCAAkB,GAAlB,C;IAnDA,OAoDO,a;EAnDX,C;sBAEA,yB;I7FkMA,iB;I6FlMA,4D;MAWQ,IAIe,I;MAXnB,YAAmB,YAAP,gBAAO,C;MACnB,YAAY,sB;MACZ,QAAQ,K;MACE,c;MAAI,Q1EbwB,0BAAgB,sBAAhB,I;M0EatC,UAAU,S7FkMH,MAAK,K6FlMQ,M7FkMR,EAAO,CAAP,C6FlMF,I;MAEV,OAAO,IAAI,GAAX,KACQ,UAAU,Kf+2BuC,Ce/2BjC,Cf+2BiC,Ce/2BjD,CADR,C;QAEI,a;;MAGJ,aAAa,IAAI,KAAJ,I;MACb,eAAe,cAAI,UAAJ,gC;MACf,QAAS,KAAI,KAAM,UAAS,KAAT,EAAgB,GAAhB,CAAV,EAAgC,MAAhC,C;MACT,oCAAkB,CAAlB,C;MAEA,OAAO,M;IACX,C;GApBA,C;wBAsBA,yB;I7F4KA,iB;IoCnEA,gF;IAAA,4E;IyDzGA,4C;MAGI,YAAmB,YAAP,gBAAO,C;MACnB,YAAQ,sBAAR,C;MACA,sBAAkB,CAAlB,C;MzD2GA,WAAwB,iByDzGxB,GzDyGwB,EAAiB,CAAjB,EAAoB,IAApB,C;;QAEpB,Y;UACS,YAAM,I;UyD3GT,cAAN,KAAM,EAAW,KAAX,EAAkB,CAAlB,C;UACN,YAAY,G;UACF,QAAM,OAAI,K1EjCe,S0EiCf,K1EjCuB,cAAR,I0EiCnB,K;UAAN,QAAgC,uB;UAA1C,U7FyKG,MAAK,KAAI,CAAJ,EAAO,CAAP,C;U6FvKR,OAAO,MAAI,GAAX,KACQ,Ufs1B6C,Met1B7B,Gfs1B6B,Cet1B7C,CADR,C;YAEI,iB;;UAGJ,WAAW,MAAI,KAAJ,I;UAEE,YAAb,KAAM,OAAO,CAAc,KAAU,eAAS,KAAT,EAAgB,GAAhB,CAAV,EAA8B,KAAM,cAApC,C;UAC3B,KAAM,uBAAc,IAAd,C;UACN,gCAAe,IAAf,I;gBAEA,CAAA,K1E9CmC,S0E8CnC,K1E9C2C,cAAR,I0E8CnC,MAAwB,CAAxB,IAA6B,MAAI,G;;UzD6F7B,OAAO,iByD7Gf,GzD6Ge,EAAiB,CAAjB,EAAoB,IAApB,C;;;QAGX,eyDhHJ,GzDgHI,EAAe,IAAf,C;;MyD7FJ,oCAAkB,GAAlB,C;MACA,OAAO,a;IACX,C;GA5BA,C;ECtFA,kD;IAKoC,sB;MAAA,S/EGlB,C;I+EH+B,sB;MAAA,S/EI/B,KAAM,O;I+EJsC,uB;MAAA,U/EKvC,sBAAS,M;I+EJ5B,IAAI,SAAS,CAAT,IAAc,SAAS,CAAvB,IAA4B,UAAS,MAAT,QAAkB,KAAM,OAAxD,C;MACI,aAAa,MAAb,EAAqB,MAArB,EAA6B,KAA7B,C;KAGJ,SAC0B,K;IAC1B,mBAAmB,EAAG,WAAH,GAAgB,MAAhB,I;IACnB,aAAa,EAAG,OAAO,OAAM,YAAN,EAAoB,eAAe,MAAf,IAApB,C;IAEvB,WACW,aAAgB,KAAP,8BAAO,EAAG,MAAH,CAAhB,EAA4B,IAA5B,C;IACX,IAAK,e;IACL,aAAa,oBAAe,IAAf,EAAqB,mCAAY,8BAAjC,C;IAEb,OAA4B,OAArB,OAAQ,aAAa,EAAO,MAAP,EAAe,UAAf,C;EAChC,C;EAEA,6C;I7FII,IAAI,E6FHI,UAAU,C7FGd,CAAJ,C;M6FHuB,MAAM,8BAA0B,+CAA1B,C;K7FG7B,IAAI,E6FFI,UAAU,C7FEd,CAAJ,C;M6FFuB,MAAM,8BAA0B,+CAA1B,C;K7FE7B,IAAI,E6FDI,UAAS,MAAT,SAAmB,KAAM,O7FC7B,CAAJ,C;M6FAI,MAAM,8BAA0B,qEAA2D,YAA3D,MAA1B,C;KAGV,MAAM,gC;EACV,C;EAEA,qD;IAK6B,IACjB,I;IALR,aAAa,gB;I7FPb,IAAI,E6FQI,aAAY,MAAZ,SAAsB,GAAI,O7FR9B,CAAJ,C;MACI,cAda,qB;MAeb,MAAM,8BAAyB,OAAQ,WAAjC,C;K6FQV,eAAe,S;IACf,oBAAiB,CAAjB,aAAyB,MAAzB,a;MACI,IAAI,eAAJ,EAAI,uBAAJ,UAAkB,qBAAK,QAAL,C;;EAE1B,C;EC/C8B,qC;IAAyD,qBAAU,OAAV,EAAmB,KAAnB,C;;G;;;;;;EACnF,0C;IAAA,qD;IAAsC,wBAAK,OAAL,EAAc,IAAd,C;IAAtC,Y;G;EAG2B,+B;qBAAkD,O;;G;;;;;;;EZIjF,8C;IAC8C,mB;MAAA,MAAW,U;IAAyB,6BAAS,+BAAQ,iBAAQ,QAAR,CAAjB,EAAoC,GAApC,C;G;EAElF,mD;IAC4B,wB;MAAA,WAAmB,O;IAA0B,mB;MAAA,MAAW,U;IAChF,OAAO,sBAAS,GAAT,EAAc,+BAAQ,iBAAQ,QAAR,CAAtB,EAAyC,GAAzC,C;EACX,C;;;EAwBA,2C;IAAgD,qB;MAAA,QAAiB,I;IAG7D,IAAI,WAAW,OAAZ,WAAY,IAA4B,WAA3C,C;MACI,eAAR,OAAqB,CAAb,eAAa,C;MACb,IAAI,QAAO,YAAP,KAAuB,SAA3B,C;QAAsC,MAAM,2BAAsB,gFAAtB,C;MAC5C,WAAW,QAAO,Y;MAClB,mBAAmB,MAAa,QAAO,IAAK,UAAZ,C;MAGhC,OAAW,KAAJ,GAAW,IAAK,MAAK,YAAL,EAAmB,QAAnB,EAA6B,UAA7B,CAAhB,GACF,IAAK,MAAK,YAAL,EAAmB,QAAnB,C;KAGd,OAAW,KAAJ,GAAW,gBAAY,QAAZ,EAAsB,UAAtB,CAAX,GAAkD,gBAAY,QAAZ,C;EAC7D,C;4GAEA,yB;IAoBA,sF;IAAA,qB;IApBA,4C;MAwBmE,Q;;QAtBpD,U;QAAA,W;UACH,kCAAe,WAAf,C;;UAEA,iC;;QAHJ,a;;QAqBF,gC;UACE,MAAM,iCAAwB,8BAA2B,CAAE,OAAF,CAAE,QAAF,mBAAa,mBAAxC,CAAxB,C;;UAHV,O;;IAbJ,C;GARA,C;8GAUA,yB;IAUA,sF;IAAA,qB;IAVA,4C;MAcmE,Q;;QAZpD,U;QAAA,W;UACH,kCAAe,WAAf,C;;UAEA,iC;;QAHJ,a;;QAWF,gC;UACE,MAAM,iCAAwB,8BAA2B,CAAE,OAAF,CAAE,QAAF,mBAAa,mBAAxC,CAAxB,C;;UAHV,O;;IAHJ,C;GARA,C;wGAUA,yB;IAAA,sF;IAAA,qB;IAAA,wB;MAImE,Q;;QAF3D,OAAO,O;;QACT,gC;UACE,MAAM,iCAAwB,8BAA2B,CAAE,OAAF,CAAE,QAAF,mBAAa,mBAAxC,CAAxB,C;;UAHV,O;;IAKJ,C;GANA,C;EanEA,2B;IAEI,IAAI,OAAD,WAAC,IAA4B,WAAhC,C;MACI,eAAR,OAAqB,CAAb,eAAa,C;MACb,IAAI,QAAO,YAAP,KAAuB,SAA3B,C;QAAsC,MAAM,2BAAsB,gFAAtB,C;MAC5C,WAAW,QAAO,Y;MAClB,mBAAmB,MAAa,QAAO,IAAK,UAAZ,C;MAGhC,OAAO,IAAK,MAAK,YAAL,C;KAGhB,OAAO,iB;EACX,C;EClBA,uC;IAII,iB;MAAmB,kBAAV,mB;MAAU,cAAyB,qD;MvF6J5C,IAAI,4CAAJ,C;QAAmC,MAAM,8BAAyB,OAAzB,C;MuF7JzC,IvF8JO,WAAK,Q;KuF5JZ,aAAa,gBAAY,CAAZ,C;IACb,wBAAU,MAAV,EAAkB,CAAlB,EAAqB,CAArB,C;IACA,OAAO,M;EACX,C;EAEA,uD;IAGmD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,WAAJ,GAAiB,MAAjB,I;IAC9E,yBAAW,cAAU,GAAV,CAAX,EAA2B,MAA3B,EAAmC,MAAnC,C;EACJ,C;EAEA,uD;IAGiD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAa,MAAb,I;IAC5E,kBAAc,CAAd,C;IACA,cAAU,MAAV,C;IAEA,OAAO,QAAM,CAAb,C;MxD6bI,aAAa,mCwD5bP,CxD4bO,C;;QwD3bE,QxD6bQ,MtBtZY,SsBsZZ,MtBtZoB,cAAR,I;Q8EvCpB,QAAyB,K;QAApC,WjGiPD,MAAK,KAAI,CAAJ,EAAO,CAAP,C;QiGhPD,cxD4bgB,MwD5bhB,OAAgB,sBAAhB,EAAkC,IAAlC,C;QACH,wBAAW,IAAX,I;QACA,gBAAO,IAAP,I;QxD0bA,awDzbA,I;QhG2DR,IAAI,EwC+XU,UAAU,CxC/XpB,CAAJ,C;UACI,cwC8XyB,0C;UxC7XzB,MAAM,2BAAsB,OAAQ,WAA9B,C;;QwCiYF,0B;;;EwD3bZ,C;EC/BA,uC;IACI,eAAY,gBAAP,MAAO,CAAZ,C;EACJ,C;0GAEA,yB;IAAA,yD;I5EJA,yE;IAAA,qB;I4EIA,mC;MACe,sB;M5EGX,cAAc,kBAL2B,CAK3B,C;;Q4EHiB,K5EK3B,CAAM,OAAN,C;QACA,qBAAO,OAAQ,Q;;QACjB,gC;UACE,OAAQ,U;UACR,MAAM,C;;UALV,O;;M4EJA,yC;IACJ,C;GAFA,C;gGAIA,yB;IAAA,2C;IAAA,yB;IAAA,8B;IAAA,2C;IAAA,oD;IAAA,8D;IAAA,6E;IAAA,4B;MAE6C,IAAK,I;MAA9C,OAAO,oBAAe,kBAAgB,GAAP,gBAAO,EAAG,cAAK,qBAAL,iCAAH,CAAhB,EAAkD,IAAlD,CAAf,EAAwE,qBAAY,eAApF,C;IACX,C;GAHA,C;0GCRA,yB;IAAA,yD;I7EAA,yE;IAAA,qB;I6EAA,mC;MACe,sB;M7EOX,cAAc,kBAL2B,CAK3B,C;;Q6EPiB,K7ES3B,CAAM,OAAN,C;QACA,qBAAO,OAAQ,Q;;QACjB,gC;UACE,OAAQ,U;UACR,MAAM,C;;UALV,O;;M6ERA,yC;IACJ,C;GAFA,C;EAIA,yC;IACI,eAAY,gBAAP,MAAO,CAAZ,C;EACJ,C;EAEA,mC;IAC4D,UAG7B,M;IAH6B,6B;IACxD,iBC2HiH,aD3HjH,E;MADkD,OACR,oBACtC,aACW,KAAP,8BAAO,EAAG,cAAS,2BAAT,iCAAH,CADX,EAEI,IAFJ,CADsC,EAInC,mCAAY,8BAJuB,C;;MAM1C,iBCmHgG,EDnHhG,E;QAPkD,OAOd,sCAAe,M;;QAC3C,MAAM,2BAAsB,uBAAoB,sBAApB,+CAAtB,C;;G;EEvByB,+B;IAAmB,kC;IAC1D,2BAAwB,gBAAmB,aAAnB,O;IACxB,sBAAmB,C;G;;SAFuC,Y;MAAA,8B;K;;kDAK1D,oB;EAAwD,C;gDAExD,oB;IAA0D,e;G;mDAC1D,oB;EAAyD,C;iCAEzD,Y;IAKmB,Q;IAJf,IAAI,wBAAQ,CAAZ,C;MAAe,OAAO,sB;IACtB,WAAU,iDAAV,EAAU,mBAAV,C;IAEA,eACe,8CAAU,GAAV,2B;IACf,yBAAU,GAAV,IAAiB,I;IAEjB,OAAO,2BAAc,QAAd,C;EACX,C;0CAEA,oB;IAKkB,Q;IAJd,8BAAiB,QAAjB,C;IACA,IAAI,wBAAQ,aAAZ,C;MACI,6BAAgB,QAAhB,C;;MAEA,yBAAU,0BAAV,EAAU,kCAAV,UAAoB,Q;;EAE5B,C;kCAEA,Y;IACsB,UAEC,M;IAFD,0B;IAAlB,aAAU,CAAV,gB;MACI,eACe,gDAAU,CAAV,6B;MACf,yBAAU,CAAV,IAAe,I;MACf,6BAAgB,QAAhB,C;;IAEJ,sBAAO,C;EACX,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBxDhC0C,I;6BA8CgB,uB;iBL8U7B,O;oBACG,K;qBACC,K;qBACA,K;uBACE,K;mBsBxMT,cAAU,CAAV,C;2BexLO,iCAAU,cAAV,0C;iCOFkB,C;yBACd,S;yBQHF,G;0BACI,G;qBACL,I;ETAP,Q;YAAA,gBAC/B,OAAO,OAAQ,KAAI,WAAY,IAAG,OAAO,SAAU,IAAG,IADvB,IAC+B,OAAO,SAAS,KAAM,IAAG,IADxD,oC;EAsBC,gBAAN,S;ExEsDtB,SwEpDI,UAAS,I;gBxEqDN,S;EwEjDoB,kBAAN,S;ExEgDrB,WwE9CI,SAAQ,I;exE+CL,W;;;;"}
{"version":3,"file":"kotlinx-serialization-kotlinx-serialization-json-jsLegacy.js","sources":["util/Preconditions.kt","generated/_Strings.kt","collections/Maps.kt","collections/Collections.kt","../../../../../core/commonMain/src/kotlinx/serialization/Serializers.kt","../../../../../formats/json/jsMain/src/kotlinx/serialization/json/internal/DynamicDecoders.kt","kotlin/math.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/Json.kt","../../../../../core/commonMain/src/kotlinx/serialization/internal/Platform.common.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonContentPolymorphicSerializer.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElement.kt","text/StringBuilder.kt","util/Standard.kt","kotlin/text/numberConversions.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElementBuilders.kt","collections/MutableCollections.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElementSerializers.kt","../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptors.kt","util/Lazy.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonTransformingSerializer.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonConf.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonExceptions.kt","kotlin/text/string.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonParser.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonReader.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/Polymorphic.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonEncoder.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/PolymorphismValidator.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonDecoder.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonEncoder.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StringOps.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonDecoder.kt","../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/WriteMode.kt","../../../../../formats/json/jsMain/src/kotlinx/serialization/json/Dynamics.kt","kotlin/jsTypeOf.kt","../../../../../formats/json/jsMain/src/kotlinx/serialization/json/internal/DynamicEncoders.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.scanReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.scanReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n",null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n",null,null,null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.toLowerCase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\nprivate fun String.isNaN(): Boolean = when (this.toLowerCase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    else -> -1\n}.let { if (it >= radix) -1 else it }\n",null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n",null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n",null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n",null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Function corresponding to JavaScript's `typeof` operator\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline fun jsTypeOf(a: Any?): String = js(\"typeof a\")\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;mCAwIA,gD;sCA/GA,mD;iBC29BA,mC;oBAAA,kB;;;;;;;;;;;;;;;;;;;;;;2BC14BA,oD;uBCrBA,+C;;;;;;;;;;;;;;;;qBCnEA,0G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BCD8C,4B;;;;;eC2R9C,I;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EC1PwB,6B;IAKpB,0B;IALqB,0C;G;;;SAGjB,Y;MAAQ,OAAA,0BAAc,kB;K;;EAE1B,wB;IAAA,4B;IAGkC,gBAAK,cAAL,C;G;;;;;;;EAHlC,oC;IAAA,mC;MAAA,kB;KAAA,4B;G;0CAKA,6B;IAMI,aAAa,oB;IACb,cAAc,0BACV,MADU,EACF,IADE,+BAGV,gBAAuB,kBAAS,OAAhC,OAHU,C;IAKd,OAAQ,iCAAwB,UAAxB,EAAoC,KAApC,C;IACR,OAAO,MAAO,W;EAClB,C;4CAEA,gC;IAMI,aAAa,eAAW,MAAX,C;IACb,YAAY,yBAAqB,IAArB,+BAA0C,MAA1C,C;IACZ,aAAa,KAAM,iCAAwB,YAAxB,C;IACnB,IAAI,CAAC,MAAO,OAAZ,C;MPyDyC,MAAM,2BAA8B,COzDjD,8CAA2C,MPyDM,YAA9B,C;KOxD/C,OAAO,M;EACX,C;+CACA,6B;IAMI,OAAO,gBAAU,KAAV,EAAiB,UAAjB,C;EACX,C;iDAEA,iC;IAMI,OAAO,eAAS,OAAT,EAAkB,YAAlB,C;EACX,C;8CAEA,kB;IAMI,OAAO,8BAAiB,mCAAjB,EAAwC,MAAxC,C;EACX,C;;;;;;EAGJ,qC;IAGgB,oB;MAAA,iC;IACZ,cAAc,gBAAY,IAAK,sBAAjB,C;IACN,cAAR,OAAQ,C;IACR,WAAW,OAAQ,gB;IACnB,OAAO,aAAS,IAAT,C;EACX,C;qKAEA,yB;IAAA,sE;IHpGA,6I;IImDA,uI;IAAA,8B;IDiDA,6C;MAOiD,kBAAlB,2B;MCtDiC,Q;MDsD5D,OAAO,sCCtDqD,qBJhDrD,0DIgDqD,kCDsDrD,EAAoD,KAApD,C;IACX,C;GARA,C;yKAUA,yB;IAAA,sE;IH9GA,6I;IImDA,uI;IAAA,8B;ID2DA,4C;MAO4C,kBAAlB,2B;MChEsC,Q;MDgE5D,+CChE4D,qBJhDrD,0DIgDqD,kCDgE5D,EAAsD,IAAtD,C;K;GAPJ,C;EAayB,2B;IACrB,sBAIqC,IAAK,e;IAE1C,yBAKwC,IAAK,kB;IAE7C,iBAUgC,IAAK,U;IAErC,8BAK6C,IAAK,uB;IAElD,mBAIkC,IAAK,Y;IAEvC,yBAOuC,IAAK,kB;IAE5C,yBAOwC,IAAK,kB;IAE7C,4BAK2C,IAAK,qB;IAEhD,0BAIwC,IAAK,mB;IAE7C,uCAMsD,IAAK,gC;IAE3D,yBAGkD,IAAK,kB;G;wCAEvD,Y;IAEI,IAAI,yBAAJ,C;MPvMJ,IAAI,COuMkC,gCAAsB,oBAAtB,CPvMtC,C;QACI,cOuMI,kF;QPtMJ,MAAM,8BAAyB,OAAQ,WAAjC,C;QOyMN,IAAI,CAAC,gBAAL,C;MP3MJ,IAAI,CO4MY,+BAAqB,aAArB,CP5MhB,C;QACI,gBO4MQ,mE;QP3MR,MAAM,8BAAyB,SAAQ,WAAjC,C;cO6MC,IAAI,gCAAqB,aAArB,CAAJ,C;MAEoC,gBAAlB,sB;MAAkB,c;;QNswB/B,Q;QAAA,0B;QAAhB,OAAgB,cAAhB,C;UAAgB,oC;UAAW,SAAU,oB;UAAf,IAAI,EMtwB2B,kBAAM,EAAN,IAAa,kBAAM,CAAnB,IAA2B,kBAAM,EAAjC,IAAyC,kBAAM,ENswB1E,CAAJ,C;YAAyB,aAAO,K;YAAP,e;;QAC/C,aAAO,I;;;MMvwBC,+B;MPjNR,IAAI,COkNY,cPlNhB,C;QACI,gBOkNQ,gGAA6F,sB;QPjNrG,MAAM,8BAAyB,SAAQ,WAAjC,C;QOqNN,OAAO,aACH,mBADG,EACa,sBADb,EACgC,cADhC,EAEH,2BAFG,EAEqB,gBAFrB,EAEkC,sBAFlC,EAGH,sBAHG,EAGgB,yBAHhB,EAIH,uBAJG,EAIiB,oCAJjB,EAIkD,sBAJlD,C;EAMX,C;;;;;;EAIkB,iC;IAA4B,gBAAK,aAAL,C;IAG1C,8B;G;+CAGJ,Y;IACI,IAAI,+BAAqB,8BAArB,CAAJ,C;MAAiD,M;IACjD,gBAAgB,0BAAsB,0BAAc,qBAApC,EAA0D,0BAAc,mBAAxE,C;IAChB,sBAAkB,gBAAO,SAAP,C;EACtB,C;;;;;;;;EE7M2D,qD;IAAC,oC;IAC5D,4BASI,sBAAsB,+CAAoC,wBAAU,WAA9C,OAAtB,6B;G;;;SATJ,Y;MAAA,gC;K;;iEAWA,0B;IAEkC,UAA1B,MAA0B,EAI7B,M;IALD,uBACI,WAA0B,OAA1B,OAAQ,kBAAkB,wBAAe,wBAAf,EAA0B,KAA1B,CAA1B,mBACwB,gDAAb,KAAa,EADxB,qBAEW,wEAA0B,KAA1B,GAAwC,wBAAxC,C;IAEsB,CAApC,2EAAoC,oBAAU,OAAV,EAAmB,KAAnB,C;EACzC,C;mEAEA,mB;IAK2B,Q;IAJvB,YAAoB,cAAR,OAAQ,C;IACpB,WAAW,KAAM,oB;IAEjB,uBACuB,qDAAmB,IAAnB,mC;IACvB,OAAO,KAAM,KAAK,+BAAsB,gBAAtB,EAAwC,IAAxC,C;EACtB,C;mFAOA,+B;IACgC,Q;IAA5B,mBAAmB,CAAS,OAAT,QAAS,WAAT,mBAAyB,QAAF,W;IAC1C,YAAY,+BAAoB,SAAU,WAA9B,O;IACZ,MAAM,4BACM,YAAU,YAAV,0DAA0E,KAA1E,gBACQ,wEAFd,C;EAGV,C;;;;;;;;;;;;;EC/FJ,uB;;G;EAAA,iC;;G;+CAAA,Y;;G;;;;;;;;;;;;;;;;;EAaA,yB;;IAKoC,sB;G;qCAehC,Y;IAAyC,mB;G;EApB7C,mC;;G;iDAAA,Y;;G;;;;;;;;;;;;;;;;;EAuBA,gC;IAII,IAAI,aAAJ,C;MAAmB,OAAO,sB;IAC1B,OAAO,gBAAY,KAAZ,EAA8B,KAA9B,C;EACX,C;EAEA,gC;IAII,IAAI,aAAJ,C;MAAmB,OAAO,sB;IAC1B,OAAO,gBAAY,KAAZ,EAA8B,KAA9B,C;EACX,C;EAEA,gC;IAII,IAAI,aAAJ,C;MAAmB,OAAO,sB;IAC1B,OAAO,gBAAY,KAAZ,EAA8B,IAA9B,C;EACX,C;EAG2B,qC;IAGvB,wB;IADA,kC;IAEA,yBAAsC,IAAK,W;G;;SAF3C,Y;MAAA,8B;K;;;;SAEA,Y;MAAA,6B;K;;mCAEA,Y;IACI,Q;IAAA,IAAI,aAAJ,C;MCuUmB,gBAAhB,oB;MDvUyB,YEGhC,SFHgC,EAAY,YAAZ,C;MAA5B,OEIG,SDmUqC,W;;MDvUxC,OACK,Y;IADL,W;G;iCAGJ,iB;cAII,M;IAFA,IAAI,SAAS,KAAb,C;MAAoB,OAAO,I;IAC3B,IAAI,iBAAiB,qGAAe,KAAf,UAArB,C;MAAkD,OAAO,K;IACzD,gE;IACA,IAAI,kBAAY,KAAM,SAAtB,C;MAAgC,OAAO,K;IACvC,IAAI,sBAAW,KAAM,QAAjB,CAAJ,C;MAA8B,OAAO,K;IACrC,OAAO,I;EACX,C;mCAEA,Y;IACI,aAAsB,SAAT,aAAS,C;IACtB,SAAS,MAAK,MAAL,QAAsB,SAAR,YAAQ,CAAtB,I;IACT,OAAO,M;EACX,C;;;;;;EAGJ,oB;IAAA,wB;IAIyB,wB;IAErB,yBAA+B,M;G;;;SADA,Y;MAAQ,Y;K;;;;SACvC,Y;MAAA,6B;K;;;;;;;;EANJ,gC;IAAA,+B;MAAA,c;KAAA,wB;G;EAgBuB,6B;;IAAkD,sB;IAAjD,wB;G;gCACpB,iB;IAAmD,8BAAW,KAAX,C;G;kCACnD,Y;IAAsC,OAAQ,SAAR,cAAQ,C;G;EAM1B,uC;IAAE,QR0K0C,K;IQ1KvC,QRuLuC,O;IQvLjC,aAAK,CAAL,eAAS,C;EAAI,C;kCAL5C,Y;IACI,OAAuB,aAAhB,cAAQ,QAAQ,EACP,GADO,EAEV,GAFU,EAGT,GAHS,kBAIP,0BAJO,C;EAM3B,C;EAjBJ,gC;;G;8CAAA,Y;;G;;;;;;;;;;;;;SAOwF,Y;MAAA,6B;K;;;SAAA,Y;MAAA,0B;K;;;SAAA,Y;MAAA,0B;K;;;SAAA,Y;MAAA,4B;K;;2CAAA,e;IAAA,4C;G;6CAAA,iB;IAAA,gD;G;mCAAA,e;IAAA,oC;G;iCAAA,Y;IAAA,+B;G;;;;;;EAoBlE,4B;;IAA2C,sB;IAA1C,wB;G;+BACnB,iB;IAAmD,8BAAW,KAAX,C;G;iCACnD,Y;IAAsC,OAAQ,SAAR,cAAQ,C;G;iCAC9C,Y;IAAyC,OAAQ,aAAR,cAAQ,EAAsD,GAAtD,EAAsB,GAAtB,EAAqC,GAArC,C;G;EAVrD,+B;;G;6CAAA,Y;;G;;;;;;;;;;;;;SAOgF,Y;MAAA,0B;K;;uCAAA,mB;IAAA,6C;G;4CAAA,oB;IAAA,mD;G;oCAAA,iB;IAAA,wC;G;sCAAA,mB;IAAA,4C;G;gCAAA,Y;IAAA,+B;G;iCAAA,Y;IAAA,gC;G;0CAAA,mB;IAAA,gD;G;qCAAA,Y;IAAA,oC;G;6CAAA,iB;IAAA,iD;G;wCAAA,8B;IAAA,yD;G;;;;;;EAW5E,sC;IAAQ,gB;IAAA,kGAA0B,iBAAM,eAAN,C;G;EAOlC,mC;IAAQ,gB;IAAA,+FAAuB,iBAAM,YAAN,C;G;EAO/B,kC;IAAQ,gB;IAAA,8FAAsB,iBAAM,WAAN,C;G;EAO9B,iC;IAAQ,gB;IAAA,6FAAqB,iBAAM,UAAN,C;G;EAMC,4B;IAAQ,OAAQ,MAAR,iBAAQ,C;G;EAKT,kC;IAAQ,OAAQ,YAAR,iBAAQ,C;G;EAMrB,6B;IAAQ,OAAQ,OAAR,iBAAQ,C;G;EAKT,mC;IAAQ,OAAQ,aAAR,iBAAQ,C;G;EAMnB,+B;IAAQ,OAAQ,SAAR,iBAAQ,C;G;EAKT,qC;IAAQ,OAAQ,eAAR,iBAAQ,C;G;EAMzB,8B;IAAQ,OGrHK,SHqHL,iBGrHK,C;G;EH0HN,oC;IAAQ,OG3GK,eH2GL,iBG3GK,C;G;EHiHhB,gC;IAAQ,OAAQ,gBAAR,iBAAQ,C;G;EAKT,sC;IAAQ,OAAQ,sBAAR,iBAAQ,C;G;EAKjB,sC;IAAQ,OAAI,kCAAJ,GAAsB,IAAtB,GAAgC,iB;G;EAExF,mC;IACI,MAAM,8BAAyB,4CAAW,SAAX,mBAAkC,OAA3D,C;G;EAEV,uC;IAEI,MAAM,8BAAyB,aAAU,GAAV,kBAAwB,QAAjD,C;G;6JIjOV,yB;IAAA,2E;IAAA,gC;MAiBI,cAAc,4B;MACN,cAAR,OAAQ,C;MACR,OAAO,OAAQ,Q;IACnB,C;GApBA,C;2JAuBA,yB;IAAA,yE;IAAA,gC;MAiBI,cAAc,2B;MACN,cAAR,OAAQ,C;MACR,OAAO,OAAQ,Q;IACnB,C;GApBA,C;EA0B+B,6B;IAE3B,iBZmD0D,oB;G;4CYjD1D,wB;IAKkE,OAAA,cAAQ,aAAI,GAAJ,EAAS,OAAT,C;G;sCAE1E,Y;IACmC,sBAAW,cAAX,C;G;;;;;;EAGvC,sD;IA/CI,cAAc,uB;IAqDW,aApDjB,CAAR,OAAQ,C;IAoDR,6BAAI,GAAJ,EAnDO,OAAQ,QAmDf,C;G;EAEJ,qD;IAhCI,cAAc,sB;IAsCU,aArChB,CAAR,OAAQ,C;IAqCR,6BAAI,GAAJ,EApCO,OAAQ,QAoCf,C;G;EAEJ,oC;IAK+E,6BAAI,GAAJ,EAAS,gBAAc,KAAd,CAAT,C;G;EAE/E,sC;IAK8E,6BAAI,GAAJ,EAAS,gBAAc,KAAd,CAAT,C;G;EAE9E,sC;IAK8E,6BAAI,GAAJ,EAAS,gBAAc,KAAd,CAAT,C;G;EAMhD,4B;IAE1B,iBXzBoD,gB;G;2CW2BpD,mB;IAMI,cCzEC,WDyEU,OCzEV,C;ID0ED,OAAO,I;EACX,C;qCAEA,Y;IACkC,qBAAU,cAAV,C;G;;;;;;EAGtC,+B;IAK4D,6BAAI,gBAAc,KAAd,CAAJ,C;G;EAE5D,iC;IAK2D,6BAAI,gBAAc,KAAd,CAAJ,C;G;EAE3D,iC;IAK2D,6BAAI,gBAAc,KAAd,CAAJ,C;G;EAE3D,iD;IA/HI,cAAc,uB;IAqIM,aApIZ,CAAR,OAAQ,C;IAoIR,6BAnIO,OAAQ,QAmIf,C;G;EAEJ,gD;IAhHI,cAAc,sB;IAsHK,aArHX,CAAR,OAAQ,C;IAqHR,6BApHO,OAAQ,QAoHf,C;G;;;EAKJ,yB;G;;;;;;EE7JA,iC;IAAA,qC;IAeI,4BACI,sBAAsB,wCAAtB,8BAAwF,uCAAxF,C;G;;;SADJ,Y;MAAA,gC;K;;sDAUA,0B;IACI,OAAO,OAAP,C;IAEI,kBADE,KACF,iB;MAAoB,OAAQ,iCAAwB,qCAAxB,EAAiD,KAAjD,C;SAC5B,kBAFE,KAEF,c;MAAiB,OAAQ,iCAAwB,kCAAxB,EAA8C,KAA9C,C;SACzB,kBAHE,KAGF,a;MAAgB,OAAQ,iCAAwB,iCAAxB,EAA6C,KAA7C,C;EAEhC,C;wDAEA,mB;IACI,YAAoB,cAAR,OAAQ,C;IACpB,OAAO,KAAM,oB;EACjB,C;EAnBuC,0D;IAAE,OAAA,qCAAwB,W;EAAW,C;EAC1C,4D;IAAE,OAAA,gCAAmB,W;EAAW,C;EAC7B,4D;IAAE,OAAA,mCAAsB,W;EAAW,C;EACpC,4D;IAAE,OAAA,kCAAqB,W;EAAW,C;EACnC,4D;IAAE,OAAA,iCAAoB,W;EAAW,C;EANwB,4D;IAEpF,0BAAQ,eAAR,EAAyB,MAAM,8CAAN,CAAzB,C;IACA,0BAAQ,UAAR,EAAoB,MAAM,gDAAN,CAApB,C;IACA,0BAAQ,aAAR,EAAuB,MAAM,gDAAN,CAAvB,C;IACA,0BAAQ,YAAR,EAAsB,MAAM,gDAAN,CAAtB,C;IACA,0BAAQ,WAAR,EAAqB,MAAM,gDAAN,CAArB,C;IACJ,W;EAAA,C;;;;;;;EAvBR,6C;IAAA,4C;MAAA,2B;KAAA,qC;G;EAwCA,mC;IAAA,uC;IAOI,4BACI,sBAAsB,0CAAtB,2B;G;;;SADJ,Y;MAAA,gC;K;;wDAGA,0B;IAKwC,IAAuB,IAAvB,EAH7B,M;IADP,OAAO,OAAP,C;IACO,IAAI,8BAAJ,C;MACK,SAAR,OAAQ,iCAAwB,gCAAxB,EAA4C,sBAA5C,C;;MAEA,SAAR,OAAQ,iCAAwB,mCAAxB,EAA+C,4DAA/C,C;;IAHZ,a;EAKJ,C;0DAEA,mB;IACI,aAAqB,cAAR,OAAQ,CAAgB,oB;IACrC,IAAI,qCAAJ,C;MAA8B,MAAM,wBAAsB,EAAtB,EAA0B,yFAAwD,MAAxD,CAA1B,EAAmG,MAAO,WAA1G,C;IACpC,OAAO,M;EACX,C;;;;;;;EAvBJ,+C;IAAA,8C;MAAA,6B;KAAA,uC;G;EA0BA,8B;IAAA,kC;IAOI,4BAEI,sBAAsB,qCAAtB,sB;G;;;SAFJ,Y;MAAA,gC;K;;mDAIA,0B;IACI,OAAO,OAAP,C;IACA,OAAQ,a;EACZ,C;qDAEA,mB;IACI,SAAO,OAAP,C;IACA,OAAQ,a;IACR,OAAO,sB;EACX,C;;;;;;;EApBJ,0C;IAAA,yC;MAAA,wB;KAAA,kC;G;EAuBA,iC;IAAA,qC;IAEI,4BACI,0BAA0B,wCAA1B,uB;G;;;SADJ,Y;MAAA,gC;K;;sDAGA,0B;IACI,OAAO,OAAP,C;IACA,IAAI,KAAM,SAAV,C;MACI,OAAO,OAAQ,sBAAa,KAAM,QAAnB,C;KAGnB,WAAiB,eAAN,KAAM,C;IACjB,IAAI,YAAJ,C;MACI,OAAO,OAAQ,oBAAW,IAAX,C;KAGnB,aAAmB,iBAAN,KAAM,C;IACnB,IAAI,cAAJ,C;MACI,OAAO,OAAQ,sBAAa,MAAb,C;KAGnB,cAAoB,kBAAN,KAAM,C;IACpB,IAAI,eAAJ,C;MACI,OAAO,OAAQ,uBAAc,OAAd,C;KAEnB,OAAQ,sBAAa,KAAM,QAAnB,C;EACZ,C;wDAEA,mB;IACI,aAAqB,cAAR,OAAQ,CAAgB,oB;IACrC,IAAI,mCAAJ,C;MAA4B,MAAM,wBAAsB,EAAtB,EAA0B,uFAAsD,MAAtD,CAA1B,EAAiG,MAAO,WAAxG,C;IAClC,OAAO,M;EACX,C;;;;;;;EAhCJ,6C;IAAA,4C;MAAA,2B;KAAA,qC;G;EAmCA,gC;IAAA,oC;IAaI,4BAA4C,uD;G;EAL5C,qD;IAAA,yD;IRpE4D,Q;IQoEtB,2BC/B2C,CTrCrB,qBJxDrD,4NIwDqD,kCSqCqB,Y;IDgC7E,4BACkC,uC;G;;;SADlC,Y;MAAA,gC;K;;;SADkC,Y;MAAA,2C;K;;;SAAA,Y;MAAA,6C;K;;;SAAA,Y;MAAA,0C;K;;;SAAA,Y;MAAA,oC;K;;sFAAA,iB;IAAA,oE;G;qFAAA,iB;IAAA,mE;G;gFAAA,gB;IAAA,6D;G;+EAAA,iB;IAAA,6D;G;kFAAA,iB;IAAA,gE;G;;;;;;;EAAtC,iE;IAAA,gE;MAAA,+C;KAAA,yD;G;;;SAKA,Y;MAAA,gC;K;;qDAEA,0B;IACI,OAAO,OAAP,C;IACA,cAAqB,WAAP,wCAAO,CAArB,EAAmC,mCAAnC,CAA0D,mBAAU,OAAV,EAAmB,KAAnB,C;EAC9D,C;uDAEA,mB;IACI,SAAO,OAAP,C;IACA,OAAO,eAAW,cAAqB,WAAP,wCAAO,CAArB,EAAmC,mCAAnC,CAA0D,qBAAY,OAAZ,CAArE,C;EACX,C;;;;;;;EAvBJ,4C;IAAA,2C;MAAA,0B;KAAA,oC;G;EA0BA,+B;IAAA,mC;IAaI,4BAA4C,qD;G;EAL5C,mD;IAAA,uD;IR9F4D,Q;IQ8FvB,2BCzD4C,CTrCrB,qBJxDrD,mIIwDqD,kCSqCqB,Y;ID0D7E,4BACkC,sC;G;;;SADlC,Y;MAAA,gC;K;;;SADiC,Y;MAAA,2C;K;;;SAAA,Y;MAAA,6C;K;;;SAAA,Y;MAAA,0C;K;;;SAAA,Y;MAAA,oC;K;;oFAAA,iB;IAAA,oE;G;mFAAA,iB;IAAA,mE;G;8EAAA,gB;IAAA,6D;G;6EAAA,iB;IAAA,6D;G;gFAAA,iB;IAAA,gE;G;;;;;;;EAArC,+D;IAAA,8D;MAAA,6C;KAAA,uD;G;;;SAKA,Y;MAAA,gC;K;;oDAEA,0B;IACI,OAAO,OAAP,C;IACA,eAAe,mCAAf,CAAsC,mBAAU,OAAV,EAAmB,KAAnB,C;EAC1C,C;sDAEA,mB;IACI,SAAO,OAAP,C;IACA,OAAO,cAAU,eAAe,mCAAf,CAAsC,qBAAY,OAAZ,CAAhD,C;EACX,C;;;;;;;EAvBJ,2C;IAAA,0C;MAAA,yB;KAAA,mC;G;EA0BA,yB;IACY,cAAR,OAAQ,C;EACZ,C;EAEA,2B;IACY,cAAR,OAAQ,C;EACZ,C;EAEA,kC;IAAoD,gB;IAAA,mE;IAAA,mB;MAC7C,MAAM,2BACL,wDACQ,4EAA2C,SAA3C,CADR,CADK,C;KADuC,a;G;EAMpD,kC;IAAuC,gB;IAAA,mE;IAAA,mB;MAChC,MAAM,2BACL,wDACQ,4EAA2C,SAA3C,CADR,CADK,C;KAD0B,a;G;EAYiC,+C;IAEpE,0BAA0C,KAAK,gBAAL,C;G;;;SAA1C,Y;aEhLwF,6B;K;;;;SFmLpF,Y;MAAQ,OAAA,eAAS,W;K;;;;SAEjB,Y;MAAQ,OAAA,eAAS,K;K;;;;SAEjB,Y;MAAQ,OAAA,eAAS,c;K;;yDAErB,iB;IAAkD,OAAA,eAAS,wBAAe,KAAf,C;G;0DAC3D,gB;IAAkD,OAAA,eAAS,yBAAgB,IAAhB,C;G;gEAC3D,iB;IAAmE,OAAA,eAAS,+BAAsB,KAAtB,C;G;+DAC5E,iB;IAAkE,OAAA,eAAS,8BAAqB,KAArB,C;G;4DAC3E,iB;IAAsD,OAAA,eAAS,2BAAkB,KAAlB,C;G;;;;;EApBnE,yB;IAKwE,wC;G;;;;;;;;EGnKf,iD;IACrD,wC;G;;;SAU0C,Y;MAAQ,OAAA,0BAAY,W;K;;2DAE9D,0B;IACI,aAAqB,cAAR,OAAQ,C;IACrB,cAA0B,UAAZ,MAAO,KAAK,EAAU,KAAV,EAAiB,0BAAjB,C;IAC1B,UAAU,gCAAmB,OAAnB,C;IACV,MAAO,2BAAkB,OAAlB,C;EACX,C;6DAEA,mB;IACI,YAAoB,cAAR,OAAQ,C;IACpB,cAAc,KAAM,oB;IACpB,OAAO,KAAM,KAAK,+BAAsB,0BAAtB,EAAmC,kCAAqB,OAArB,CAAnC,C;EACtB,C;sEAEA,mB;IAQ6E,c;G;oEAE7E,mB;IAO2E,c;G;;;;;;ECrFnD,yO;IACxB,8B;MAAA,iBAA+C,K;IAC/C,iC;MAAA,oBAAkD,K;IAClD,yB;MAAA,YAA0C,K;IAC1C,sC;MAAA,yBAAuD,K;IACvD,2B;MAAA,cAA4C,K;IAC5C,iC;MAAA,oBAAiD,M;IACjD,iC;MAAA,oBAAkD,K;IAClD,oC;MAAA,uBAAqD,K;IACrD,kC;MAAA,qBAAkD,M;IAClD,+C;MAAA,kCAAgE,K;IAChE,iC;MAAA,oBAA4D,8B;IAV5D,oC;IACA,0C;IACA,0B;IACA,oD;IACA,8B;IACA,0C;IACA,0C;IACA,gD;IACA,4C;IACA,sE;IACA,0C;G;;;;;;kCAbJ,Y;IAGI,0B;G;kCAHJ,Y;IAII,6B;G;kCAJJ,Y;IAKI,qB;G;kCALJ,Y;IAMI,kC;G;kCANJ,Y;IAOI,uB;G;kCAPJ,Y;IAQI,6B;G;kCARJ,Y;IASI,6B;G;kCATJ,Y;IAUI,gC;G;kCAVJ,Y;IAWI,8B;G;mCAXJ,Y;IAYI,2C;G;mCAZJ,Y;IAaI,6B;G;oCAbJ,iO;IAAA,oBAGI,gEAHJ,EAII,yEAJJ,EAKI,iDALJ,EAMI,wFANJ,EAOI,uDAPJ,EAQI,yEARJ,EASI,yEATJ,EAUI,kFAVJ,EAWI,4EAXJ,EAYI,mHAZJ,EAaI,yEAbJ,C;G;gCAAA,Y;IAAA,OAGI,iEAHJ,IAII,gEAJJ,KAKI,gDALJ,KAMI,0EANJ,KAOI,oDAPJ,KAQI,gEARJ,KASI,gEATJ,KAUI,sEAVJ,KAWI,kEAXJ,KAYI,4FAZJ,KAaI,gEAbJ,O;G;gCAAA,Y;IAAA,c;IAGI,+D;IACA,kE;IACA,0D;IACA,uE;IACA,4D;IACA,kE;IACA,kE;IACA,qE;IACA,mE;IACA,gF;IACA,kE;IAbJ,a;G;8BAAA,iB;IAAA,4IAGI,wDAHJ,IAII,8DAJJ,IAKI,8CALJ,IAMI,wEANJ,IAOI,kDAPJ,IAQI,8DARJ,IASI,8DATJ,IAUI,oEAVJ,IAWI,gEAXJ,IAYI,0FAZJ,IAaI,8DAbJ,I;G;ECKiC,gC;gCAA2C,O;;G;;;;;;EAKxC,wC;IAAoB,yBAAc,OAAd,C;;G;;;;;;EAExD,kD;IACI,iCAA0B,UAAU,CAAd,GAAiB,qCAAkC,MAAlC,UAA2C,OAA5D,GAA0E,OAAhG,C;G;EAKgC,wC;IAAoB,yBAAc,OAAd,C;;G;;;;;;EAExD,yD;IACI,+BAAsB,MAAtB,EAAgC,OAAF,2BAA+B,OAAN,KAAM,EAAO,MAAP,CAA7D,C;G;EAEJ,oD;IAA0E,iCACtE,6CAA0C,KAA1C,iCACQ,kGADR,GAEQ,iGAFR,IAGQ,qBAA0B,OAAP,MAAO,CAHlC,CADsE,C;G;EAO1E,2D;IACI,iCAAsB,yBAAyB,KAAzB,EAAgC,GAAhC,EAAqC,MAArC,CAAtB,C;G;EAEJ,yD;IACI,+BAAsB,EAAtB,EAA0B,yBAAyB,KAAzB,EAAgC,GAAhC,EAAqC,MAArC,CAA1B,C;G;EAEJ,6D;IAEI,uBAAK,6CAA0C,MAA1C,iCACG,kGADH,GAEG,wBAFR,C;EAIJ,C;EAEA,sD;IACI,OAAO,6CAA0C,KAA1C,6BAA0D,GAA1D,sBACC,kGADD,GAEC,iGAFD,IAGC,qBAA0B,OAAP,MAAO,CAH3B,C;EAIX,C;EAEA,yC;IAA+D,+BAC3D,EAD2D,EAE3D,8BAA2B,GAA3B,iBACQ,+EADR,IAEQ,oBAAwB,OAAN,KAAM,CAFhC,CAF2D,C;G;EAO/D,gD;IAAwE,iCACpE,oBAAkB,aAAc,WAAhC,sDACQ,oEAAkE,aAAc,KAAhF,cADR,IAEQ,0BAH4D,C;G;EAMxE,mC;IAA0B,sB;MAAA,SAAc,E;IACpC,IAAI,mBAAS,GAAb,C;MAAkB,OAAO,S;IACzB,IAAI,WAAU,EAAd,C;MACI,YAAY,SAAK,OAAL,GAAc,EAAd,I;MACZ,IAAI,SAAS,CAAb,C;QAAgB,OAAO,S;MACvB,OAAO,UCsHkE,oBDtH9C,KCsH8C,C;KDnH7E,cAAY,SAAS,EAAT,I;IACZ,UAAU,SAAS,EAAT,I;IACV,aAAiB,WAAS,CAAb,GAAgB,EAAhB,GAAwB,O;IACrC,aAAiB,OAAO,gBAAX,GAAmB,EAAnB,GAA2B,O;IACxB,iBAAgB,cAAN,OAAM,EAAc,CAAd,C;IAAhB,eAAsC,aAAJ,GAAI,EAAa,gBAAb,C;IAAtD,OAAO,SCkHqF,oBAAU,UAAV,EAAsB,QAAtB,CDlHrF,GAAuE,M;EAClF,C;EE/EyB,2C;IAErB,sB;IAEA,mBAAwB,aAAc,U;G;sCAEtC,Y;IACW,YAAP,a;IC+HA,IAAI,qBD/HqB,YC+HzB,C;MAAyD,mBAAX,gBAAW,E;MAA7B,mBD/Ha,8BC+Hb,EAAwC,qBAAxC,C;KD9H5B,aAAO,Y;IAEA,cAAP,a;IAAO,gBAAQ,aAAO,WAAP,KAAqB,Q;IAA7B,eAAuC,aAAO,gB;IC8TrD,IAAI,CAAC,SAAL,C;MAAgB,qBD9TwD,0BC8TxD,EAAgB,QAAhB,C;KD7ThB,arB4FsD,oB;IqB3FtD,oBAAoB,K;IACpB,OAAO,aAAO,cAAd,C;MACI,gBAAgB,K;MAChB,UAAc,gBAAJ,GAAe,aAAO,aAAtB,GAAwC,aAAO,mB;MAClD,cAAP,a;MCsHJ,IAAI,uBDtHyB,QCsH7B,C;QAAyD,mBAAX,kBAAW,E;QAA7B,qBDtHa,cCsHb,EAAwC,uBAAxC,C;ODrHxB,aAAO,Y;MACP,cAAc,W;MACd,MrB4NR,aqB5Ne,GrB4Nf,EqB5NsB,OrB4NtB,C;MqB3NQ,IAAI,aAAO,WAAP,KAAqB,QAAzB,C;QAEW,cAAP,a;QCgHR,IAAI,uBDhH6B,UCgHjC,C;UAAyD,mBAAX,kBAAW,E;UAA7B,qBDhHmB,qCCgHnB,EAAwC,uBAAxC,C;;QD9GpB,gBAAgB,I;QAChB,aAAO,Y;;;IAGR,cAAP,a;IAAO,kBAAQ,CAAC,aAAD,IAAkB,aAAO,WAAP,KAAqB,U;IAA/C,iBAA2D,aAAO,gB;IC4SzE,IAAI,CAAC,WAAL,C;MAAgB,qBD5S4E,4BC4S5E,EAAgB,UAAhB,C;KD3ShB,aAAO,Y;IACP,OAAO,eAAW,MAAX,C;EACX,C;qCAEA,Y;IACW,YAAP,a;ICoGA,IAAI,qBDpGqB,aCoGzB,C;MAAyD,mBAAX,gBAAW,E;MAA7B,mBDpGc,6BCoGd,EAAwC,qBAAxC,C;KDnG5B,aAAO,Y;IAEA,cAAP,a;IAAO,gBAAQ,aAAO,WAAP,KAAqB,Q;IAA7B,eAAuC,aAAO,gB;ICmSrD,IAAI,CAAC,SAAL,C;MAAgB,qBDnSwD,0BCmSxD,EAAgB,QAAhB,C;KDlShB,apBqD4C,gB;IoBpD5C,oBAAoB,K;IACpB,OAAO,aAAO,cAAd,C;MACI,gBAAgB,K;MAChB,cAAc,W;MACd,MAAO,WAAI,OAAJ,C;MACP,IAAI,aAAO,WAAP,KAAqB,QAAzB,C;QAEW,cAAP,a;QCwFR,IAAI,uBDxF6B,WCwFjC,C;UAAyD,mBAAX,kBAAW,E;UAA7B,qBDxFoB,oCCwFpB,EAAwC,uBAAxC,C;;QDtFpB,gBAAgB,I;QAChB,aAAO,Y;;;IAIR,cAAP,a;IAAO,kBAAQ,CAAC,a;IAAT,iBAAwB,aAAO,gB;ICmRtC,IAAI,CAAC,WAAL,C;MAAgB,qBDnRyC,2BCmRzC,EAAgB,UAAhB,C;KDlRhB,aAAO,Y;IACP,OAAO,cAAU,MAAV,C;EACX,C;qCAEA,oB;IACc,Q;IAAA,IAAI,gBAAJ,C;MACC,OAAP,aAAO,a;;MAEP,OAAI,QAAJ,GAAc,aAAO,mBAArB,GAA6C,aAAO,a;;IAHxD,c;IAKA,OAAO,gBAAY,GAAZ,EAAiB,QAAjB,C;EACX,C;8BAEA,Y;IAEwB,IAAb,I;IADP,IAAI,CAAC,aAAO,cAAZ,C;MAA2B,aAAO,cAAK,qCAAL,C;IAC3B,QAAM,aAAO,WAAb,C;WACH,E;QAAoB,gBAAT,sB;QAAgB,aAAO,Y;QAAd,OXoBrB,S;QWpBC,K;WACA,C;QAAa,wBAAqB,IAArB,C;QAAb,K;WACA,C;QAAY,wBAAqB,KAArB,C;QAAZ,K;WACA,C;QAAgB,0B;QAAhB,K;WACA,C;QAAiB,yB;QAAjB,K;cACe,OAAP,aAAO,cAAK,+CAAL,C;QANZ,K;;IAAP,W;EAQJ,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECZJ,8B;IAAA,kC;IAEI,qBAC2B,iBAAU,GAAV,C;IAGvB,aAAU,CAAV,OAAgB,EAAhB,M;MACI,iBAAU,CAAV,EAAa,WAAb,C;;IAGJ,iBAAU,CAAV,EAAgB,EAAhB,C;IACA,iBAAU,CAAV,EAAgB,GAAhB,C;IACA,iBAAU,EAAV,EAAgB,GAAhB,C;IACA,iBAAU,EAAV,EAAgB,GAAhB,C;IACA,iBAAU,EAAV,EAAgB,GAAhB,C;IACA,iBAAU,EAAV,EAAe,EAAf,C;IACA,iBAAU,MAAV,EAAkB,MAAlB,C;IACA,iBAAU,UAAV,EAAsB,UAAtB,C;G;6CAGJ,kB;IACI,IAAI,QAAO,WAAX,C;MAAwB,mBAAc,GAAI,IAAlB,IAA+B,OAAF,CAAE,C;EAC3D,C;6CAEA,kB;IAA4C,iBAAU,CAAE,IAAZ,EAAqB,GAArB,C;G;;;;;;;EAxBhD,0C;IAAA,yC;MAAA,wB;KAAA,kC;G;EA2BA,oC;IACI,UAAK,CAAL,IAAU,E;EACd,C;EAEA,sC;IACI,oBAAS,CAAE,IAAX,EAAoB,EAApB,C;EACJ,C;EAEA,6B;IAAyC,OAAI,CAAA,CAAE,IAAF,IAAY,GAAhB,GAAyB,KAAK,CAAE,IAAP,CAAzB,GAA8C,Q;G;EAEvF,yB;IAA0C,iBAAI,IAAI,GAAR,GAAmB,+CAAc,CAAd,CAAnB,GAAyC,OAAzC,C;G;EAGjB,4B;IAAC,sB;IAEtB,uBAC2B,C;IAE3B,kBACuB,M;IAUvB,uBACiC,C;IAEjC,gBACqB,E;IACrB,gBAAqB,C;IACrB,aAAkB,iBAAU,EAAV,C;IAGd,gB;G;;;SAjBuB,Y;MAAQ,2BAAc,M;K;;;;SAG7C,Y;MAAQ,QAAM,eAAN,C;aACJ,C;aAAA,C;aAAA,C;aAAA,C;aAAA,E;UADI,OACyD,I;gBADzD,OAEI,K;;K;;8MAehB,yB;IAAA,0B;IAAA,oC;IAAA,yC;MACI,IAAI,oBAAc,QAAlB,C;QAA4B,kBAAK,aAAwB,mBAAX,eAAW,EAAxB,CAAL,EAAwC,oBAAxC,C;IAChC,C;GAFA,C;oCAIA,Y;IACI,IAAI,oBAAc,QAAd,IAA0B,oBAAc,SAA5C,C;MAAuD,kBACnD,qCADmD,EACZ,oBADY,C;IAGvD,OAAO,2B;EACX,C;4CAEA,qB;IACI,OAAW,oBAAc,SAAd,KAA4B,CAAC,SAAD,IAAc,oBAAc,QAAxD,CAAJ,GAAuE,IAAvE,GACF,0BAA6B,KAA7B,C;EACT,C;0CAEA,Y;IACI,QAAM,eAAN,C;WACI,C;QAAA,K;WACA,E;QAAW,kBACP,+IADO,EAEP,oBAFO,C;QAAX,K;cAIQ,kBACJ,iHADI,EAEJ,oBAFI,C;QANZ,K;;IAWA,OAAO,2B;EACX,C;mDAEA,Y;IACI,IAAI,oBAAc,QAAlB,C;MAA4B,kBAAK,4HAAL,EAAsE,oBAAtE,C;IAC5B,OAAO,2B;EACX,C;8CAEA,mB;IAA+B,uB;MAAA,UAAmB,I;IAChC,Q;IAAA,IAAI,gBAAS,CAAb,C;MAAA,OACN,eAAJ,UAAI,EAAe,CAAf,EAAkB,IAAI,aAAJ,IAAlB,C;;MACG,gBAAP,a;MAAO,iBAAU,a;MAAV,eAAkB,gBAAS,aAAT,I;MAFf,OFsB8D,SAAY,WAAU,UAAV,EAAsB,QAAtB,C;;IEtBxF,kB;IAGA,IAAI,OAAJ,C;MAAa,gB;IACb,OAAO,O;EACX,C;kCAEA,c;IAEQ,Q;IADJ,IAAI,iBAAU,UAAI,OAAlB,C;MAAwB,aAAU,OAAJ,UAAI,EAAO,IAAI,UAAI,OAAR,IAAP,C;IAClC,WAAI,oBAAJ,EAAI,4BAAJ,UAAgB,E;EACpB,C;uCAEA,sC;IAEI,aAAa,UAAU,SAAV,I;IACb,aAAa,a;IACb,aAAa,SAAS,MAAT,I;IACb,IAAI,SAAS,UAAI,OAAjB,C;MAAuB,aAAU,OAAJ,UAAI,EAAc,cAAP,MAAO,EAAc,IAAI,UAAI,OAAR,IAAd,CAAd,C;IACjC,aAAU,CAAV,MAAkB,MAAlB,M;MAA0B,WAAI,SAAS,CAAT,IAAJ,IAAkB,kBAAO,YAAY,CAAZ,IAAP,C;IAC5C,gCAAU,MAAV,I;EACJ,C;mCAEA,Y;IACI,aAAa,a;IACb,sBAAsB,oB;IACtB,OAAO,kBAAkB,MAAO,OAAhC,C;MACI,SAAS,kBAAO,eAAP,C;MACH,SAAS,iBAAiB,EAAjB,C;MAAf,W;aACI,C;UAAS,yC;UAAT,K;aACA,C;UACI,mBAAY,MAAZ,EAAoB,eAApB,C;UACA,M;aAEJ,C;UACI,kBAAW,MAAX,EAAmB,eAAnB,C;UACA,M;gBAGA,uBAAqB,e;UACrB,kBAAkB,E;UAClB,uBAAuB,kBAAkB,CAAlB,I;UACvB,M;;;IAKZ,uBAAgB,e;IAChB,kBAAa,M;EACjB,C;uCAEA,4B;IACI,uBAAgB,Q;IAChB,gBAAS,Q;IACT,sBAAsB,Q;IACtB,OAAO,kBAAkB,MAAO,OAAzB,IAAmC,iBAAiB,kBAAO,eAAP,CAAjB,MAA6C,QAAvF,C;MACI,yC;;IAEJ,uBAAuB,e;IACvB,gBAAS,kBAAkB,aAAlB,I;IACT,kBAAiB,YAAY,MAAZ,EAAoB,aAApB,EAA4B,aAA5B,EAAoC,IAApC,CAAJ,GAA+C,OAA/C,GAA4D,Q;EAC7E,C;sCAEA,iC;IACI,uBAAgB,a;IAChB,gBAAS,C;IACT,sBAAsB,gBAAgB,CAAhB,I;IAEtB,IAAI,mBAAmB,MAAO,OAA9B,C;MACI,kBAAK,KAAL,EAAY,eAAZ,C;KAEJ,mBAAmB,e;IACnB,OAAO,kBAAO,eAAP,MAA2B,MAAlC,C;MACI,IAAI,kBAAO,eAAP,MAA2B,UAA/B,C;QACI,mBAAY,MAAZ,EAAoB,YAApB,EAAkC,eAAlC,C;QACA,kBAAkB,iBAAU,MAAV,EAAkB,kBAAkB,CAAlB,IAAlB,C;QAClB,kBAAkB,W;QAClB,eAAe,W;aACZ,IAAI,gEAAqB,MAAO,OAAhC,C;QACH,kBAAK,KAAL,EAAY,eAAZ,C;;IAGR,IAAI,kBAAgB,gBAAgB,CAAhB,IAAhB,CAAJ,C;MAEI,gBAAS,Y;MACT,gBAAc,kBAAkB,YAAlB,I;;MAGd,mBAAY,MAAZ,EAAoB,YAApB,EAAkC,eAAlC,C;MACA,gBAAc,E;;IAElB,uBAAuB,kBAAkB,CAAlB,I;IACvB,kBAAa,S;EACjB,C;qCAEA,iC;IAG6B,Q;IAFzB,sBAAsB,a;IACtB,gBAAQ,kBAAkB,MAAO,O;IAAjC,eAAyC,e;IA8DzC,IAAI,CAAC,SAAL,C;MAAgB,kBA9D4C,uCA8D5C,EAAgB,QAAhB,C;KA7DhB,kBAAkB,mBAAO,sBAAP,EAAO,8BAAP,Q;IAClB,IAAI,gBAAe,WAAnB,C;MACI,OAAO,iBAAU,MAAV,EAAkB,eAAlB,C;KAGX,QAAQ,aAAa,WAAY,IAAzB,C;IACR,kBAAQ,MAAK,O;IAAb,iBAAsB,e;IAuDtB,IAAI,CAAC,WAAL,C;MAAgB,kBAvDyB,iEAuDzB,EAAgB,UAAhB,C;KAtDhB,cAAO,CAAP,C;IACA,OAAO,e;EACX,C;qCAEA,4B;IAG8B,UACO,MADP,EAEO,MAFP,EAGM,M;IALhC,aAAa,Q;IACb,cAI2C,OAHtC,CAAC,mBAAY,MAAZ,GAAoB,aAApB,EAAoB,qBAApB,YAAkC,EAAnC,KACQ,mBAAY,MAAZ,GAAoB,eAApB,EAAoB,uBAApB,cAAkC,CAD1C,KAEQ,mBAAY,MAAZ,GAAoB,eAApB,EAAoB,uBAApB,cAAkC,CAF1C,IAGO,mBAAY,MAAZ,GAAoB,eAApB,EAAoB,uBAApB,UAHP,IAGsC,CAJ3C,C;IAMA,OAAO,M;EACX,C;qCAEA,Y;IACI,IAAI,oBAAc,YAAd,IAA8B,oBAAc,aAAhD,C;MACI,gB;MACA,M;KAEJ,iBrBnNgD,gB;;MqBqN5C,QAAM,eAAN,C;aACI,C;aAAA,C;UAA+B,UAAW,WAAI,eAAJ,C;UAA1C,K;aACA,C;UACI,IAAe,KAAX,UAAW,CAAX,KAAqB,aAAzB,C;YAAwC,MAAM,wBAC1C,oBAD0C,EAE1C,sBAF0C,EAG1C,aAH0C,C;UAK9C,UAAW,kBAAS,UAAW,KAAX,GAAkB,CAAlB,IAAT,C;UANf,K;aAQA,C;UACI,IAAe,KAAX,UAAW,CAAX,KAAqB,YAAzB,C;YAAuC,MAAM,wBACzC,oBADyC,EAEzC,sBAFyC,EAGzC,aAHyC,C;UAK7C,UAAW,kBAAS,UAAW,KAAX,GAAkB,CAAlB,IAAT,C;UANf,K;;MASJ,gB;MACgB,qB;MrBjGgC,qBqBiG3C,UrBjG4C,U;;;EqBkGzD,C;kCAEA,Y;IACI,OAAO,wBAAqB,aAArB,2BAA+C,oBAA/C,qBAA4E,eAA5E,wBAAuG,oBAAvG,iBAA8H,aAA9H,M;EACX,C;sCAEA,6B;IAAiC,wB;MAAA,WAAgB,oB;IAC7C,MAAM,wBAAsB,QAAtB,EAAgC,OAAhC,EAAyC,aAAzC,C;EACV,C;0LAEA,wC;IAAgD,wB;MAAA,WAAgB,oB;IAC5D,IAAI,CAAC,SAAL,C;MAAgB,kBAAK,SAAL,EAAgB,QAAhB,C;EACpB,C;uCAEA,mC;IAEW,Q;IALP,IAAI,EAII,kBAAkB,MAAO,OAJ7B,CAAJ,C;MAAgB,kBAI4C,sCAJ5C,EAIyB,eAJzB,C;KAKH,cAAc,kBAAO,eAAP,C;IACvB,KAAG,kBAAK,EAAL,CAAH,4B;MAAe,QAAA,OAAQ,IAAR,IAAkB,EAAlB,I;SACf,KAAG,kBAAK,GAAL,CAAH,4B;MAAe,QAAA,OAAQ,IAAR,IAAkB,EAAlB,GAAgC,EAAhC,I;SACf,KAAG,kBAAK,EAAL,CAAH,4B;MAAe,QAAA,OAAQ,IAAR,IAAkB,EAAlB,GAAgC,EAAhC,I;;MACP,yBAAK,iDAA0B,OAA1B,yBAAL,C;IAJZ,W;EAMJ,C;;;;;;EAGJ,iD;IACI,QAAQ,GAAI,O;IACZ,IAAI,WAAU,CAAd,C;MAAiB,OAAO,K;IACxB,aAAU,CAAV,MAAkB,CAAlB,M;MAAqB,IAAI,kBAAO,QAAQ,CAAR,IAAP,MAAqB,eAAI,CAAJ,CAAzB,C;QAAiC,OAAO,K;IAC7D,OAAO,I;EACX,C;kLCvVA,yB;IAAA,oL;IAAA,2J;IAAA,8B;IAAA,gB;IAAA,8D;MAMgD,UAA0C,M;MAJtF,IAAI,6DAAmD,cAAK,sBAAc,qBAA1E,C;QACI,UAAW,mBAAU,SAAV,EAAgB,KAAhB,C;QACX,M;OAEJ,uBAAuB,gCAAqB,2EAArB,EAA+D,wDAA/D,C;MACvB,e;MACA,gBAAiB,mBAAU,SAAV,EAAgB,KAAhB,C;IACrB,C;GATA,C;EAWA,4D;IAIiB,UACiD,M;IAD9D,aAAa,mF;IACb,uBAA8B,0BAAP,MAAO,EAA0B,SAA1B,EAAgC,wDAAhC,C;IAC9B,iBAAiB,MAAjB,EAAyB,gBAAzB,EAA2C,cAAK,sBAAc,mBAA9D,C;IACA,WAAW,gBAAiB,WAAW,K;IACvC,UAAU,IAAV,C;IACA,OAAO,gB;EACX,C;EAEA,4E;IAKI,IAAI,iDAAJ,C;MAA6C,M;IAE7C,IAAsD,sBAA5B,gBAAiB,WAAW,CAAlD,mCAAJ,C;MACI,eAAe,UAAW,WAAW,W;MACrC,iBAAiB,gBAAiB,WAAW,W;MzBkGJ,MAAM,2BAA8B,CyBhGzE,mBAAgB,UAAhB,8CAAiE,QAAjE,kBACQ,yEAAsE,kBAAtE,QADR,IAEQ,kEAFR,GAGQ,gFzB6FiE,YAA9B,C;KyB1FvD,C;EAEA,yB;IACI,IAAI,uEAAJ,C;MzBuF6C,MAAM,2ByBvFhB,0HzBuF8C,WAA9B,C;KyBtFnD,IAAI,kCAAJ,C;MzBsF6C,MAAM,2ByBtFlB,+HzBsFgD,WAA9B,C;KyBrFnD,IAAI,oCAAJ,C;MzBqF6C,MAAM,2ByBrFhB,gEzBqF8C,WAA9B,C;KyBpFvD,C;EAEA,qE;IAOe,kBACyB,MADzB,EAK8C,M;IAXzD,IAAI,+DAAqD,cAAK,sBAAc,qBAA5E,C;MACI,OAAO,YAAa,qBAAY,SAAZ,C;KAGT,YAAiB,6B;IAAjB,iBAAsC,YAAa,W;ICwIlE,IAAI,iCAAJ,C;MACI,MAAM,wBACF,EADE,EAEF,sEAAkD,UAAW,WAA7D,iDAAoF,KAApF,CAFE,C;KDzIV,eC8IO,K;ID7IP,oBAAoB,cAAK,sBAAc,mB;IACvC,WAAW,qCAAS,aAAT,4E;IACX,uBAAuB,CAAa,SAAb,YAAa,yCAAgC,SAAhC,EAAsC,IAAtC,CAAb,qBAChB,wBAAwB,IAAxB,EAA8B,QAA9B,C;IAGP,OAAY,oBAAL,cAAK,EAAoB,aAApB,EAAmC,QAAnC,EAA6C,uFAA7C,C;EAChB,C;EAEA,iD;IACI,aACQ,YAAJ,GAAkB,sCAAlB,GACK,mCAAuB,IAAvB,O;IACT,MAAM,wBAAsB,EAAtB,EAA0B,8CAA2C,MAArE,EAA8E,QAAS,WAAvF,C;EACV,C;EEpEoC,oE;IAChC,kD;IACA,oC;G;uDAGA,8B;EAEA,C;wDAEA,oD;IAKI,iBAAiB,gBAAiB,W;IAClC,iBAAU,UAAV,EAAsB,WAAtB,C;IACA,IAAI,CAAC,2BAAL,C;MAEI,oCAA6B,UAA7B,EAAyC,WAAzC,C;KAER,C;gDAEA,mC;IACI,WAAW,UAAW,K;IACtB,IAAI,wCAA2B,mCAA/B,C;MACI,MAAM,8BAAyB,6BAAkB,WAAY,WAA9B,2EACvB,sBAAmB,IAAnB,sFADuB,CAAzB,C;KAIV,IAAI,2BAAJ,C;MAA0B,M;IAK1B,IAAI,oCAA8B,+BAA9B,IACG,kCADH,IAEG,uEAFP,C;MAII,MAAM,8BACF,6BAAkB,WAAY,WAA9B,kBAAmD,IAAnD,oEADE,C;KAId,C;mEAEA,mC;IAIiC,Q;IAAA,OAAX,UAAW,c;IAA7B,aAAU,CAAV,gB;MACI,WAAW,UAAW,wBAAe,CAAf,C;MACtB,IAAI,aAAQ,oBAAR,CAAJ,C;QACI,MAAM,8BACF,gCAA6B,WAA7B,uBAAwD,IAAxD,yBACQ,iGADR,GAEQ,8CAFR,GAGQ,oCAJN,C;;EAQlB,C;+DAEA,gD;EAKA,C;;;;;;EC3DgC,kD;IAInB,0B;IAHb,0B;IACA,kB;IACA,4B;IAGA,mCAA2D,SAAK,kB;IAChE,sBAA2B,E;IAC3B,uBAA4B,SAAK,sB;G;;SAPjC,Y;MAAA,0B;K;;;;SAKA,Y;MAAA,uC;K;;qDAIA,Y;IAAuD,OAAuC,CAAvC,eAAW,SAAK,sBAAhB,EAA+B,mBAA/B,CAAuC,Q;G;mEAE9F,wB;IACI,OAAO,yCAAmC,YAAnC,C;EACX,C;0DAEA,sB;IAMiB,IAAN,I;IALP,cAAmB,WAAL,SAAK,EAAW,UAAX,C;IACnB,IAAY,UAAR,OAAQ,OAAR,KAAiB,OAArB,C;MACW,YAAP,mB;MJwGJ,IAAI,qBIxGyB,OAAQ,QJwGrC,C;QAAyD,mBAAX,gBAAW,E;QAA7B,mBIxGoB,mCAAqB,wBAArB,iBAAgD,eAAhD,MJwGpB,EAAwC,qBAAxC,C;OIvGxB,mBAAO,Y;KAEJ,QAAM,OAAN,M;WACH,M;WAAA,K;WAAA,U;QAAqD,gCACjD,SADiD,EAEjD,OAFiD,EAGjD,mBAHiD,C;QAArD,K;cAKQ,OAAI,gBAAQ,OAAZ,GAAqB,IAArB,GACJ,yBAAqB,SAArB,EAA2B,OAA3B,EAAoC,mBAApC,C;QAPD,K;;IAAP,W;EASJ,C;wDAEA,sB;IACI,IAAS,UAAL,WAAK,KAAL,KAAY,OAAhB,C;MACW,YAAP,mB;MJwFJ,IAAI,qBIxFyB,WAAK,MJwFlC,C;QAAyD,mBAAX,gBAAW,E;QAA7B,mBIxFe,mCAAkB,UAAL,WAAK,KAAlB,OJwFf,EAAwC,qBAAxC,C;OIvFxB,mBAAO,Y;KAEf,C;qDAEA,Y;IACI,OAAO,mBAAO,WAAP,KAAqB,O;EAChC,C;8CAEA,Y;IACW,YAAP,mB;IJ8EA,IAAI,qBI9EqB,OJ8EzB,C;MAAyD,mBAAX,gBAAW,E;MAA7B,mBI9EQ,yBJ8ER,EAAwC,qBAAxC,C;KI7E5B,mBAAO,Y;IACP,OAAO,I;EACX,C;8DAEA,sB;IAMiB,IAAN,I;IALP,iBAAiB,mBAAO,W;IACxB,IAAI,eAAc,QAAlB,C;MACW,YAAP,mB;MAAO,gBAAQ,wBAAgB,E;MAAxB,eAA4B,mBAAO,gB;MJwQ9C,IAAI,CAAC,SAAL,C;QAAgB,mBIxQiD,0BJwQjD,EAAgB,QAAhB,C;OIvQZ,mBAAO,Y;KAEJ,QAAM,WAAN,M;WACH,M;QAAkB,8BAAgB,UAAhB,C;QAAlB,K;WACA,K;QAAiB,6BAAe,UAAf,C;QAAjB,K;WACA,U;QACI,QAAM,iDAAN,EAAM,mBAAN,C;eACI,C;YAAK,Q;YAAL,K;eACA,C;YAAK,Q;YAAL,K;kBAEI,S;YAJR,K;;;QADJ,K;cASQ,gCAAkB,UAAlB,EAA8B,UAA9B,C;QAZL,K;;IAAP,W;EAcJ,C;oDAEA,sB;IAQW,Q;IAPP,IAAI,eAAc,QAAd,IAA0B,sBAAe,CAAf,KAAoB,CAAlD,C;MACW,YAAP,mB;MJiDJ,IAAI,qBIjDyB,UJiD7B,C;QAAyD,mBAAX,gBAAW,E;QAA7B,mBIjDe,qCJiDf,EAAwC,qBAAxC,C;QI/C5B,IAAI,sBAAe,CAAf,KAAoB,CAAxB,C;MACW,cAAP,mB;MJ8CJ,IAAI,uBI9CyB,QJ8C7B,C;QAAyD,mBAAX,kBAAW,E;QAA7B,qBI9Ca,4BJ8Cb,EAAwC,uBAAxC,C;OI7CxB,mBAAO,Y;KAEJ,IAAI,CAAC,mBAAO,cAAZ,C;MACI,cAAP,mB;MAAO,gBAAQ,eAAc,Q;MAAtB,Y;MJ2OiC,WAAgB,uB;MAC5D,IAAI,CAAC,SAAL,C;QAAgB,qBI5O6B,2BJ4O7B,EAAgB,QAAhB,C;OI3OZ,S;;MAEA,+E;;IAJJ,W;EAMJ,C;sDAEA,6B;IAO+B,Q;IAH3B,wBAAwB,UAAW,8BAAqB,KAArB,C;IACnC,IAAI,mBAAO,WAAP,KAAqB,OAArB,IAAgC,CAAC,iBAAkB,WAAvD,C;MAAmE,OAAO,I;IAC1E,IAAI,OAAA,iBAAkB,KAAlB,kBAAJ,C;MAC2B,OAAP,mBAAO,oBAAW,oBAAc,UAAzB,C;MAAP,iB;QACL,OAAO,K;OADlB,gBAAgB,I;MAEhB,gBAAgB,iBAAkB,yBAAgB,SAAhB,C;MAClC,IAAI,cAAa,EAAjB,C;QAA+B,OAAO,I;KAE1C,OAAO,K;EACX,C;uDAEA,kC;IAWwB,Q;IAVpB,IAAI,eAAc,QAAd,IAA0B,CAAC,mBAAO,cAAtC,C;MACI,mBAAO,cAAK,2BAAL,C;KAGX,OAAO,mBAAO,cAAd,C;MACI,iD;MACA,UAAU,mB;MACH,YAAP,mB;MJYJ,IAAI,qBIZyB,QJY7B,C;QAAyD,mBAAX,gBAAW,E;QAA7B,mBIZa,cJYb,EAAwC,qBAAxC,C;OIXxB,mBAAO,Y;MACP,YAAY,UAAW,yBAAgB,GAAhB,C;MACP,IAAI,UAAS,EAAb,C;QACZ,IAAI,oBAAc,kBAAd,IAAmC,wBAAiB,UAAjB,EAA6B,KAA7B,CAAvC,C;UACI,Y;;UAEA,OAAO,K;;;QAGX,W;;MAPJ,oB;MAUA,IAAI,aAAa,CAAC,oBAAc,kBAAhC,C;QACI,mBAAO,cAAK,iCAA8B,GAA9B,iBAAsC,qBAA3C,C;;QAEP,mBAAO,c;;MAGX,IAAI,mBAAO,WAAP,KAAqB,QAAzB,C;QACI,mBAAO,Y;QACA,cAAP,mB;QAAO,gBAAQ,mBAAO,c;QAAf,eAA8B,mBAAO,gB;QJyLpD,IAAI,CAAC,SAAL,C;UAAgB,qBIzLuD,2BJyLvD,EAAgB,QAAhB,C;;IItLhB,OAAO,E;EACX,C;qDAEA,sB;IAKW,Q;IAHP,IAAI,eAAc,QAAd,IAA0B,wBAAgB,EAA9C,C;MACW,YAAP,mB;MJlBJ,IAAI,qBIkByB,WJlB7B,C;QAAyD,mBAAX,gBAAW,E;QAA7B,mBIkBgB,oCJlBhB,EAAwC,qBAAxC,C;QIoBrB,IAAI,CAAC,mBAAO,cAAZ,C;MACI,cAAP,mB;MAAO,gBAAQ,eAAc,Q;MAAtB,Y;MJ4KiC,WAAgB,uB;MAC5D,IAAI,CAAC,SAAL,C;QAAgB,qBI7K6B,2BJ6K7B,EAAgB,QAAhB,C;OI5KZ,S;;MAEA,+E;;IAJJ,W;EAMJ,C;iDAEA,Y;IAKW,Q;IAAA,IAAI,oBAAc,UAAlB,C;MACiB,uBAApB,mBAAO,aAAa,C;;MAEe,uBAAnC,mBAAO,4BAA4B,C;;IAHvC,W;EAKJ,C;8CAEA,Y;IAIsD,gBAApB,mBAAO,a;IAAa,kB;;MA+B9C,iBA/B8D,iB;;MAgChE,gC;QACE,mBAAO,cAAK,sBAjCwC,MAiCxC,MAAL,C;;QAHX,O;;IA9B8B,qB;G;+CAClC,Y;IAAwD,gBAApB,mBAAO,a;IAAa,kB;;MA8BhD,iBA9BiE,kB;;MA+BnE,gC;QACE,mBAAO,cAAK,sBAhC0C,OAgC1C,MAAL,C;;QAHX,O;;IA7BgC,qB;G;6CACpC,Y;IAAoD,gBAApB,mBAAO,a;IAAa,kB;;MA6B5C,iBA7B2D,gB;;MA8B7D,gC;QACE,mBAAO,cAAK,sBA/BsC,KA+BtC,MAAL,C;;QAHX,O;;IA5B4B,qB;G;8CAChC,Y;IAAsD,gBAApB,mBAAO,a;IAAa,kB;;MA4B9C,iBA5B8D,iB;;MA6BhE,gC;QACE,mBAAO,cAAK,sBA9BwC,MA8BxC,MAAL,C;;QAHX,O;;IA3B8B,qB;G;+CAElC,Y;IACqC,gBAApB,mBAAO,a;IAAa,kB;;MAyB7B,iBfhIuC,mB;;MeiIzC,gC;QACE,mBAAO,cAAK,sBA3BuB,OA2BvB,MAAL,C;;QAHX,O;;IAxBA,2B;IACA,gBAAgB,SAAK,sBAAc,gC;IACnC,IAAI,aAAoB,SAAP,MAAO,CAAxB,C;MAAoC,OAAO,M;IACpC,iCAAP,mBAAO,EAAiC,MAAjC,C;EACX,C;gDAEA,Y;IACqC,gBAApB,mBAAO,a;IAAa,kB;;MAkB7B,iBAlB+C,mB;;MAmBjD,gC;QACE,mBAAO,cAAK,sBApBuB,QAoBvB,MAAL,C;;QAHX,O;;IAjBA,2B;IACA,gBAAgB,SAAK,sBAAc,gC;IACnC,IAAI,aAAoB,WAAP,MAAO,CAAxB,C;MAAoC,OAAO,M;IACpC,iCAAP,mBAAO,EAAiC,MAAjC,C;EACX,C;8CAEA,Y;IAAsD,gBAApB,mBAAO,a;IAAa,kB;;MAY9C,iBAZ8D,8B;;MAahE,gC;QACE,mBAAO,cAAK,sBAdwC,MAcxC,MAAL,C;;QAHX,O;;IAX8B,qB;G;gDAElC,Y;IACW,Q;IAAA,IAAI,oBAAc,UAAlB,C;MACI,OAAP,mBAAO,a;;MAEA,OAAP,mBAAO,mB;;IAHX,W;EAKJ,C;2CAEA,kC;;MAEQ,OAAO,gB;;MACT,gC;QACE,mBAAO,cAAK,sBAAmB,IAAnB,MAAL,C;;QAHX,O;;EAKJ,C;sDAEA,0B;IACI,OAAsB,uBAAf,cAAe,EAAuB,mBAAvB,C;EAC1B,C;;;;;;ECnN+B,oE;IAKlB,0B;IAJb,0B;IACA,0B;IACA,kB;IACA,sC;IAQA,mCAA2D,SAAK,kB;IAChE,uBAA4B,SAAK,sB;IAEjC,sBACoC,K;IACpC,0BAA+B,K;IAG3B,QAAQ,WAAK,Q;IACb,IAAI,sBAAe,CAAf,MAAsB,IAAtB,IAA8B,sBAAe,CAAf,MAAsB,IAAxD,C;MACI,sBAAe,CAAf,IAAoB,I;G;;SApB5B,Y;MAAA,0B;K;;;;SAUA,Y;MAAA,uC;K;;6DAaA,mB;IACI,qCAAwB,mCAAxB,EAA+C,OAA/C,C;EACJ,C;sEAEA,6B;IACI,OAAO,oBAAc,e;EACzB,C;mEAEA,6B;;MJ7B4C,gB;MAJ5C,IAAI,eIkCsB,UJlCtB,oCAAmD,SAAK,sBAAc,qBAA1E,C;QIkC0B,UJjCX,yBIiCuB,KJjCvB,C;QACX,iC;OAEJ,uBAAuB,2BAAqB,qBI8BlB,UJ9BkB,4CAArB,EAA+D,uBI8BhD,KJ9BgD,4BAA/D,C;MI+Bf,0BAAmB,I;MJ7B3B,gBAAiB,yBI4BqB,KJ5BrB,C;;;EI+BjB,C;oDAEA,sB;IACI,eAAS,W;IACT,0BAAa,oBAAc,mBAA3B,C;IACA,eAAS,eAAM,KAAN,C;IACT,eAAS,Q;IACT,0BAAa,UAAW,WAAxB,C;EACJ,C;0DAEA,sB;IAgBW,Q;IAfP,cAAmB,WAAL,SAAK,EAAW,UAAX,C;IACnB,IAAY,UAAR,OAAQ,OAAR,KAAiB,OAArB,C;MACI,eAAS,eAAc,UAAR,OAAQ,OAAd,C;MACT,eAAS,S;KAGb,IAAI,uBAAJ,C;MACI,0BAAmB,K;MACnB,sBAAe,UAAf,C;KAGJ,IAAI,gBAAQ,OAAZ,C;MACI,OAAO,I;KAGX,OAAO,8BAAe,OAAQ,QAAvB,oBAAmC,yBAAqB,eAArB,EAA+B,SAA/B,EAAqC,OAArC,EAA8C,qBAA9C,C;EAC9C,C;wDAEA,sB;IACI,IAAS,UAAL,WAAK,KAAL,KAAY,OAAhB,C;MACI,eAAS,W;MACT,eAAS,W;MACT,eAAS,eAAW,UAAL,WAAK,KAAX,C;KAEjB,C;yDAEA,6B;IACU,IAQqB,I;IAR3B,QAAM,WAAN,M;WACI,M;QACI,IAAI,CAAC,eAAS,aAAd,C;UACI,eAAS,eAAM,KAAN,C;QACb,eAAS,W;QAHb,K;WAKA,K;QACI,IAAI,CAAC,eAAS,aAAd,C;UACmB,IAAI,QAAQ,CAAR,KAAa,CAAjB,C;YACX,eAAS,eAAM,KAAN,C;YACT,eAAS,W;YACT,W;;YAEA,eAAS,eAAM,KAAN,C;YACT,eAAS,Q;YACT,Y;;UAPJ,0B;;UAUA,sBAAe,I;UACf,eAAS,W;;;QAbjB,K;WAgBA,U;QACI,IAAI,UAAS,CAAb,C;UACI,sBAAe,I;QACnB,IAAI,UAAS,CAAb,C;UACI,eAAS,eAAM,KAAN,C;UACT,eAAS,Q;UACT,sBAAe,K;;QANvB,K;cAUI,IAAI,CAAC,eAAS,aAAd,C;UACI,eAAS,eAAM,KAAN,C;QACb,eAAS,W;QACT,0BAAa,UAAW,wBAAe,KAAf,CAAxB,C;QACA,eAAS,eAAM,KAAN,C;QACT,eAAS,Q;QArCjB,K;;IAwCA,OAAO,I;EACX,C;8CAEA,Y;IACI,eAAS,eAAM,IAAN,C;EACb,C;yDAEA,iB;IACI,IAAI,mBAAJ,C;MAAkB,0BAAa,KAAM,WAAnB,C;;MAAoC,eAAS,eAAM,KAAN,C;EACnE,C;sDAEA,iB;IACI,IAAI,mBAAJ,C;MAAkB,0BAAa,KAAM,WAAnB,C;;MAAoC,eAAS,eAAM,KAAN,C;EACnE,C;uDAEA,iB;IACI,IAAI,mBAAJ,C;MAAkB,0BAAa,KAAM,WAAnB,C;;MAAoC,eAAS,eAAM,KAAN,C;EACnE,C;qDAEA,iB;IACI,IAAI,mBAAJ,C;MAAkB,0BAAa,KAAM,WAAnB,C;;MAAoC,eAAS,eAAM,KAAN,C;EACnE,C;sDAEA,iB;IACI,IAAI,mBAAJ,C;MAAkB,0BAAa,KAAM,WAAnB,C;;MAAoC,eAAS,eAAM,KAAN,C;EACnE,C;uDAEA,iB;IAEI,IAAI,mBAAJ,C;MAAkB,0BAAa,KAAM,WAAnB,C;;MAAoC,eAAS,eAAM,KAAN,C;IAC/D,IAAI,CAAC,oBAAc,gCAAf,IAAkD,CAAO,SAAN,KAAM,CAA7D,C;MACI,MAAM,4BAA4B,KAA5B,EAAmC,eAAS,WAAG,WAA/C,C;KAEd,C;wDAEA,iB;IAEI,IAAI,mBAAJ,C;MAAkB,0BAAa,KAAM,WAAnB,C;;MAAoC,eAAS,eAAM,KAAN,C;IAC/D,IAAI,CAAC,oBAAc,gCAAf,IAAkD,CAAO,WAAN,KAAM,CAA7D,C;MACI,MAAM,4BAA4B,KAA5B,EAAmC,eAAS,WAAG,WAA/C,C;KAEd,C;sDAEA,iB;IACI,0BAAmB,oBAAN,KAAM,CAAnB,C;EACJ,C;wDAEA,iB;IAA2C,eAAS,qBAAY,KAAZ,C;G;sDAEpD,iC;IACI,0BAAa,cAAe,wBAAe,KAAf,CAA5B,C;EACJ,C;EAEuB,iD;IAAC,oB;IAA0C,kB;IAC9D,eAAoB,C;IACpB,8BAAmB,I;G;;;SAAnB,Y;MAAA,kC;K;SAAA,wB;MAAA,0C;K;;mDAGA,Y;IACI,oBAAe,I;IAAM,mC;EACzB,C;qDAEA,Y;IACI,mC;EACJ,C;qDAEA,Y;IACI,oBAAe,K;IACf,IAAI,WAAK,sBAAc,YAAvB,C;MACI,mBAAM,IAAN,C;MACA,YAAO,Y;MjBlDnB,iBAAc,CAAd,UAAsB,KAAtB,U;QiBkD4B,mBAAM,WAAK,sBAAc,kBAAzB,C;;KAExB,C;kDAEA,Y;IACI,IAAI,WAAK,sBAAc,YAAvB,C;MACI,mBAAM,EAAN,C;EACR,C;0DAEA,a;IAAqB,OAAA,eAAG,gBAAO,CAAP,C;G;0DACxB,a;IAAuB,OAAA,eAAG,gBAAO,CAAP,C;G;0DAC1B,a;IAAsB,OAAA,eAAG,gBAAO,CAAP,C;G;0DACzB,a;IAAuB,OAAA,eAAG,gBAAO,CAAP,C;G;0DAC1B,a;IAAqB,OAAA,eAAG,gBAAO,CAAP,C;G;0DACxB,a;IAAsB,OAAA,eAAG,gBAAO,CAAP,C;G;0DACzB,a;IAAoB,OAAA,eAAG,gBAAO,CAAP,C;G;0DACvB,a;IAAqB,OAAA,eAAG,gBAAO,CAAP,C;G;0DACxB,a;IAAwB,OAAA,eAAG,gBAAO,CAAP,C;G;gEAC3B,iB;IAA0C,YAAH,eAAG,EAAY,KAAZ,C;G;;;;;;;;;;;EApM9C,8E;IAAA,8D;IAGI,iCAAK,kCAAS,MAAT,EAAiB,IAAjB,CAAL,EAA6B,IAA7B,EAAmC,IAAnC,EAAyC,cAAzC,C;IAHJ,Y;G;ECbJ,sB;IACI,QAAQ,IAAM,E;IACd,OAAW,IAAI,EAAR,GAA8B,OAAjB,IAAI,EAAJ,IAAiB,CAA9B,GACqB,OAAtB,IAAI,EAAJ,GAAS,EAAT,IAAsB,C;EAChC,C;;EAwBA,uC;IAIsB,IAKJ,I;IARd,yBAAO,MAAP,C;IACA,cAAc,C;IACd,aAAa,KAAM,O;IACnB,aAAU,CAAV,MAAkB,MAAlB,M;MACI,QAAQ,iBAAM,CAAN,CAAS,I;MAGjB,IAAI,KAAK,YAAa,OAAtB,C;QAA4B,Q;MAClB,oBAAa,CAAb,C;MAAA,iB;QAAmB,Q;OAA7B,UAAU,I;MACV,yBAAO,KAAP,EAAc,OAAd,EAAuB,CAAvB,C;MACA,yBAAO,GAAP,C;MACA,UAAU,IAAI,CAAJ,I;;IAEd,yBAAO,KAAP,EAAc,OAAd,EAAuB,MAAvB,C;IACA,yBAAO,MAAP,C;EACJ,C;EAEA,oC;IAIiD,Q;IAAA,uC;IAAA,iB;MAA2B,MAAM,2BAAwB,SAAF,kCAAtB,C;KAAjC,W;G;EAEjD,0C;IAKI,IAAK,SAAL,SAAK,EAAO,MAAP,EAA4B,IAA5B,CAAL,C;MADoD,OACV,I;SAC1C,IAAK,SAAL,SAAK,EAAO,OAAP,EAA6B,IAA7B,CAAL,C;MAFoD,OAET,K;;MAFS,OAG5C,I;G;EAGZ,6B;IAEe,Q;IADX,IAAI,YAAO,IAAP,CAAJ,C;MAAiB,OAAO,I;IACb,oB;IAAX,OAAW,cAAX,C;MAAW,+B;MACP,IAAI,iBAAiB,EAAjB,MAAwB,QAA5B,C;QAAsC,OAAO,I;;IAGjD,OAAO,K;EACX,C;EC5DA,oD;IACsB,IAGyC,IAHzC,EAAN,M;IACR,kBADc,OACd,c;MAAiB,6BAAgB,SAAhB,EAAsB,OAAtB,C;SACjB,kBAFc,OAEd,a;MAAgB,iCAAoB,SAApB,EAA0B,OAA1B,C;SAChB,kBAHc,OAGd,yBAHc,OAGd,EAAgB,sBAAhB,E;MAA4B,kCAAqB,SAArB,EAA2B,gEAA3B,C;;;IAHhC,kB;IAKA,OAAO,KAAM,iCAAwB,YAAxB,C;EACjB,C;EAEA,8E;IAKI,OAA8E,CAAvE,oBAAgB,SAAhB,EAAsB,OAAtB,EAA+B,aAA/B,EAA8C,YAAa,WAA3D,CAAuE,kCAAwB,YAAxB,C;EAClF,C;EAE4C,8C;IAGxC,4B;IAFA,0B;IACA,4B;IAMA,uBAC8B,SAAK,sB;G;;SARnC,Y;MAAA,0B;K;;;SACA,Y;MAAA,2B;K;;;;SAII,Y;MAAQ,OAAA,SAAK,kB;K;;sDAKjB,Y;IAA8B,gB;IAAA,0DAAwB,iCAAxB,4BAAgD,U;G;wDAE9E,Y;IAAgD,6B;G;sEAEhD,wB;IACI,OAAO,yCAAmC,YAAnC,C;EACX,C;0DAEA,iC;IAA0E,gB;G;6DAE1E,sB;IAE4B,UAAjB,M;IADP,oBAAoB,sB;IACI,OAAX,UAAW,K;IACpB,wCAAoB,oCAApB,C;MAA8D,sB;ML+ItE,IAAI,eK/I6E,aL+I7E,YAAJ,C;QACI,MAAM,wBACF,EADE,EAEF,qEKlJwF,ULkJ3B,WAA7D,iDKlJyE,aLkJzE,CAFE,C;OKhJwC,yCAA+B,aAA/B,C;WAC1C,oC;MAA0B,gBAAL,S;MClBtB,U;MAFP,oBDqBY,UCrBsB,8BAAqB,CAArB,C;MAClC,cAAc,aAAc,K;MACrB,IAAI,yCAA4B,gCAAhC,C;QDoB0B,sB;QL4IjC,IAAI,yCAAJ,C;UACI,MAAM,wBACF,EADE,EAEF,sEAA6D,qBAA7D,+DAFE,C;SMhKN,SDmBU,6C;aClBP,IAAI,+BAAc,uBAAlB,C;QDmB2B,sB;QL2IlC,IAAI,wCAAJ,C;UACI,MAAM,wBACF,EADE,EAEF,qEAA6D,qBAA7D,+DAFE,C;SM9JN,SDkBU,8C;;QChBV,MAAM,wBAAwB,aAAxB,C;;MDawB,e;;MAKF,sB;MLyIhC,IAAI,eKzIuC,aLyIvC,aAAJ,C;QACI,MAAM,wBACF,EADE,EAEF,sEK5IkD,UL4IW,WAA7D,iDK5ImC,aL4InC,CAFE,C;OK1IM,qCAA2B,aAA3B,C;;IAPZ,a;EASJ,C;2DAEA,sB;EAEA,C;wDAEA,Y;IAA4C,uD;G;uDAE5C,e;IAEW,gB;IADP,qBAAqB,4BAAe,GAAf,C;IACd,0E;IAAA,mB;MAAoC,MAAM,wBAC7C,EAD6C,EAE7C,+BAA4B,GAA5B,gBAAwC,cAFK,EAEY,sBAAgB,WAF5B,C;KAAjD,OAAO,M;EAIX,C;+DAIA,+B;IACI,OAAe,uBAAf,cAAe,EAAuB,sBAAS,GAAT,CAAc,QAArC,C;G;6DAEnB,e;IAAuD,W;G;oEAEvD,e;IAA6D,mCAAe,GAAf,MAAwB,sB;G;gEAErF,e;IAGsB,Q;IAFlB,YAAY,sBAAS,GAAT,C;IACZ,IAAI,CAAC,SAAK,sBAAc,UAAxB,C;MACI,cAAc,4D;MACd,IAAI,OAAQ,SAAZ,C;QAAsB,MAAM,wBACxB,EADwB,EACpB,8BAA2B,GAA3B,oCAAsD,WADlC,EACgD,sBAAgB,WADhE,C;KAIhC,OAAa,YAAN,KAAM,C;EACjB,C;6DAEA,e;IAA2D,gBAAd,sBAAS,GAAT,C;IAAc,sB;;MAuBnD,qBAvB2E,SAAJ,kBAAI,C;;MAwB7E,gC;QACE,MAAM,wBAAsB,EAAtB,EAA0B,sBAzB6B,MAyB7B,MAA1B,EAA0D,sBAAgB,WAA1E,C;;QAHV,O;;IAtByC,yB;G;8DAC7C,e;IAA4D,gBAAd,sBAAS,GAAT,C;IAAc,sB;;MAsBpD,qBAtB6E,UAAJ,kBAAI,C;;MAuB/E,gC;QACE,MAAM,wBAAsB,EAAtB,EAA0B,sBAxB8B,OAwB9B,MAA1B,EAA0D,sBAAgB,WAA1E,C;;QAHV,O;;IArB0C,yB;G;4DAC9C,e;IAA0D,gBAAd,sBAAS,GAAT,C;IAAc,sB;;MAqBlD,qBArBqE,kB;;MAsBvE,gC;QACE,MAAM,wBAAsB,EAAtB,EAA0B,sBAvB4B,KAuB5B,MAA1B,EAA0D,sBAAgB,WAA1E,C;;QAHV,O;;IApBwC,yB;G;6DAC5C,e;IAA2D,gBAAd,sBAAS,GAAT,C;IAAc,sB;;MAoBnD,qBApBuE,mB;;MAqBzE,gC;QACE,MAAM,wBAAsB,EAAtB,EAA0B,sBAtB6B,MAsB7B,MAA1B,EAA0D,sBAAgB,WAA1E,C;;QAHV,O;;IAnByC,yB;G;8DAE7C,e;IAC+B,gBAAd,sBAAS,GAAT,C;IAAc,sB;;MAiBvB,qBAjB4C,oB;;MAkB9C,gC;QACE,MAAM,wBAAsB,EAAtB,EAA0B,sBAnBC,OAmBD,MAA1B,EAA0D,sBAAgB,WAA1E,C;;QAHV,O;;IAhBA,+B;IACA,gBAAgB,SAAK,sBAAc,gC;IACnC,IAAI,aAAoB,SAAP,MAAO,CAAxB,C;MAAoC,OAAO,M;IAC3C,MAAM,4BAA4B,MAA5B,EAAoC,GAApC,EAAyC,sBAAgB,WAAzD,C;EACV,C;+DAEA,e;IAC+B,gBAAd,sBAAS,GAAT,C;IAAc,sB;;MAUvB,qBAV6C,qB;;MAW/C,gC;QACE,MAAM,wBAAsB,EAAtB,EAA0B,sBAZC,QAYD,MAA1B,EAA0D,sBAAgB,WAA1E,C;;QAHV,O;;IATA,+B;IACA,gBAAgB,SAAK,sBAAc,gC;IACnC,IAAI,aAAoB,WAAP,MAAO,CAAxB,C;MAAoC,OAAO,M;IAC3C,MAAM,4BAA4B,MAA5B,EAAoC,GAApC,EAAyC,sBAAgB,WAAzD,C;EACV,C;6DAEA,e;IAAiE,gBAAd,sBAAS,GAAT,C;IAAc,sB;;MAIzD,qBAJqF,mBAAR,iBAAQ,E;;MAKvF,gC;QACE,MAAM,wBAAsB,EAAtB,EAA0B,sBANmC,MAMnC,MAA1B,EAA0D,sBAAgB,WAA1E,C;;QAHV,O;;IAH+C,yB;G;kDAEnD,uC;;MAEQ,OAAO,gB;;MACT,gC;QACE,MAAM,wBAAsB,EAAtB,EAA0B,sBAAmB,SAAnB,MAA1B,EAA0D,sBAAgB,WAA1E,C;;QAHV,O;;EAKJ,C;+DAEA,e;IAGsB,Q;IAFlB,YAAY,sBAAS,GAAT,C;IACZ,IAAI,CAAC,SAAK,sBAAc,UAAxB,C;MACI,cAAc,4D;MACd,IAAI,CAAC,OAAQ,SAAb,C;QAAuB,MAAM,wBACzB,EADyB,EACrB,6BAA0B,GAA1B,kCAAmD,WAD9B,EAC4C,sBAAgB,WAD5D,C;KAIjC,OAAO,KAAM,Q;EACjB,C;;;;;;EAG8B,2C;IAAkD,mCAAwB,IAAxB,EAA8B,KAA9B,C;IAArC,4B;IAGvC,mBAAQ,aAAR,C;G;;SAHuC,Y;MAAA,2B;K;;8DAM3C,sB;IAAqE,Q;G;0DAErE,e;I/BpHA,IAAI,E+BqHQ,QAAQ,a/BrHhB,CAAJ,C;MACI,c+BoHiC,4D;M/BnHjC,MAAM,8BAAyB,OAAQ,WAAjC,C;K+BoHN,OAAO,U;EACX,C;;;;;;EAG8B,yE;IAG9B,iC;MAAA,oBAAyC,I;IACzC,8B;MAAA,iBAAgD,I;IAChD,mCAAwB,IAAxB,EAA8B,KAA9B,C;IAHA,4B;IACA,4C;IACA,sC;IAEA,kBAAuB,C;G;;SAJvB,Y;MAAA,2B;K;;iDAMA,kC;IAOyB,kBAAD,M;IAHpB,wBAAwB,UAAW,8BAAqB,KAArB,C;IACnC,IAAI,0CAAe,GAAf,gBAAmC,CAAC,iBAAkB,WAA1D,C;MAAsE,OAAO,I;IAC7E,IAAI,OAAA,iBAAkB,KAAlB,kBAAJ,C;MACoB,UAAC,0DAAe,GAAf,+BAAD,4C;MAAA,mB;QACL,OAAO,K;OADlB,gBAAgB,M;MAEhB,gBAAgB,iBAAkB,yBAAgB,SAAhB,C;MAClC,IAAI,cAAa,EAAjB,C;QAAgD,OAAO,I;KAE3D,OAAO,K;EACX,C;yDAEA,sB;IAEqC,Q;IADjC,OAAO,kBAAW,UAAW,cAA7B,C;MACI,WAAsB,oBAAX,UAAW,GAAO,sBAAP,EAAO,8BAAP,Q;MAClB,gBAAQ,U;M7B0ES,U;M6B1ErB,I7B0EwC,CAAnB,4DAAmB,oB6B1EpC,I7B0EoC,C6B1EpC,KAAkB,CAAC,oBAAc,kBAAf,IAAoC,CAAC,wBAAiB,UAAjB,EAA6B,kBAAW,CAAX,IAA7B,EAA2C,IAA3C,CAAvD,CAAJ,C;QACI,OAAO,kBAAW,CAAX,I;;IAGf,OAAO,E;EACX,C;qDAEA,e;IAAwD,OAAM,SAAN,UAAM,EAAS,GAAT,C;G;qDAE9D,sB;IAKI,IAAI,eAAe,qBAAnB,C;MAAmC,OAAO,I;IAC1C,OAAa,oEAAe,UAAf,C;EACjB,C;mDAEA,sB;IAKgB,Q;IAJZ,IAAI,oBAAc,kBAAd,IAAmC,cAAA,UAAW,KAAX,kBAAvC,C;MAA2E,M;IAE3E,YACuB,sBAAX,UAAW,C;IACX,OAAA,UAAM,KAAN,W;IAAZ,OAAY,cAAZ,C;MAAY,qB;MACR,IAAI,CAAQ,KAAR,wBAAiB,aAAO,wBAAP,CAArB,C;QACI,MAAM,oBAAoB,GAApB,EAAyB,UAAM,WAA/B,C;;EAGlB,C;;;;;;EAG4B,yC;IAA+C,2BAAgB,IAAhB,EAAsB,KAAtB,C;IAAlC,4B;IACzC,cAA8B,OAAX,UAAM,KAAK,C;IAC9B,cAAwB,WAAK,KAAL,GAAY,CAAZ,I;IACxB,kBAAuB,E;G;;SAHkB,Y;MAAA,2B;K;;qDAKzC,uB;IACI,QAAQ,QAAQ,CAAR,I;IACR,OAAO,wBAAK,CAAL,C;EACX,C;4DAEA,sB;IACI,OAAO,mBAAW,cAAO,CAAP,IAAX,CAAP,C;MACI,yC;MACA,OAAO,e;;IAEX,OAAO,E;EACX,C;wDAEA,e;IACI,OAAW,kBAAW,CAAX,KAAgB,CAApB,GAAuB,gBAAc,GAAd,CAAvB,GAAqD,SAAN,UAAM,EAAS,GAAT,C;EAChE,C;sDAEA,sB;EAEA,C;;;;;;EAG6B,0C;IAA8C,mCAAwB,IAAxB,EAA8B,KAA9B,C;IAAjC,4B;IAC1C,cAAmB,UAAM,K;IACzB,sBAA2B,E;G;;SAFe,Y;MAAA,2B;K;;sDAI1C,uB;IAAuE,OAAC,KAAO,W;G;yDAE/E,e;IACI,OAAO,uBAAU,MAAJ,GAAI,CAAV,C;EACX,C;6DAEA,sB;IACI,OAAO,uBAAe,cAAO,CAAP,IAAf,CAAP,C;MACI,iD;MACA,OAAO,mB;;IAEX,OAAO,E;EACX,C;;;;;;;EAMJ,iD;IAKI,YAAY,kCAAgB,IAAhB,C;IACZ,IAAI,UAAS,EAAb,C;MACI,MAAM,4BAAyB,oBAAF,6CAAkD,IAAlD,MAAvB,C;IACV,OAAO,K;EACX,C;EL9PwC,0C;IAAA,qB;MAAE,mBAAS,E;MAAG,W;IAAA,C;G;EAFtD,iD;IACI,sB;IACA,cAAc,oBAAgB,SAAhB,EAAsB,wBAAtB,C;IACd,OAAQ,iCAAwB,UAAxB,EAAoC,KAApC,C;IACR,OAAO,iD;EACX,C;EAG4C,qD;IAGxC,4B;IAFA,0B;IACA,kC;IAMA,uBAC8B,SAAK,sB;IAEnC,0BAA+B,K;G;;SAV/B,Y;MAAA,0B;K;;;;SAKI,Y;MAAQ,OAAA,SAAK,kB;K;;gEAOjB,mB;IACI,qCAAwB,mCAAxB,EAA+C,OAA/C,C;EACJ,C;yEAEA,6B;IACI,OAAA,oBAAc,e;G;0DAElB,iC;IAA0E,gB;G;iDAK1E,Y;IACc,Q;IAAA,4B;IAAA,iB;MAAoB,OAAO,oBAAa,sBAAb,C;KAArC,UAAU,I;IACV,4BAAiB,GAAjB,C;EACJ,C;6DAEA,e;IAA6C,wBAAW,GAAX,EAAgB,sBAAhB,C;G;8DAE7C,sB;IAAwD,wBAAW,GAAX,EAAgB,gBAAc,KAAd,CAAhB,C;G;+DACxD,sB;IAA0D,wBAAW,GAAX,EAAgB,gBAAc,KAAd,CAAhB,C;G;gEAC1D,sB;IAA4D,wBAAW,GAAX,EAAgB,gBAAc,KAAd,CAAhB,C;G;+DAC5D,sB;IAA0D,wBAAW,GAAX,EAAgB,gBAAc,KAAd,CAAhB,C;G;gEAE1D,sB;IAEI,wBAAW,GAAX,EAAgB,gBAAc,KAAd,CAAhB,C;IACA,IAAI,CAAC,oBAAc,gCAAf,IAAkD,CAAO,SAAN,KAAM,CAA7D,C;MACI,MAAM,8BAA4B,KAA5B,EAAmC,GAAnC,EAAwC,iBAAa,WAArD,C;KAEd,C;sEAEA,6B;IAEI,IAAI,kCAA4B,eAAA,UAAW,WAAW,KAAtB,oBAAgD,UAAW,WAAW,KAAtB,oBAA5E,CAAJ,C;;QDrDwC,gB;QAJ5C,IAAI,eC0D0B,UD1D1B,oCAAmD,SAAK,sBAAc,qBAA1E,C;UC0D8B,UDzDf,yBCyD2B,KDzD3B,C;UACX,iC;SAEJ,uBAAuB,2BAAqB,qBCsDd,UDtDc,4CAArB,EAA+D,uBCsD5C,KDtD4C,4BAA/D,C;QCsD4B,0BAAmB,I;QDpDtE,gBAAiB,yBCoDyB,KDpDzB,C;;;;MCqDmC,gBAAzC,yBAAqB,SAArB,EAA2B,mBAA3B,C;MdSX,ScRQ,mD;MdQR,ScPQ,mBAAqB,qBAArB,C;;EAER,C;iEAEA,sB;IAEI,wBAAW,GAAX,EAAgB,gBAAc,KAAd,CAAhB,C;IACA,IAAI,CAAC,oBAAc,gCAAf,IAAkD,CAAO,WAAN,KAAM,CAA7D,C;MACI,MAAM,8BAA4B,KAA5B,EAAmC,GAAnC,EAAwC,iBAAa,WAArD,C;KAEd,C;kEAEA,sB;IAAgE,wBAAW,GAAX,EAAgB,gBAAc,KAAd,CAAhB,C;G;+DAChE,sB;IAA0D,wBAAW,GAAX,EAAgB,gBAAoB,oBAAN,KAAM,CAApB,CAAhB,C;G;iEAC1D,sB;IAA8D,wBAAW,GAAX,EAAgB,gBAAc,KAAd,CAAhB,C;G;+DAC9D,wC;IAII,wBAAW,GAAX,EAAgB,gBAAc,cAAe,wBAAe,OAAf,CAA7B,CAAhB,C;G;gEAEJ,sB;IACI,wBAAW,GAAX,EAAgB,gBAAc,KAAM,WAApB,CAAhB,C;EACJ,C;EAKa,qF;IAAA,uB;MAAU,gDAAW,uCAAX,EAAuB,IAAvB,C;MAA6B,W;IAAA,C;G;6DAHpD,sB;IAKmC,UAAjB,M;IAJd,eACQ,6BAAJ,GAA8B,mBAA9B,GACK,mD;IAEsB,OAAX,UAAW,K;IAC3B,wCAAoB,oCAApB,C;MAA0C,iCAAoB,SAApB,EAA0B,QAA1B,C;SAC1C,oC;MAA0B,gBAAL,S;MMlEtB,U;MAFP,oBNqEY,UMrEsB,8BAAqB,CAArB,C;MAClC,cAAc,aAAc,K;MACrB,IAAI,yCAA4B,gCAAhC,C;QACH,SNmEU,uBAAmB,SAAnB,W;aMlEP,IAAI,+BAAc,uBAAlB,C;QACH,SNkEU,wBAAoB,SAApB,W;;QMhEV,MAAM,wBAAwB,aAAxB,C;;MN6DwB,e;;MAKlB,6BAAgB,SAAhB,EAAsB,QAAtB,C;IAPZ,oB;IAUA,IAAI,uBAAJ,C;MACI,0BAAmB,K;MACnB,OAAQ,oBAAW,oBAAc,mBAAzB,EAA6C,gBAAc,UAAW,WAAzB,CAA7C,C;KAGZ,OAAO,O;EACX,C;wDAEA,sB;IACI,oBAAa,iBAAb,C;EACJ,C;;;;;;;EAK8B,kD;IAG9B,mCAAwB,IAAxB,EAA8B,YAA9B,C;IACA,iBAAoC,I;IAGhC,mBAAQ,aAAR,C;G;sDAGJ,wB;I1BzGA,IAAI,E0B0GQ,QAAQ,a1B1GhB,CAAJ,C;MACI,c0ByGiC,8D;M1BxGjC,MAAM,8BAAyB,OAAQ,WAAjC,C;KAFV,IAAI,E0B2GQ,sB1B3GR,CAAJ,C;MACI,gB0B0G2B,wF;M1BzG3B,MAAM,8BAAyB,SAAQ,WAAjC,C;K0B0GN,iBAAU,O;EACd,C;8CAEA,Y;IACI,YAAe,c;IAAf,yB;I1BnFJ,IAAI,aAAJ,C;MACI,c0BkF0B,0F;M1BjF1B,MAAM,8BAAyB,OAAQ,WAAjC,C;;MAEN,wBAAO,K;;I0B+EP,4B;G;;;;;;EAG0B,6C;IAE9B,mCAAwB,IAAxB,EAA8B,YAA9B,C;IAEA,iBxB3C0D,oB;G;iDwB6C1D,wB;IACI,cxB0FJ,awB1FY,GxB0FZ,EwB1FmB,OxB0FnB,C;EwBzFA,C;yCAEA,Y;IAAyC,sBAAW,cAAX,C;G;;;;;;EAGb,gD;IAAoD,2BAAgB,IAAhB,EAAsB,YAAtB,C;IAChF,uC;IACA,eAAoB,I;G;;;SADpB,Y;;;MAAA,yB;K;SAAA,e;MAAA,wB;K;;oDAGA,wB;IAEoB,IAAN,I;IADV,IAAI,YAAJ,C;MAEQ,kBADQ,OACR,iB;QAA4B,OAAR,OAAQ,Q;WAC5B,kBAFQ,OAER,c;QAAiB,MAAM,wBAAwB,kCAAqB,WAA7C,C;WACvB,kBAHQ,OAGR,a;QAAgB,MAAM,wBAAwB,iCAAoB,WAA5C,C;;;MAH1B,iB;MAKA,eAAQ,K;;MAER,8B;MAAA,YAAQ,U;MxBuEhB,sBAAI,KAAJ,EwBvEuB,OxBuEvB,C;MwBtEQ,eAAQ,I;;EAEhB,C;4CAEA,Y;IACI,OAAO,eAAW,cAAX,C;EACX,C;;;;;;EAG6B,iD;IAC7B,mCAAwB,IAAxB,EAA8B,YAA9B,C;IACA,evBzFgD,gB;G;sDuB0FhD,6B;IAA6E,OAAA,KAAM,W;G;qDAEnF,wB;IACI,UAAc,MAAJ,GAAI,C;IACd,YAAM,aAAI,GAAJ,EAAS,OAAT,C;EACV,C;6CAEA,Y;IAAyC,qBAAU,YAAV,C;G;;;;;;gJAG7C,yB;IAAA,gC;IAAA,+F;IAAA,8C;MAEI,IAAI,WAAJ,C;QACI,MAAM,sBACF,EADE,EAEF,+DAAkD,UAAW,WAA7D,iDAAoF,KAApF,CAFE,C;OAKV,OAAO,K;IACX,C;GATA,C;EM3L6B,8C;IAA7B,e;IAA8B,+B;IAA2B,2B;IAAzD,iB;IAAA,uB;IAMI,eACoB,iBAAiB,qBAAjB,C;IACpB,aACkB,iBAAiB,mBAAjB,C;G;EATtB,gC;IAAA,mC;K;IACI,iDAAI,SAAJ,EAAe,OAAf,C;IACA,mDAAK,UAAL,EAAiB,QAAjB,C;IACA,iDAAI,SAAJ,EAAe,OAAf,C;IACA,2DAAS,UAAT,EAAqB,QAArB,C;G;;EAHA,qC;IAAA,sB;IAAA,6B;G;;EACA,sC;IAAA,sB;IAAA,8B;G;;EACA,qC;IAAA,sB;IAAA,6B;G;;EACA,0C;IAAA,sB;IAAA,kC;G;;;;;;EAJJ,4B;IAAA,iI;G;;EAAA,iC;IAAA,a;MAAA,W;QAAA,kC;MAAA,Y;QAAA,mC;MAAA,W;QAAA,kC;MAAA,gB;QAAA,uC;MAAA,QAAA,kF;;G;;EAYA,qC;IAEe,Q;IAAA,OAAL,IAAK,K;IACP,yC;MADJ,uC;SAEI,qC;MAFJ,mC;SAGI,oC;MAYG,U;MAFP,oBAVuC,IAUL,8BAAqB,CAArB,C;MAClC,cAAc,aAAc,K;MACrB,IAAI,yCAA4B,gCAAhC,C;QACH,oC;aACG,IAAI,+BAAc,uBAAlB,C;QACH,qC;;QAEA,MAAM,wBAAwB,aAAxB,C;;MApBV,a;;MAAA,kC;G;kKAOJ,yB;IAAA,uJ;IAAA,iJ;IAAA,0B;IAAA,mG;IAAA,0D;MAQW,Q;MAFP,oBAAoB,aAAc,8BAAqB,CAArB,C;MAClC,cAAc,aAAc,K;MACrB,IAAI,yCAA4B,gCAAhC,C;QACH,c;aACG,IAAI,+BAAc,uBAAlB,C;QACH,e;;QAEA,MAAM,wBAAwB,aAAxB,C;;MALV,W;IAOJ,C;GAfA,C;ECvBA,6D;IA2BuG,gCAAc,YAAd,EAA4B,OAA5B,C;G;mKAEvG,yB;IAAA,sE;IAAA,8E;I7BbA,6I;IImDA,uI;IAAA,8B;IyBtCA,+C;MAKwC,kBAAlB,2B;MzBmC0C,Q;MyBnC5D,oCzBmC4D,qBJhDrD,0DIgDqD,kCyBnC5D,EAAkD,OAAlD,C;K;GALJ,C;EAOA,uD;IAmB+F,gCAAc,UAAd,EAA0B,KAA1B,C;G;+JAE/F,yB;IAAA,sE;IAAA,0E;I7BzCA,6I;IImDA,uI;IAAA,8B;IyBVA,6C;MAKsC,kBAAlB,2B;MzBO4C,Q;MyBP5D,kCzBO4D,qBJhDrD,0DIgDqD,kCyBP5D,EAAgD,KAAhD,C;K;GALJ,C;;E5BhDA,yD;IAEsB,IAAN,I;IAAA,Q6BT8B,O7BSf,OAAf,C;WACR,S;WAAA,Q;WAAA,Q;QAAiC,iCAAsB,OAAtB,EAA+B,SAA/B,C;QAAjC,K;cAEI,IAAZ,KAAK,QAAW,CAAF,OAAE,CAAJ,C;UACI,4BAAiB,OAAjB,EAA0B,SAA1B,C;;UAEA,wBAAa,OAAb,EAAsB,SAAtB,C;;;QANA,K;;IAAZ,gB;IAUA,OAAO,KAAM,iCAAwB,YAAxB,C;EACjB,C;EAG+B,mC;IAG3B,4B;IAFA,oB;IACA,0B;IAMA,yBAA8B,C;G;;SAN9B,Y;MAAA,0B;K;;;;SAII,Y;MAAQ,OAAA,SAAK,kB;K;;6CAIjB,Y;IAOoB,IAAK,I;IANrB,UAAU,qB;IACV,IAAI,WAAJ,C;MACI,OAAY,kBAAL,SAAK,EAAkB,mCAAY,aAA9B,EAA4C,aAAM,GAAN,CAA5C,C;KAGhB,WAAoB,MAAa,MAAK,YAAL,C;IACjC,WAAgB,QAAK,OAAL,IAAK,OAAL,kC;IS1BpB,cAAc,uB;IT4BN,aAAU,CAAV,gB;MACI,UAAU,KAAK,CAAL,C;MACV,YAAiB,cAAL,SAAK,EAAc,mCAAY,aAA1B,EAAwC,aAAM,GAAN,CAAxC,C;MS7B7B,OT8BY,aAAI,GAAI,WAAR,EAAoB,KAApB,C;;IAJR,OSzBG,OAAQ,Q;ETgCf,C;2DAEA,wB;IACI,OAAO,yCAAmC,YAAnC,C;EACX,C;+CAEA,iC;IAA0E,gB;G;sDAE1E,sB;IAEqC,Q;IADjC,OAAO,yBAAkB,UAAW,cAApC,C;MACI,WAAsB,oBAAX,UAAW,GAAO,6BAAP,EAAO,qCAAP,Q;MACtB,IAAI,aAAM,IAAN,MAAgB,SAApB,C;QAA+B,OAAO,yBAAkB,CAAlB,I;;IAE1C,OAAO,E;EACX,C;oDAEA,+B;IAC0C,Q;IAAtC,OAAe,uBAAf,cAAe,EAAuB,qCAAS,GAAT,mCAAvB,C;G;4CAEnB,e;IAAoD,oBAAM,GAAN,C;G;kDAEpD,e;IACW,Q;IAAM,YAAY,sBAAS,GAAT,C;IACrB,8B;MAAa,IAAI,KAAM,OAAN,KAAgB,CAApB,C;QAAuB,wBAAM,CAAN,C;;QAAc,MAAM,4BAAyB,KAAF,6CAAvB,C;SACxD,2B;MAAmB,oBAAN,KAAM,C;;MACX,MAAM,4BAAyB,KAAF,6CAAvB,C;IAHlB,wB;EAKJ,C;kDAEA,e;IAEiB,gB;IADb,YAAY,sBAAS,GAAT,C;IACC,yD;IAAA,mB;MAAoB,MAAM,4BAAyB,KAAF,gCAAvB,C;KAAvC,aAAa,M;IACb,OAAO,wBAAiB,MAAjB,C;EACX,C;8CAEA,kB;IACgC,sBAAP,MAAO,C;IAAP,S;MAAqB,OCsNE,MAAW,ODtNP,MCsNO,CDtNb,KAAiB,M;KAA3D,yB;IACA,IAAI,CAAC,cAAL,C;MACI,MAAM,4BAAyB,MAAF,sGAAvB,C;IACV,cC0P0C,MAAW,KD1PnC,MC0PmC,CD1PvC,IAAe,gB;IAC7B,IAAI,CAAC,OAAL,C;MACI,MAAM,4BAAyB,MAAF,gFAAvB,C;IACV,OAAc,uBAAP,MAAO,C;EAClB,C;mDAEA,e;IACY,UACD,M;IADP,QAAQ,8BAAS,GAAT,oBAAiB,uBAAgB,GAAhB,C;IACzB,OAAO,oD;EACX,C;yDAEA,e;IACI,QAAQ,sBAAS,GAAT,C;IACR,IAAI,MAAM,SAAV,C;MAAqB,uBAAgB,GAAhB,C;IAErB,OAAO,S;EACX,C;6CAEA,e;IACI,MAAM,4BAAuB,qBAAkB,GAAlB,gBAAvB,C;EACV,C;kDAEA,sB;IACuB,kBACR,MADQ,EAQZ,M;IARP,mBAAmB,mDAAwB,kBAAxB,4BAAuC,Y;IAEtD,kBADa,UAAW,KACxB,mB;MACI,SAAI,SAAK,sBAAc,qBAAvB,yC;;MAGe,SAAX,UAAW,K;IALvB,iB;IAQI,WADS,IACT,sB;MAAsB,8BAAiB,YAAjB,EAA+B,SAA/B,C;SACtB,WAFS,IAET,qB;MAAqB,6BAAgB,YAAhB,EAA8B,SAA9B,C;;MACb,0BAAa,YAAb,EAA2B,SAA3B,C;IAHZ,a;EAKJ,C;;;;;;EAGyB,sC;IAGzB,wBAAa,KAAb,EAAoB,IAApB,C;IACA,cAA4B,MAAa,MAAK,KAAL,C;IAChB,IAAK,I;IAA9B,cAAwB,CAAC,QAAK,OAAL,WAAK,OAAL,kCAAD,IAAuB,CAAvB,I;IACxB,yBAA8B,E;G;;;SACH,Y;MAAQ,gCAAkB,CAAlB,KAAuB,C;K;;kDAE1D,uB;IAEW,Q;IADP,QAAQ,QAAQ,CAAR,I;IACR,OAAO,2BAAK,CAAL,mC;EACX,C;oDAEA,4B;IAOI,MAAM,4BAAuB,cAAW,GAAX,2BAAkC,IAAlC,UAAyC,KAAzC,WAAvB,C;EACV,C;qDAEA,e;IACI,yB;;MA2B4B,Q;MAH5B,IAAI,YAAJ,C;QACI,YAAY,6BAzBH,GAyBG,C;QACZ,IAAI,4BAAJ,C;UAAsB,wBA1BQ,6D;UA0BR,0B;SACtB,wBAAO,CAAiB,OA3BiC,aA2BlD,KAAM,WA3B4C,CA2BlD,mBAA2B,2BA3BzB,GA2ByB,EAAyB,KAAzB,EA3BpB,MA2BoB,C;QAAlC,0B;OAEJ,wBA7BkC,6D;;;IAAlC,4B;G;sDAEJ,e;IACI,yB;;MAwB4B,Q;MAH5B,IAAI,YAAJ,C;QACI,YAAY,6BAtBH,GAsBG,C;QACZ,IAAI,4BAAJ,C;UAAsB,wBAvBS,8D;UAuBT,0B;SACtB,wBAAO,CAAiB,OAxBmC,cAwBpD,KAAM,WAxB8C,CAwBpD,mBAA2B,2BAxBzB,GAwByB,EAAyB,KAAzB,EAxBpB,OAwBoB,C;QAAlC,0B;OAEJ,wBA1BmC,8D;;;IAAnC,4B;G;oDAEJ,e;IACI,yB;;MAqB4B,Q;MAH5B,IAAI,YAAJ,C;QACI,YAAY,6BAnBH,GAmBG,C;QACZ,IAAI,4BAAJ,C;UAAsB,wBApBO,4D;UAoBP,0B;SACtB,wBAAO,CAAiB,OArB+B,YAqBhD,KAAM,WArB0C,CAqBhD,mBAA2B,2BArBzB,GAqByB,EAAyB,KAAzB,EArBpB,KAqBoB,C;QAAlC,0B;OAEJ,wBAvBiC,4D;;;IAAjC,4B;G;qDAEJ,e;IAAmD,yB;;MAmBnB,Q;MAH5B,IAAI,YAAJ,C;QACI,YAAY,6BAjB4C,GAiB5C,C;QACZ,IAAI,4BAAJ,C;UAAsB,wBAlBuD,6D;UAkBvD,0B;SACE,gBAAjB,KAAM,W;QAlBA,U;QAkBb,wBAAO,CAAiB,OAlB5B,wBAAiB,wDAAoB,gCAAyB,SAAzB,EAA+B,MAA/B,CAArC,CAkBW,mBAA2B,2BAnBsB,GAmBtB,EAAyB,KAAzB,EAnB2B,MAmB3B,C;QAAlC,0B;OAEJ,wBArBiF,6D;;;IAAlC,4B;G;sDAInD,e;IACI,yB;;MAc4B,Q;MAH5B,IAAI,YAAJ,C;QACI,YAAY,6BAZH,GAYG,C;QACZ,IAAI,4BAAJ,C;UAAsB,wBAbS,8D;UAaT,0B;SACtB,wBAAO,CAAiB,OQtFsB,eRsFvC,KAAM,WQtFiC,CRsFvC,mBAA2B,2BAdzB,GAcyB,EAAyB,KAAzB,EAdpB,OAcoB,C;QAAlC,0B;OAEJ,wBAhBmC,8D;;;IAAnC,4B;G;uDAEJ,e;IACI,yB;;MAW4B,Q;MAH5B,IAAI,YAAJ,C;QACI,YAAY,6BATH,GASG,C;QACZ,IAAI,4BAAJ,C;UAAsB,wBAVU,+D;UAUV,0B;SACtB,wBAAO,CAAiB,OAXqC,eAWtD,KAAM,WAXgD,CAWtD,mBAA2B,2BAXzB,GAWyB,EAAyB,KAAzB,EAXpB,QAWoB,C;QAAlC,0B;OAEJ,wBAboC,+D;;;IAApC,4B;G;6CAEJ,6C;IASgC,Q;IAH5B,IAAI,YAAJ,C;MACI,YAAY,6BAAkB,GAAlB,C;MACZ,IAAI,4BAAJ,C;QAAsB,OAAO,OAAO,GAAP,C;MAC7B,OAAO,CAAiB,YAAjB,KAAM,WAAW,CAAjB,mBAA2B,2BAAoB,GAApB,EAAyB,KAAzB,EAAgC,IAAhC,C;KAEtC,OAAO,OAAO,GAAP,C;EACX,C;yDAEA,sB;IAEgB,UACG,M;IAFf,OAAO,0BAAkB,cAAO,CAAP,IAAlB,CAAP,C;MACI,QAAQ,+EAAoB,CAApB,I;MACR,WAAW,6BAAK,CAAL,qC;MACX,IAAI,IAAK,QAAL,CAAW,IAAX,MAAqB,SAAzB,C;QAAoC,OAAO,sB;;IAE/C,OAAO,E;EACX,C;+CAEA,e;IACI,OAAW,yBAAkB,CAAlB,KAAuB,CAA3B,GAA8B,GAA9B,GAAuC,aAAM,GAAN,C;EAClD,C;;;;;;EAG0B,uC;IAG1B,wBAAa,KAAb,EAAoB,IAApB,C;IACmB,IAAM,I;IAAzB,cAAmB,QAAM,OAAN,KAAM,OAAN,kC;IACnB,yBAA8B,E;G;mDAE9B,uB;IAAuE,OAAC,KAAO,W;G;0DAE/E,sB;IACI,OAAO,0BAAkB,cAAO,CAAP,IAAlB,CAAP,C;MACI,QAAQ,aAAM,uDAAN,EAAM,sBAAN,C;MACR,IAAI,MAAM,SAAV,C;QAAqB,OAAO,sB;;IAEhC,OAAO,E;EACX,C;iDAEA,Y;IACI,UAAU,qB;IACV,IAAI,WAAJ,C;MACI,OAAY,kBAAL,SAAK,EAAkB,mCAAY,aAA9B,EAA4C,aAAM,GAAN,CAA5C,C;KSpLpB,cAAc,sB;ITuLY,Q;IAAA,kB;IAAlB,aAAU,CAAV,gB;MStLR,OTuLY,aAAS,kBAAL,SAAK,EAAkB,mCAAY,aAA9B,EAA4C,aAAM,CAAN,CAA5C,CAAT,C;;IAFR,OSpLG,OAAQ,Q;ETyLf,C;;;;;;EAG+B,4C;IAG/B,wBAAa,KAAb,EAAoB,IAApB,C;IAEI,mBAAQ,WAAR,C;G;qDAGJ,e;IAA8C,mB;G;sDAE9C,Y;IAEiB,IAAN,I;IADP,UAAU,YAAM,W;IACT,Q6B/O+B,O7B+OhB,YAAf,C;WACH,S;QAAa,uBAAkB,UAAJ,GAAI,CAAlB,C;QAAb,K;WACA,Q;QACI,QAAY,aAAJ,GAAI,C;QACZ,IAAI,SAAJ,C;UAAe,OAAO,gBAAc,CAAd,C;QACtB,QAAY,eAAJ,GAAI,C;QACZ,IAAI,SAAJ,C;UAAe,OAAO,gBAAc,CAAd,C;QACtB,OAAO,gBAAc,GAAd,C;cAEH,uBAAc,GAAd,C;QATL,K;;IAAP,W;EAWJ,C;;;;;;E8BxPJ,qD;IAqBI,IAAI,cAAA,UAAW,WAAW,KAAtB,oBAA+C,cAAA,UAAW,WAAW,KAAtB,qDAAnD,C;MACI,cAAc,4BAAwB,SAAxB,C;MACd,OAAQ,iCAAwB,UAAxB,EAAoC,KAApC,C;MACR,OAAO,OAAQ,O;KAEnB,gBAAc,yBAAqB,SAArB,EAA2B,KAA3B,C;IACd,SAAQ,iCAAwB,UAAxB,EAAoC,KAApC,C;IACR,OAAO,SAAQ,O;EACnB,C;EAGkC,2D;IAG9B,0B;IAFA,0B;IACA,oD;IAMA,cAAsB,+C;IACtB,+C;IACA,qBAAmC,I;IACnC,mE;IACA,gCAAqC,K;IAErC,0BAG+B,K;G;;SAhB/B,Y;MAAA,0B;K;;;;SAKI,Y;MAAQ,OAAA,SAAK,kB;K;;;;SAGjB,Y;;;MAAA,6B;K;SAAA,mB;MAAA,gC;K;;;;SAEA,Y;;;MAAA,uC;K;SAAA,6B;MAAA,oD;K;;EAQA,6C;IAAA,iD;G;;;;;;;EAAA,yD;IAAA,wD;MAAA,uC;KAAA,iD;G;EAEU,wD;IAAC,0B;IAA0B,wB;IACjC,aAAiB,C;IACjB,6C;G;;;SAAA,Y;;;MAAA,4B;K;SAAA,kB;MAAA,8B;K;;;;;;;EAGJ,uD;IAAA,e;IAAA,iB;IAAA,uB;G;EAAA,qD;IAAA,wD;K;IACI,0F;IAAK,0F;IAAK,4F;G;;EAAV,0D;IAAA,2C;IAAA,kD;G;;EAAK,0D;IAAA,2C;IAAA,kD;G;;EAAK,2D;IAAA,2C;IAAA,mD;G;;;;;;EADd,iD;IAAA,8J;G;;EAAA,sD;IAAA,a;MAAA,W;QAAA,uD;MAAA,W;QAAA,uD;MAAA,Y;QAAA,wD;MAAA,QAAA,uG;;G;;yDAIA,6B;IACI,uBAAgB,K;IAChB,2BAAoB,U;IAGhB,IAAA,cAAQ,UAAR,sD;MAAsC,gCAAyB,cAAQ,MAAR,GAAgB,CAAhB,KAAqB,C;SACpF,IAAA,cAAQ,UAAR,0DAAuC,cAAA,UAAW,KAAX,kBAAvC,C;MAA6E,qBAAc,KAAM,W;;MACzF,qBAAc,UAAW,wBAAe,KAAf,C;IAGrC,OAAO,I;EACX,C;uDAEA,iB;IACI,IAAI,6BAAJ,C;MACI,qBAAc,KAAM,W;WACjB,IAAI,wBAAJ,C;MACH,cAAS,K;;MAET,cAAQ,SAAR,CAAiB,kBAAjB,IAAgC,K;;EAExC,C;sDAEA,iB;IACI,yBAAkB,oBAAN,KAAM,CAAlB,C;EACJ,C;8CAEA,Y;IACI,IAAI,6BAAJ,C;MACI,qBAAc,I;;MAEd,IAAI,4BAAJ,C;QAA2B,M;MAE3B,cAAQ,SAAR,CAAiB,kBAAjB,IAAgC,I;;EAExC,C;sDAEA,iC;IACI,yBAAY,cAAe,wBAAe,KAAf,CAA3B,C;EACJ,C;sDAEA,iB;IACI,eAAe,KAAM,W;IACrB,mC7BsO0C,MAAW,K6BtOd,Q7BsOc,C6BtOlB,GAAgB,gB;IAEnD,IAAI,CAAC,SAAK,sBAAc,UAApB,IAAiC,4BAArC,C;MACI,MAAM,8BACA,KAAF,qFACQ,gEAFN,C;KAMV,IAAI,iCAA0B,4BAA9B,C;MACI,MAAM,8BACF,qBAAkB,KAAlB,2GADE,C;KAKV,yBAAY,QAAZ,C;EACJ,C;uDAEA,iB;IACI,0BAAmB,KAAnB,C;EACJ,C;wDAEA,iB;IACI,IAAI,6BAAJ,C;MACI,+B7BuKwC,MAAW,O6BvKd,K7BuKc,C6BvKpB,KAAgB,K;MAC/C,IAAI,CAAO,WAAN,KAAM,CAAP,IAAqB,wBAAzB,C;QACI,MAAM,8BACF,uBAAoB,KAApB,4EADE,C;QAKd,yBAAY,KAAZ,C;EACJ,C;6DAEA,mB;IACI,qCAAwB,mCAAxB,EAA+C,OAA/C,C;EACJ,C;sEAEA,6B;IACI,OAAA,SAAK,sBAAc,e;G;+CAEvB,+B;IACI,YAAY,8BAAK,SAAL,EAAgB,QAAhB,C;IACZ,eAAe,c;IACf,iBAAU,K;EACd,C;8CAEA,Y;IACI,iBAAU,cAAQ,O;IAClB,gCAAyB,K;EAC7B,C;qDAEA,Y;IAAgC,uBAAW,+C;G;mEAE3C,6B;;MV3J4C,gB;MAJ5C,IAAI,eUgKsB,UVhKtB,oCAAmD,SAAK,sBAAc,qBAA1E,C;QUgK0B,UV/JX,yBU+JuB,KV/JvB,C;QACX,iC;OAEJ,uBAAuB,2BAAqB,qBU4JlB,UV5JkB,4CAArB,EAA+D,uBU4JhD,KV5JgD,4BAA/D,C;MU6Jf,0BAAmB,I;MV3J3B,gBAAiB,yBU0JqB,KV1JrB,C;;;EU6JjB,C;0DAEA,sB;IAEI,IAAI,6BAAJ,C;MACI,MAAM,8BACF,mBAAiB,UAAW,WAA5B,4CACQ,mEAAiE,UAAW,KAA5E,MADR,CADE,C;KAMV,cAAc,wBAAW,UAAX,C;IACd,IAAI,gBAAW,+CAAf,C;MACI,cAAS,gBAAS,OAAT,C;MACT,iBAAU,8BAAK,OAAL,EAAc,WAAd,C;MACV,wBAAiB,c;;MAEjB,YAAY,gBAAS,OAAT,C;MACZ,cAAQ,SAAR,CAAiB,kBAAjB,IAAgC,K;MAChC,iBAAU,KAAV,EAAiB,OAAjB,C;;IAGJ,IAAI,uBAAJ,C;MACI,0BAAmB,K;MACnB,cAAQ,SAAR,CAAiB,SAAK,sBAAc,mBAApC,IAA0D,UAAW,W;KAGzE,uBAAgB,C;IAChB,OAAO,I;EACX,C;8CAEA,qB;IAA6C,QAAM,SAAN,M;WACzC,K;WAAA,K;QADyC,OACT,E;WAChC,M;QAFyC,OAEvB,E;cAFuB,mC;;G;wDAK7C,sB;IACI,iB;EACJ,C;sDAEA,gB;IACoD,Q;IAAA,OAAL,IAAK,K;IAChD,mH;MADqC,uD;SAErC,wCAAoB,oCAApB,C;MAFqC,wD;SAGrC,oC;MAHqC,uD;SAIrC,wE;MnChFyC,MAAM,2BmCkFrC,oGnClFmE,WAA9B,C;;MmC4EV,mC;G;;;;;;EAWR,uC;IAEjC,0B;IADA,0B;IAMA,cAAsB,I;G;;SANtB,Y;MAAA,0B;K;;;;SAII,Y;MAAQ,OAAA,SAAK,kB;K;;iDAIjB,Y;IACI,cAAS,I;EACb,C;yDAEA,iB;IACI,eAAe,KAAM,W;IAErB,IAAI,CAAC,SAAK,sBAAc,UAApB,IAAiC,IAAI,KAAJ,eAAa,gBAAlD,C;MACI,MAAM,8BACA,KAAF,uFACQ,gEAFN,C;KAKV,yBAAY,QAAZ,C;EACJ,C;yDAEA,iB;IACI,yBAAkB,oBAAN,KAAM,CAAlB,C;EACJ,C;0DAEA,iB;IACI,cAAS,K;EACb,C;yDAEA,iC;IAEI,yBAAY,cAAe,wBAAe,KAAf,CAA3B,C;EACJ,C;2DAEA,sB;EACA,C;gEAEA,mB;IACI,qCAAwB,mCAAxB,EAA+C,OAA/C,C;EACJ,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kB5BC8B,M;yBACO,M;sBOzGH,uE;wBACE,8D;gBUhKP,2E;0BACU,wF;6BACG,+F;0BACH,6E;+BACK,2H;SAGtB,M;UAGC,E;UACA,E;cACI,G;YACF,G;eACG,E;aACF,E;WACF,E;eACI,E;YAED,OAAF,CAAE,C;gBACE,G;aAGG,C;cACC,C;kBACI,C;UACR,C;aACG,C;aACA,C;iBACI,C;eACF,C;kBACG,C;gBACF,C;YACJ,E;eACG,E;WACJ,E;YAGN,G;cAGE,G;EAGS,gBAAnB,cAAU,GAAV,C;EAChB,aAAU,CAAV,OAAa,EAAb,M;IACI,SZ0BJ,SY1BI,EAAS,CAAT,EAAY,UAAZ,C;;EAGJ,SZuBA,SYvBA,EAAS,CAAT,EAAe,KAAf,C;EACA,SZsBA,SYtBA,EAAS,EAAT,EAAe,KAAf,C;EACA,SZqBA,SYrBA,EAAS,EAAT,EAAe,KAAf,C;EACA,SZoBA,SYpBA,EAAS,EAAT,EAAe,KAAf,C;EACA,WZmBA,SYnBA,EAAS,KAAT,EAAgB,QAAhB,C;EACA,WZkBA,SYlBA,EAAS,KAAT,EAAgB,QAAhB,C;EACA,WZiBA,SYjBA,EAAS,SAAT,EAAoB,YAApB,C;EACA,WZgBA,SYhBA,EAAS,OAAT,EAAkB,UAAlB,C;EACA,WZeA,SYfA,EAAS,UAAT,EAAqB,aAArB,C;EACA,WZcA,SYdA,EAAS,QAAT,EAAmB,WAAnB,C;EACA,WZaA,SYbA,EAAS,MAAT,EAAiB,SAAjB,C;EACA,WZYA,SYZA,EAAS,UAAT,EAAqB,aAArB,C;SZaO,S;EkBhE0D,kBAA1B,gBAAqB,GAArB,O;EACvC,aAAU,CAAV,OAAa,EAAb,M;IACI,SAAS,UAAU,KAAM,EAAhB,C;IACT,SAAS,UAAU,KAAM,CAAhB,C;IACT,SAAS,UAAU,KAAM,CAAhB,C;IACT,SAAS,UAAU,CAAV,C;IlB0Db,WkBzDI,CAAK,CAAL,IAAU,iCAAK,EAAL,wBAAQ,EAAR,wBAAW,EAAX,wBAAc,EAAd,C;;ElByDd,WkBvDA,CAAK,EAAL,IAAoB,K;ElBuDpB,WkBtDA,CAAK,EAAL,IAAqB,M;ElBsDrB,WkBrDA,CAAK,CAAL,IAAqB,K;ElBqDrB,WkBpDA,CAAK,CAAL,IAAqB,K;ElBoDrB,WkBnDA,CAAK,EAAL,IAAqB,K;ElBmDrB,WkBlDA,CAAK,EAAL,IAAqB,K;ElBkDrB,WkBjDA,CAAK,EAAL,IAAa,K;iBlBkDN,W;yBmBiL+B,uDAClC,+G;kBLrI2B,W;qBrB/G4B,4B;;;;"}